/// <reference lib="es2015.iterable" />
/// <reference path="./gobject2.d.ts" />
/// <reference path="./glib2.d.ts" />

/**
 * Gio 2.0
 *
 * Generated from 2.76.2
 */

declare module "gi://Gio?version=2.0" {
    import GObject from "gi://GObject?version=2.0";
    import GLib from "gi://GLib?version=2.0";

    namespace Gio2 {
        export namespace BusType {
            export const $gtype: GObject.GType<BusType>;
        }

        /**
         * An enumeration for well-known message buses.
         */
        export enum BusType {
            /**
             * An alias for the message bus that activated the process, if any.
             */
            STARTER = -1,
            /**
             * Not a message bus.
             */
            NONE = 0,
            /**
             * The system-wide message bus.
             */
            SYSTEM = 1,
            /**
             * The login session message bus.
             */
            SESSION = 2,
        }

        export namespace ConverterResult {
            export const $gtype: GObject.GType<ConverterResult>;
        }

        /**
         * Results returned from g_converter_convert().
         */
        export enum ConverterResult {
            /**
             * There was an error during conversion.
             */
            ERROR = 0,
            /**
             * Some data was consumed or produced
             */
            CONVERTED = 1,
            /**
             * The conversion is finished
             */
            FINISHED = 2,
            /**
             * Flushing is finished
             */
            FLUSHED = 3,
        }

        export namespace CredentialsType {
            export const $gtype: GObject.GType<CredentialsType>;
        }

        /**
         * Enumeration describing different kinds of native credential types.
         */
        export enum CredentialsType {
            /**
             * Indicates an invalid native credential type.
             */
            INVALID = 0,
            /**
             * The native credentials type is a `struct ucred`.
             */
            LINUX_UCRED = 1,
            /**
             * The native credentials type is a `struct cmsgcred`.
             */
            FREEBSD_CMSGCRED = 2,
            /**
             * The native credentials type is a `struct sockpeercred`. Added in 2.30.
             */
            OPENBSD_SOCKPEERCRED = 3,
            /**
             * The native credentials type is a `ucred_t`. Added in 2.40.
             */
            SOLARIS_UCRED = 4,
            /**
             * The native credentials type is a `struct unpcbid`. Added in 2.42.
             */
            NETBSD_UNPCBID = 5,
            /**
             * The native credentials type is a `struct xucred`. Added in 2.66.
             */
            APPLE_XUCRED = 6,
            /**
             * The native credentials type is a PID `DWORD`. Added in 2.72.
             */
            WIN32_PID = 7,
        }

        export class DBusError extends GLib.Error {
            static $gtype: GObject.GType<DBusError>;

            constructor(options: { message: string; code: number });
            constructor(copy: DBusError);

            // Fields
            /**
             * A generic error; "something went wrong" - see the error message for
             * more.
             */
            static FAILED: number;
            /**
             * There was not enough memory to complete an operation.
             */
            static NO_MEMORY: number;
            /**
             * The bus doesn't know how to launch a service to supply the bus name
             * you wanted.
             */
            static SERVICE_UNKNOWN: number;
            /**
             * The bus name you referenced doesn't exist (i.e. no application owns
             * it).
             */
            static NAME_HAS_NO_OWNER: number;
            /**
             * No reply to a message expecting one, usually means a timeout occurred.
             */
            static NO_REPLY: number;
            /**
             * Something went wrong reading or writing to a socket, for example.
             */
            static IO_ERROR: number;
            /**
             * A D-Bus bus address was malformed.
             */
            static BAD_ADDRESS: number;
            /**
             * Requested operation isn't supported (like ENOSYS on UNIX).
             */
            static NOT_SUPPORTED: number;
            /**
             * Some limited resource is exhausted.
             */
            static LIMITS_EXCEEDED: number;
            /**
             * Security restrictions don't allow doing what you're trying to do.
             */
            static ACCESS_DENIED: number;
            /**
             * Authentication didn't work.
             */
            static AUTH_FAILED: number;
            /**
             * Unable to connect to server (probably caused by ECONNREFUSED on a
             * socket).
             */
            static NO_SERVER: number;
            /**
             * Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
             * %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
             * this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
             * exists. We can't fix it for compatibility reasons so just be
             * careful.
             */
            static TIMEOUT: number;
            /**
             * No network access (probably ENETUNREACH on a socket).
             */
            static NO_NETWORK: number;
            /**
             * Can't bind a socket since its address is in use (i.e. EADDRINUSE).
             */
            static ADDRESS_IN_USE: number;
            /**
             * The connection is disconnected and you're trying to use it.
             */
            static DISCONNECTED: number;
            /**
             * Invalid arguments passed to a method call.
             */
            static INVALID_ARGS: number;
            /**
             * Missing file.
             */
            static FILE_NOT_FOUND: number;
            /**
             * Existing file and the operation you're using does not silently overwrite.
             */
            static FILE_EXISTS: number;
            /**
             * Method name you invoked isn't known by the object you invoked it on.
             */
            static UNKNOWN_METHOD: number;
            /**
             * Certain timeout errors, e.g. while starting a service. Warning: this is
             * confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
             * can't fix it for compatibility reasons so just be careful.
             */
            static TIMED_OUT: number;
            /**
             * Tried to remove or modify a match rule that didn't exist.
             */
            static MATCH_RULE_NOT_FOUND: number;
            /**
             * The match rule isn't syntactically valid.
             */
            static MATCH_RULE_INVALID: number;
            /**
             * While starting a new process, the exec() call failed.
             */
            static SPAWN_EXEC_FAILED: number;
            /**
             * While starting a new process, the fork() call failed.
             */
            static SPAWN_FORK_FAILED: number;
            /**
             * While starting a new process, the child exited with a status code.
             */
            static SPAWN_CHILD_EXITED: number;
            /**
             * While starting a new process, the child exited on a signal.
             */
            static SPAWN_CHILD_SIGNALED: number;
            /**
             * While starting a new process, something went wrong.
             */
            static SPAWN_FAILED: number;
            /**
             * We failed to setup the environment correctly.
             */
            static SPAWN_SETUP_FAILED: number;
            /**
             * We failed to setup the config parser correctly.
             */
            static SPAWN_CONFIG_INVALID: number;
            /**
             * Bus name was not valid.
             */
            static SPAWN_SERVICE_INVALID: number;
            /**
             * Service file not found in system-services directory.
             */
            static SPAWN_SERVICE_NOT_FOUND: number;
            /**
             * Permissions are incorrect on the setuid helper.
             */
            static SPAWN_PERMISSIONS_INVALID: number;
            /**
             * Service file invalid (Name, User or Exec missing).
             */
            static SPAWN_FILE_INVALID: number;
            /**
             * Tried to get a UNIX process ID and it wasn't available.
             */
            static SPAWN_NO_MEMORY: number;
            /**
             * Tried to get a UNIX process ID and it wasn't available.
             */
            static UNIX_PROCESS_ID_UNKNOWN: number;
            /**
             * A type signature is not valid.
             */
            static INVALID_SIGNATURE: number;
            /**
             * A file contains invalid syntax or is otherwise broken.
             */
            static INVALID_FILE_CONTENT: number;
            /**
             * Asked for SELinux security context and it wasn't available.
             */
            static SELINUX_SECURITY_CONTEXT_UNKNOWN: number;
            /**
             * Asked for ADT audit data and it wasn't available.
             */
            static ADT_AUDIT_DATA_UNKNOWN: number;
            /**
             * There's already an object with the requested object path.
             */
            static OBJECT_PATH_IN_USE: number;
            /**
             * Object you invoked a method on isn't known. Since 2.42
             */
            static UNKNOWN_OBJECT: number;
            /**
             * Interface you invoked a method on isn't known by the object. Since 2.42
             */
            static UNKNOWN_INTERFACE: number;
            /**
             * Property you tried to access isn't known by the object. Since 2.42
             */
            static UNKNOWN_PROPERTY: number;
            /**
             * Property you tried to set is read-only. Since 2.42
             */
            static PROPERTY_READ_ONLY: number;

            // Members
            /**
             * Creates a D-Bus error name to use for `error.` If `error `matches
             * a registered error (cf. g_dbus_error_register_error()), the corresponding
             * D-Bus error name will be returned.
             *
             * Otherwise the a name of the form
             * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
             * will be used. This allows other GDBus applications to map the error
             * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
             *
             * This function is typically only used in object mappings to put a
             * #GError on the wire. Regular applications should not use it.
             */
            static encode_gerror(error: GLib.Error): string;
            /**
             * Gets the D-Bus error name used for error, if any.
             *
             * This function is guaranteed to return a D-Bus error name for all
             * #GErrors returned from functions handling remote method calls
             * (e.g. g_dbus_connection_call_finish()) unless
             * g_dbus_error_strip_remote_error() has been used on `error.`
             */
            static get_remote_error(error: GLib.Error): string | null;
            /**
             * Checks if `error `represents an error received via D-Bus from a remote peer. If so,
             * use g_dbus_error_get_remote_error() to get the name of the error.
             */
            static is_remote_error(error: GLib.Error): boolean;
            /**
             * Creates a #GError based on the contents of `dbus_error_name `and
             * `dbus_error_message.`
             *
             * Errors registered with g_dbus_error_register_error() will be looked
             * up using `dbus_error_name `and if a match is found, the error domain
             * and code is used. Applications can use g_dbus_error_get_remote_error()
             * to recover `dbus_error_name.`
             *
             * If a match against a registered error is not found and the D-Bus
             * error name is in a form as returned by g_dbus_error_encode_gerror()
             * the error domain and code encoded in the name is used to
             * create the #GError. Also, `dbus_error_name `is added to the error message
             * such that it can be recovered with g_dbus_error_get_remote_error().
             *
             * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
             * in the %G_IO_ERROR error domain is returned. Also, `dbus_error_name `is
             * added to the error message such that it can be recovered with
             * g_dbus_error_get_remote_error().
             *
             * In all three cases, `dbus_error_name `can always be recovered from the
             * returned #GError using the g_dbus_error_get_remote_error() function
             * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
             *
             * This function is typically only used in object mappings to prepare
             * #GError instances for applications. Regular applications should not use
             * it.
             */
            static new_for_dbus_error(dbus_error_name: string, dbus_error_message: string): GLib.Error;
            static quark(): GLib.Quark;
            /**
             * Creates an association to map between `dbus_error_name `and
             * #GErrors specified by `error_domain `and `error_code.`
             *
             * This is typically done in the routine that returns the #GQuark for
             * an error domain.
             */
            static register_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
            /**
             * Helper function for associating a #GError error domain with D-Bus error names.
             *
             * While `quark_volatile `has a `volatile` qualifier, this is a historical
             * artifact and the argument passed to it should not be `volatile`.
             */
            static register_error_domain(
                error_domain_quark_name: string,
                quark_volatile: number,
                entries: DBusErrorEntry[]
            ): void;
            /**
             * Does nothing if `error `is %NULL. Otherwise sets *`error `to
             * a new #GError created with g_dbus_error_new_for_dbus_error()
             * with `dbus_error_message `prepend with `format `(unless %NULL).
             */
            static set_dbus_error(
                error: GLib.Error,
                dbus_error_name: string,
                dbus_error_message: string,
                format: string | null,
                ___: any[]
            ): void;
            /**
             * Like g_dbus_error_set_dbus_error() but intended for language bindings.
             */
            static set_dbus_error_valist(
                error: GLib.Error,
                dbus_error_name: string,
                dbus_error_message: string,
                format: string | null,
                var_args: any
            ): void;
            /**
             * Looks for extra information in the error message used to recover
             * the D-Bus error name and strips it if found. If stripped, the
             * message field in `error `will correspond exactly to what was
             * received on the wire.
             *
             * This is typically used when presenting errors to the end user.
             */
            static strip_remote_error(error: GLib.Error): boolean;
            /**
             * Destroys an association previously set up with g_dbus_error_register_error().
             */
            static unregister_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
        }

        export namespace DBusMessageByteOrder {
            export const $gtype: GObject.GType<DBusMessageByteOrder>;
        }

        /**
         * Enumeration used to describe the byte order of a D-Bus message.
         */
        export enum DBusMessageByteOrder {
            /**
             * The byte order is big endian.
             */
            BIG_ENDIAN = 66,
            /**
             * The byte order is little endian.
             */
            LITTLE_ENDIAN = 108,
        }

        export namespace DBusMessageHeaderField {
            export const $gtype: GObject.GType<DBusMessageHeaderField>;
        }

        /**
         * Header fields used in #GDBusMessage.
         */
        export enum DBusMessageHeaderField {
            /**
             * Not a valid header field.
             */
            INVALID = 0,
            /**
             * The object path.
             */
            PATH = 1,
            /**
             * The interface name.
             */
            INTERFACE = 2,
            /**
             * The method or signal name.
             */
            MEMBER = 3,
            /**
             * The name of the error that occurred.
             */
            ERROR_NAME = 4,
            /**
             * The serial number the message is a reply to.
             */
            REPLY_SERIAL = 5,
            /**
             * The name the message is intended for.
             */
            DESTINATION = 6,
            /**
             * Unique name of the sender of the message (filled in by the bus).
             */
            SENDER = 7,
            /**
             * The signature of the message body.
             */
            SIGNATURE = 8,
            /**
             * The number of UNIX file descriptors that accompany the message.
             */
            NUM_UNIX_FDS = 9,
        }

        export namespace DBusMessageType {
            export const $gtype: GObject.GType<DBusMessageType>;
        }

        /**
         * Message types used in #GDBusMessage.
         */
        export enum DBusMessageType {
            /**
             * Message is of invalid type.
             */
            INVALID = 0,
            /**
             * Method call.
             */
            METHOD_CALL = 1,
            /**
             * Method reply.
             */
            METHOD_RETURN = 2,
            /**
             * Error reply.
             */
            ERROR = 3,
            /**
             * Signal emission.
             */
            SIGNAL = 4,
        }

        export namespace DataStreamByteOrder {
            export const $gtype: GObject.GType<DataStreamByteOrder>;
        }

        /**
         * #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
         * across various machine architectures.
         */
        export enum DataStreamByteOrder {
            /**
             * Selects Big Endian byte order.
             */
            BIG_ENDIAN = 0,
            /**
             * Selects Little Endian byte order.
             */
            LITTLE_ENDIAN = 1,
            /**
             * Selects endianness based on host machine's architecture.
             */
            HOST_ENDIAN = 2,
        }

        export namespace DataStreamNewlineType {
            export const $gtype: GObject.GType<DataStreamNewlineType>;
        }

        /**
         * #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
         */
        export enum DataStreamNewlineType {
            /**
             * Selects "LF" line endings, common on most modern UNIX platforms.
             */
            LF = 0,
            /**
             * Selects "CR" line endings.
             */
            CR = 1,
            /**
             * Selects "CR, LF" line ending, common on Microsoft Windows.
             */
            CR_LF = 2,
            /**
             * Automatically try to handle any line ending type.
             */
            ANY = 3,
        }

        export namespace DriveStartStopType {
            export const $gtype: GObject.GType<DriveStartStopType>;
        }

        /**
         * Enumeration describing how a drive can be started/stopped.
         */
        export enum DriveStartStopType {
            /**
             * Unknown or drive doesn't support
             * start/stop.
             */
            UNKNOWN = 0,
            /**
             * The stop method will physically
             * shut down the drive and e.g. power down the port the drive is
             * attached to.
             */
            SHUTDOWN = 1,
            /**
             * The start/stop methods are used
             * for connecting/disconnect to the drive over the network.
             */
            NETWORK = 2,
            /**
             * The start/stop methods will
             * assemble/disassemble a virtual drive from several physical
             * drives.
             */
            MULTIDISK = 3,
            /**
             * The start/stop methods will
             * unlock/lock the disk (for example using the ATA &lt;quote&gt;SECURITY
             * UNLOCK DEVICE&lt;/quote&gt; command)
             */
            PASSWORD = 4,
        }

        export namespace EmblemOrigin {
            export const $gtype: GObject.GType<EmblemOrigin>;
        }

        /**
         * GEmblemOrigin is used to add information about the origin of the emblem
         * to #GEmblem.
         */
        export enum EmblemOrigin {
            /**
             * Emblem of unknown origin
             */
            UNKNOWN = 0,
            /**
             * Emblem adds device-specific information
             */
            DEVICE = 1,
            /**
             * Emblem depicts live metadata, such as "readonly"
             */
            LIVEMETADATA = 2,
            /**
             * Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
             */
            TAG = 3,
        }

        export namespace FileAttributeStatus {
            export const $gtype: GObject.GType<FileAttributeStatus>;
        }

        /**
         * Used by g_file_set_attributes_from_info() when setting file attributes.
         */
        export enum FileAttributeStatus {
            /**
             * Attribute value is unset (empty).
             */
            UNSET = 0,
            /**
             * Attribute value is set.
             */
            SET = 1,
            /**
             * Indicates an error in setting the value.
             */
            ERROR_SETTING = 2,
        }

        export namespace FileAttributeType {
            export const $gtype: GObject.GType<FileAttributeType>;
        }

        /**
         * The data types for file attributes.
         */
        export enum FileAttributeType {
            /**
             * indicates an invalid or uninitialized type.
             */
            INVALID = 0,
            /**
             * a null terminated UTF8 string.
             */
            STRING = 1,
            /**
             * a zero terminated string of non-zero bytes.
             */
            BYTE_STRING = 2,
            /**
             * a boolean value.
             */
            BOOLEAN = 3,
            /**
             * an unsigned 4-byte/32-bit integer.
             */
            UINT32 = 4,
            /**
             * a signed 4-byte/32-bit integer.
             */
            INT32 = 5,
            /**
             * an unsigned 8-byte/64-bit integer.
             */
            UINT64 = 6,
            /**
             * a signed 8-byte/64-bit integer.
             */
            INT64 = 7,
            /**
             * a #GObject.
             */
            OBJECT = 8,
            /**
             * a %NULL terminated char **. Since 2.22
             */
            STRINGV = 9,
        }

        export namespace FileMonitorEvent {
            export const $gtype: GObject.GType<FileMonitorEvent>;
        }

        /**
         * Specifies what type of event a monitor event is.
         */
        export enum FileMonitorEvent {
            /**
             * a file changed.
             */
            CHANGED = 0,
            /**
             * a hint that this was probably the last change in a set of changes.
             */
            CHANGES_DONE_HINT = 1,
            /**
             * a file was deleted.
             */
            DELETED = 2,
            /**
             * a file was created.
             */
            CREATED = 3,
            /**
             * a file attribute was changed.
             */
            ATTRIBUTE_CHANGED = 4,
            /**
             * the file location will soon be unmounted.
             */
            PRE_UNMOUNT = 5,
            /**
             * the file location was unmounted.
             */
            UNMOUNTED = 6,
            /**
             * the file was moved -- only sent if the
             * (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
             */
            MOVED = 7,
            /**
             * the file was renamed within the
             * current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
             * flag is set.  Since: 2.46.
             */
            RENAMED = 8,
            /**
             * the file was moved into the
             * monitored directory from another location -- only sent if the
             * %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
             */
            MOVED_IN = 9,
            /**
             * the file was moved out of the
             * monitored directory to another location -- only sent if the
             * %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
             */
            MOVED_OUT = 10,
        }

        export namespace FileType {
            export const $gtype: GObject.GType<FileType>;
        }

        /**
         * Indicates the file's on-disk type.
         *
         * On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
         * use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
         * whether a file is a symlink or not. This is due to the fact that NTFS does
         * not have a single filesystem object type for symbolic links - it has
         * files that symlink to files, and directories that symlink to directories.
         * #GFileType enumeration cannot precisely represent this important distinction,
         * which is why all Windows symlinks will continue to be reported as
         * %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
         */
        export enum FileType {
            /**
             * File's type is unknown.
             */
            UNKNOWN = 0,
            /**
             * File handle represents a regular file.
             */
            REGULAR = 1,
            /**
             * File handle represents a directory.
             */
            DIRECTORY = 2,
            /**
             * File handle represents a symbolic link
             * (Unix systems).
             */
            SYMBOLIC_LINK = 3,
            /**
             * File is a "special" file, such as a socket, fifo,
             * block device, or character device.
             */
            SPECIAL = 4,
            /**
             * File is a shortcut (Windows systems).
             */
            SHORTCUT = 5,
            /**
             * File is a mountable location.
             */
            MOUNTABLE = 6,
        }

        export namespace FilesystemPreviewType {
            export const $gtype: GObject.GType<FilesystemPreviewType>;
        }

        /**
         * Indicates a hint from the file system whether files should be
         * previewed in a file manager. Returned as the value of the key
         * %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
         */
        export enum FilesystemPreviewType {
            /**
             * Only preview files if user has explicitly requested it.
             */
            IF_ALWAYS = 0,
            /**
             * Preview files if user has requested preview of "local" files.
             */
            IF_LOCAL = 1,
            /**
             * Never preview files.
             */
            NEVER = 2,
        }

        export class IOErrorEnum extends GLib.Error {
            static $gtype: GObject.GType<IOErrorEnum>;

            constructor(options: { message: string; code: number });
            constructor(copy: IOErrorEnum);

            // Fields
            /**
             * Generic error condition for when an operation fails
             * and no more specific #GIOErrorEnum value is defined.
             */
            static FAILED: number;
            /**
             * File not found.
             */
            static NOT_FOUND: number;
            /**
             * File already exists.
             */
            static EXISTS: number;
            /**
             * File is a directory.
             */
            static IS_DIRECTORY: number;
            /**
             * File is not a directory.
             */
            static NOT_DIRECTORY: number;
            /**
             * File is a directory that isn't empty.
             */
            static NOT_EMPTY: number;
            /**
             * File is not a regular file.
             */
            static NOT_REGULAR_FILE: number;
            /**
             * File is not a symbolic link.
             */
            static NOT_SYMBOLIC_LINK: number;
            /**
             * File cannot be mounted.
             */
            static NOT_MOUNTABLE_FILE: number;
            /**
             * Filename is too many characters.
             */
            static FILENAME_TOO_LONG: number;
            /**
             * Filename is invalid or contains invalid characters.
             */
            static INVALID_FILENAME: number;
            /**
             * File contains too many symbolic links.
             */
            static TOO_MANY_LINKS: number;
            /**
             * No space left on drive.
             */
            static NO_SPACE: number;
            /**
             * Invalid argument.
             */
            static INVALID_ARGUMENT: number;
            /**
             * Permission denied.
             */
            static PERMISSION_DENIED: number;
            /**
             * Operation (or one of its parameters) not supported
             */
            static NOT_SUPPORTED: number;
            /**
             * File isn't mounted.
             */
            static NOT_MOUNTED: number;
            /**
             * File is already mounted.
             */
            static ALREADY_MOUNTED: number;
            /**
             * File was closed.
             */
            static CLOSED: number;
            /**
             * Operation was cancelled. See #GCancellable.
             */
            static CANCELLED: number;
            /**
             * Operations are still pending.
             */
            static PENDING: number;
            /**
             * File is read only.
             */
            static READ_ONLY: number;
            /**
             * Backup couldn't be created.
             */
            static CANT_CREATE_BACKUP: number;
            /**
             * File's Entity Tag was incorrect.
             */
            static WRONG_ETAG: number;
            /**
             * Operation timed out.
             */
            static TIMED_OUT: number;
            /**
             * Operation would be recursive.
             */
            static WOULD_RECURSE: number;
            /**
             * File is busy.
             */
            static BUSY: number;
            /**
             * Operation would block.
             */
            static WOULD_BLOCK: number;
            /**
             * Host couldn't be found (remote operations).
             */
            static HOST_NOT_FOUND: number;
            /**
             * Operation would merge files.
             */
            static WOULD_MERGE: number;
            /**
             * Operation failed and a helper program has
             * already interacted with the user. Do not display any error dialog.
             */
            static FAILED_HANDLED: number;
            /**
             * The current process has too many files
             * open and can't open any more. Duplicate descriptors do count toward
             * this limit. Since 2.20
             */
            static TOO_MANY_OPEN_FILES: number;
            /**
             * The object has not been initialized. Since 2.22
             */
            static NOT_INITIALIZED: number;
            /**
             * The requested address is already in use. Since 2.22
             */
            static ADDRESS_IN_USE: number;
            /**
             * Need more input to finish operation. Since 2.24
             */
            static PARTIAL_INPUT: number;
            /**
             * The input data was invalid. Since 2.24
             */
            static INVALID_DATA: number;
            /**
             * A remote object generated an error that
             * doesn't correspond to a locally registered #GError error
             * domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
             * error name and g_dbus_error_strip_remote_error() to fix up the
             * message so it matches what was received on the wire. Since 2.26.
             */
            static DBUS_ERROR: number;
            /**
             * Host unreachable. Since 2.26
             */
            static HOST_UNREACHABLE: number;
            /**
             * Network unreachable. Since 2.26
             */
            static NETWORK_UNREACHABLE: number;
            /**
             * Connection refused. Since 2.26
             */
            static CONNECTION_REFUSED: number;
            /**
             * Connection to proxy server failed. Since 2.26
             */
            static PROXY_FAILED: number;
            /**
             * Proxy authentication failed. Since 2.26
             */
            static PROXY_AUTH_FAILED: number;
            /**
             * Proxy server needs authentication. Since 2.26
             */
            static PROXY_NEED_AUTH: number;
            /**
             * Proxy connection is not allowed by ruleset.
             * Since 2.26
             */
            static PROXY_NOT_ALLOWED: number;
            /**
             * Broken pipe. Since 2.36
             */
            static BROKEN_PIPE: number;
            /**
             * Connection closed by peer. Note that this
             * is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
             * "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
             * returned %G_IO_ERROR_FAILED. Now they should all return the same
             * value, which has this more logical name. Since 2.44.
             */
            static CONNECTION_CLOSED: number;
            /**
             * Transport endpoint is not connected. Since 2.44
             */
            static NOT_CONNECTED: number;
            /**
             * Message too large. Since 2.48.
             */
            static MESSAGE_TOO_LARGE: number;
            /**
             * No such device found. Since 2.74
             */
            static NO_SUCH_DEVICE: number;
        }

        export namespace IOModuleScopeFlags {
            export const $gtype: GObject.GType<IOModuleScopeFlags>;
        }

        /**
         * Flags for use with g_io_module_scope_new().
         */
        export enum IOModuleScopeFlags {
            /**
             * No module scan flags
             */
            NONE = 0,
            /**
             * When using this scope to load or
             * scan modules, automatically block a modules which has the same base
             * basename as previously loaded module.
             */
            BLOCK_DUPLICATES = 1,
        }

        export namespace MemoryMonitorWarningLevel {
            export const $gtype: GObject.GType<MemoryMonitorWarningLevel>;
        }

        /**
         * Memory availability warning levels.
         *
         * Note that because new values might be added, it is recommended that applications check
         * #GMemoryMonitorWarningLevel as ranges, for example:
         * |[&lt;!-- language="C" --&gt;
         * if (warning_level &gt; G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
         * drop_caches ();
         * ]|
         */
        export enum MemoryMonitorWarningLevel {
            /**
             * Memory on the device is low, processes
             * should free up unneeded resources (for example, in-memory caches) so they can
             * be used elsewhere.
             */
            LOW = 50,
            /**
             * Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW
             * but the device has even less free memory, so processes should try harder to free
             * up unneeded resources. If your process does not need to stay running, it is a
             * good time for it to quit.
             */
            MEDIUM = 100,
            /**
             * The system will soon start terminating
             * processes to reclaim memory, including background processes.
             */
            CRITICAL = 255,
        }

        export namespace MountOperationResult {
            export const $gtype: GObject.GType<MountOperationResult>;
        }

        /**
         * #GMountOperationResult is returned as a result when a request for
         * information is send by the mounting operation.
         */
        export enum MountOperationResult {
            /**
             * The request was fulfilled and the
             * user specified data is now available
             */
            HANDLED = 0,
            /**
             * The user requested the mount operation
             * to be aborted
             */
            ABORTED = 1,
            /**
             * The request was unhandled (i.e. not
             * implemented)
             */
            UNHANDLED = 2,
        }

        export namespace NetworkConnectivity {
            export const $gtype: GObject.GType<NetworkConnectivity>;
        }

        /**
         * The host's network connectivity state, as reported by #GNetworkMonitor.
         */
        export enum NetworkConnectivity {
            /**
             * The host is not configured with a
             * route to the Internet; it may or may not be connected to a local
             * network.
             */
            LOCAL = 1,
            /**
             * The host is connected to a network, but
             * does not appear to be able to reach the full Internet, perhaps
             * due to upstream network problems.
             */
            LIMITED = 2,
            /**
             * The host is behind a captive portal and
             * cannot reach the full Internet.
             */
            PORTAL = 3,
            /**
             * The host is connected to a network, and
             * appears to be able to reach the full Internet.
             */
            FULL = 4,
        }

        export namespace NotificationPriority {
            export const $gtype: GObject.GType<NotificationPriority>;
        }

        /**
         * Priority levels for #GNotifications.
         */
        export enum NotificationPriority {
            /**
             * the default priority, to be used for the
             * majority of notifications (for example email messages, software updates,
             * completed download/sync operations)
             */
            NORMAL = 0,
            /**
             * for notifications that do not require
             * immediate attention - typically used for contextual background
             * information, such as contact birthdays or local weather
             */
            LOW = 1,
            /**
             * for events that require more attention,
             * usually because responses are time-sensitive (for example chat and SMS
             * messages or alarms)
             */
            HIGH = 2,
            /**
             * for urgent notifications, or notifications
             * that require a response in a short space of time (for example phone calls
             * or emergency warnings)
             */
            URGENT = 3,
        }

        export namespace PasswordSave {
            export const $gtype: GObject.GType<PasswordSave>;
        }

        /**
         * #GPasswordSave is used to indicate the lifespan of a saved password.
         *
         * #Gvfs stores passwords in the Gnome keyring when this flag allows it
         * to, and later retrieves it again from there.
         */
        export enum PasswordSave {
            /**
             * never save a password.
             */
            NEVER = 0,
            /**
             * save a password for the session.
             */
            FOR_SESSION = 1,
            /**
             * save a password permanently.
             */
            PERMANENTLY = 2,
        }

        export namespace PollableReturn {
            export const $gtype: GObject.GType<PollableReturn>;
        }

        /**
         * Return value for various IO operations that signal errors via the
         * return value and not necessarily via a #GError.
         *
         * This enum exists to be able to return errors to callers without having to
         * allocate a #GError. Allocating #GErrors can be quite expensive for
         * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
         *
         * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
         * operation to give details about the error that happened.
         */
        export enum PollableReturn {
            /**
             * Generic error condition for when an operation fails.
             */
            FAILED = 0,
            /**
             * The operation was successfully finished.
             */
            OK = 1,
            /**
             * The operation would block.
             */
            WOULD_BLOCK = -27,
        }

        export class ResolverError extends GLib.Error {
            static $gtype: GObject.GType<ResolverError>;

            constructor(options: { message: string; code: number });
            constructor(copy: ResolverError);

            // Fields
            /**
             * the requested name/address/service was not
             * found
             */
            static NOT_FOUND: number;
            /**
             * the requested information could not
             * be looked up due to a network error or similar problem
             */
            static TEMPORARY_FAILURE: number;
            /**
             * unknown error
             */
            static INTERNAL: number;

            // Members
            /**
             * Gets the #GResolver Error Quark.
             */
            static quark(): GLib.Quark;
        }

        export namespace ResolverRecordType {
            export const $gtype: GObject.GType<ResolverRecordType>;
        }

        /**
         * The type of record that g_resolver_lookup_records() or
         * g_resolver_lookup_records_async() should retrieve. The records are returned
         * as lists of #GVariant tuples. Each record type has different values in
         * the variant tuples returned.
         *
         * %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
         * `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
         * weight, a `guint16` with the port, and a string of the hostname.
         *
         * %G_RESOLVER_RECORD_MX records are returned as variants with the signature
         * `(qs)`, representing a `guint16` with the preference, and a string containing
         * the mail exchanger hostname.
         *
         * %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
         * `(as)`, representing an array of the strings in the text record. Note: Most TXT
         * records only contain a single string, but
         * [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
         * record to contain multiple strings. The RFC which defines the interpretation
         * of a specific TXT record will likely require concatenation of multiple
         * strings if they are present, as with
         * [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
         *
         * %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
         * `(ssuuuuu)`, representing a string containing the primary name server, a
         * string containing the administrator, the serial as a `guint32`, the refresh
         * interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
         * as a `guint32`, and the TTL as a `guint32`.
         *
         * %G_RESOLVER_RECORD_NS records are returned as variants with the signature
         * `(s)`, representing a string of the hostname of the name server.
         */
        export enum ResolverRecordType {
            /**
             * look up DNS SRV records for a domain
             */
            SRV = 1,
            /**
             * look up DNS MX records for a domain
             */
            MX = 2,
            /**
             * look up DNS TXT records for a name
             */
            TXT = 3,
            /**
             * look up DNS SOA records for a zone
             */
            SOA = 4,
            /**
             * look up DNS NS records for a domain
             */
            NS = 5,
        }

        export class ResourceError extends GLib.Error {
            static $gtype: GObject.GType<ResourceError>;

            constructor(options: { message: string; code: number });
            constructor(copy: ResourceError);

            // Fields
            /**
             * no file was found at the requested path
             */
            static NOT_FOUND: number;
            /**
             * unknown error
             */
            static INTERNAL: number;

            // Members
            /**
             * Gets the #GResource Error Quark.
             */
            static quark(): GLib.Quark;
        }

        export namespace SocketClientEvent {
            export const $gtype: GObject.GType<SocketClientEvent>;
        }

        /**
         * Describes an event occurring on a #GSocketClient. See the
         * #GSocketClient::event signal for more details.
         *
         * Additional values may be added to this type in the future.
         */
        export enum SocketClientEvent {
            /**
             * The client is doing a DNS lookup.
             */
            RESOLVING = 0,
            /**
             * The client has completed a DNS lookup.
             */
            RESOLVED = 1,
            /**
             * The client is connecting to a remote
             * host (either a proxy or the destination server).
             */
            CONNECTING = 2,
            /**
             * The client has connected to a remote
             * host.
             */
            CONNECTED = 3,
            /**
             * The client is negotiating
             * with a proxy to connect to the destination server.
             */
            PROXY_NEGOTIATING = 4,
            /**
             * The client has negotiated
             * with the proxy server.
             */
            PROXY_NEGOTIATED = 5,
            /**
             * The client is performing a
             * TLS handshake.
             */
            TLS_HANDSHAKING = 6,
            /**
             * The client has performed a
             * TLS handshake.
             */
            TLS_HANDSHAKED = 7,
            /**
             * The client is done with a particular
             * #GSocketConnectable.
             */
            COMPLETE = 8,
        }

        export namespace SocketFamily {
            export const $gtype: GObject.GType<SocketFamily>;
        }

        /**
         * The protocol family of a #GSocketAddress. (These values are
         * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
         * if available.)
         */
        export enum SocketFamily {
            /**
             * no address family
             */
            INVALID = 0,
            /**
             * the UNIX domain family
             */
            UNIX = 1,
            /**
             * the IPv4 family
             */
            IPV4 = 2,
            /**
             * the IPv6 family
             */
            IPV6 = 10,
        }

        export namespace SocketListenerEvent {
            export const $gtype: GObject.GType<SocketListenerEvent>;
        }

        /**
         * Describes an event occurring on a #GSocketListener. See the
         * #GSocketListener::event signal for more details.
         *
         * Additional values may be added to this type in the future.
         */
        export enum SocketListenerEvent {
            /**
             * The listener is about to bind a socket.
             */
            BINDING = 0,
            /**
             * The listener has bound a socket.
             */
            BOUND = 1,
            /**
             * The listener is about to start
             * listening on this socket.
             */
            LISTENING = 2,
            /**
             * The listener is now listening on
             * this socket.
             */
            LISTENED = 3,
        }

        export namespace SocketProtocol {
            export const $gtype: GObject.GType<SocketProtocol>;
        }

        /**
         * A protocol identifier is specified when creating a #GSocket, which is a
         * family/type specific identifier, where 0 means the default protocol for
         * the particular family/type.
         *
         * This enum contains a set of commonly available and used protocols. You
         * can also pass any other identifiers handled by the platform in order to
         * use protocols not listed here.
         */
        export enum SocketProtocol {
            /**
             * The protocol type is unknown
             */
            UNKNOWN = -1,
            /**
             * The default protocol for the family/type
             */
            DEFAULT = 0,
            /**
             * TCP over IP
             */
            TCP = 6,
            /**
             * UDP over IP
             */
            UDP = 17,
            /**
             * SCTP over IP
             */
            SCTP = 132,
        }

        export namespace SocketType {
            export const $gtype: GObject.GType<SocketType>;
        }

        /**
         * Flags used when creating a #GSocket. Some protocols may not implement
         * all the socket types.
         */
        export enum SocketType {
            /**
             * Type unknown or wrong
             */
            INVALID = 0,
            /**
             * Reliable connection-based byte streams (e.g. TCP).
             */
            STREAM = 1,
            /**
             * Connectionless, unreliable datagram passing.
             * (e.g. UDP)
             */
            DATAGRAM = 2,
            /**
             * Reliable connection-based passing of datagrams
             * of fixed maximum length (e.g. SCTP).
             */
            SEQPACKET = 3,
        }

        export namespace TlsAuthenticationMode {
            export const $gtype: GObject.GType<TlsAuthenticationMode>;
        }

        /**
         * The client authentication mode for a #GTlsServerConnection.
         */
        export enum TlsAuthenticationMode {
            /**
             * client authentication not required
             */
            NONE = 0,
            /**
             * client authentication is requested
             */
            REQUESTED = 1,
            /**
             * client authentication is required
             */
            REQUIRED = 2,
        }

        export namespace TlsCertificateRequestFlags {
            export const $gtype: GObject.GType<TlsCertificateRequestFlags>;
        }

        /**
         * Flags for g_tls_interaction_request_certificate(),
         * g_tls_interaction_request_certificate_async(), and
         * g_tls_interaction_invoke_request_certificate().
         */
        export enum TlsCertificateRequestFlags {
            /**
             * No flags
             */
            NONE = 0,
        }

        export class TlsChannelBindingError extends GLib.Error {
            static $gtype: GObject.GType<TlsChannelBindingError>;

            constructor(options: { message: string; code: number });
            constructor(copy: TlsChannelBindingError);

            // Fields
            /**
             * Either entire binding
             * retrieval facility or specific binding type is not implemented in the
             * TLS backend.
             */
            static NOT_IMPLEMENTED: number;
            /**
             * The handshake is not yet
             * complete on the connection which is a strong requirement for any existing
             * binding type.
             */
            static INVALID_STATE: number;
            /**
             * Handshake is complete but
             * binding data is not available. That normally indicates the TLS
             * implementation failed to provide the binding data. For example, some
             * implementations do not provide a peer certificate for resumed connections.
             */
            static NOT_AVAILABLE: number;
            /**
             * Binding type is not supported
             * on the current connection. This error could be triggered when requesting
             * `tls-server-end-point` binding data for a certificate which has no hash
             * function or uses multiple hash functions.
             */
            static NOT_SUPPORTED: number;
            /**
             * Any other backend error
             * preventing binding data retrieval.
             */
            static GENERAL_ERROR: number;

            // Members
            /**
             * Gets the TLS channel binding error quark.
             */
            static quark(): GLib.Quark;
        }

        export namespace TlsChannelBindingType {
            export const $gtype: GObject.GType<TlsChannelBindingType>;
        }

        /**
         * The type of TLS channel binding data to retrieve from #GTlsConnection
         * or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
         * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
         * binding type is not currently implemented.
         */
        export enum TlsChannelBindingType {
            /**
             * [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
             * type
             */
            UNIQUE = 0,
            /**
             * [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
             * binding type
             */
            SERVER_END_POINT = 1,
            /**
             * [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
             * type. Since: 2.74
             */
            EXPORTER = 2,
        }

        export namespace TlsDatabaseLookupFlags {
            export const $gtype: GObject.GType<TlsDatabaseLookupFlags>;
        }

        /**
         * Flags for g_tls_database_lookup_certificate_for_handle(),
         * g_tls_database_lookup_certificate_issuer(),
         * and g_tls_database_lookup_certificates_issued_by().
         */
        export enum TlsDatabaseLookupFlags {
            /**
             * No lookup flags
             */
            NONE = 0,
            /**
             * Restrict lookup to certificates that have
             * a private key.
             */
            KEYPAIR = 1,
        }

        export class TlsError extends GLib.Error {
            static $gtype: GObject.GType<TlsError>;

            constructor(options: { message: string; code: number });
            constructor(copy: TlsError);

            // Fields
            /**
             * No TLS provider is available
             */
            static UNAVAILABLE: number;
            /**
             * Miscellaneous TLS error
             */
            static MISC: number;
            /**
             * The certificate presented could not
             * be parsed or failed validation.
             */
            static BAD_CERTIFICATE: number;
            /**
             * The TLS handshake failed because the
             * peer does not seem to be a TLS server.
             */
            static NOT_TLS: number;
            /**
             * The TLS handshake failed because the
             * peer's certificate was not acceptable.
             */
            static HANDSHAKE: number;
            /**
             * The TLS handshake failed because
             * the server requested a client-side certificate, but none was
             * provided. See g_tls_connection_set_certificate().
             */
            static CERTIFICATE_REQUIRED: number;
            /**
             * The TLS connection was closed without proper
             * notice, which may indicate an attack. See
             * g_tls_connection_set_require_close_notify().
             */
            static EOF: number;
            /**
             * The TLS handshake failed
             * because the client sent the fallback SCSV, indicating a protocol
             * downgrade attack. Since: 2.60
             */
            static INAPPROPRIATE_FALLBACK: number;
            /**
             * The certificate failed
             * to load because a password was incorrect. Since: 2.72
             */
            static BAD_CERTIFICATE_PASSWORD: number;

            // Members
            /**
             * Gets the TLS error quark.
             */
            static quark(): GLib.Quark;
        }

        export namespace TlsInteractionResult {
            export const $gtype: GObject.GType<TlsInteractionResult>;
        }

        /**
         * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
         * when finishing an interaction request.
         */
        export enum TlsInteractionResult {
            /**
             * The interaction was unhandled (i.e. not
             * implemented).
             */
            UNHANDLED = 0,
            /**
             * The interaction completed, and resulting data
             * is available.
             */
            HANDLED = 1,
            /**
             * The interaction has failed, or was cancelled.
             * and the operation should be aborted.
             */
            FAILED = 2,
        }

        export namespace TlsProtocolVersion {
            export const $gtype: GObject.GType<TlsProtocolVersion>;
        }

        /**
         * The TLS or DTLS protocol version used by a #GTlsConnection or
         * #GDtlsConnection. The integer values of these versions are sequential
         * to ensure newer known protocol versions compare greater than older
         * known versions. Any known DTLS protocol version will compare greater
         * than any SSL or TLS protocol version. The protocol version may be
         * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
         * protocol version that GLib does not yet know about. This means that
         * it's possible for an unknown DTLS protocol version to compare less
         * than the TLS protocol versions.
         */
        export enum TlsProtocolVersion {
            /**
             * No protocol version or unknown protocol version
             */
            UNKNOWN = 0,
            /**
             * SSL 3.0, which is insecure and should not be used
             */
            SSL_3_0 = 1,
            /**
             * TLS 1.0, which is insecure and should not be used
             */
            TLS_1_0 = 2,
            /**
             * TLS 1.1, which is insecure and should not be used
             */
            TLS_1_1 = 3,
            /**
             * TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
             */
            TLS_1_2 = 4,
            /**
             * TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
             */
            TLS_1_3 = 5,
            /**
             * DTLS 1.0, which is insecure and should not be used
             */
            DTLS_1_0 = 201,
            /**
             * DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
             */
            DTLS_1_2 = 202,
        }

        export namespace TlsRehandshakeMode {
            export const $gtype: GObject.GType<TlsRehandshakeMode>;
        }

        /**
         * When to allow rehandshaking. See
         * g_tls_connection_set_rehandshake_mode().
         */
        export enum TlsRehandshakeMode {
            /**
             * Never allow rehandshaking
             */
            NEVER = 0,
            /**
             * Allow safe rehandshaking only
             */
            SAFELY = 1,
            /**
             * Allow unsafe rehandshaking
             */
            UNSAFELY = 2,
        }

        export namespace UnixSocketAddressType {
            export const $gtype: GObject.GType<UnixSocketAddressType>;
        }

        /**
         * The type of name used by a #GUnixSocketAddress.
         * %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
         * socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
         * indicates a socket not bound to any name (eg, a client-side socket,
         * or a socket created with socketpair()).
         *
         * For abstract sockets, there are two incompatible ways of naming
         * them; the man pages suggest using the entire `struct sockaddr_un`
         * as the name, padding the unused parts of the %sun_path field with
         * zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
         * However, many programs instead just use a portion of %sun_path, and
         * pass an appropriate smaller length to bind() or connect(). This is
         * %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
         */
        export enum UnixSocketAddressType {
            /**
             * invalid
             */
            INVALID = 0,
            /**
             * anonymous
             */
            ANONYMOUS = 1,
            /**
             * a filesystem path
             */
            PATH = 2,
            /**
             * an abstract name
             */
            ABSTRACT = 3,
            /**
             * an abstract name, 0-padded
             * to the full length of a unix socket name
             */
            ABSTRACT_PADDED = 4,
        }

        export namespace ZlibCompressorFormat {
            export const $gtype: GObject.GType<ZlibCompressorFormat>;
        }

        /**
         * Used to select the type of data format to use for #GZlibDecompressor
         * and #GZlibCompressor.
         */
        export enum ZlibCompressorFormat {
            /**
             * deflate compression with zlib header
             */
            ZLIB = 0,
            /**
             * gzip file format
             */
            GZIP = 1,
            /**
             * deflate compression with no header
             */
            RAW = 2,
        }
        /**
         * The value returned by handlers of the signals generated by
         * the `gdbus-codegen` tool to indicate that a method call has been
         * handled by an implementation. It is equal to %TRUE, but using
         * this macro is sometimes more readable.
         *
         * In code that needs to be backwards-compatible with older GLib,
         * use %TRUE instead, often written like this:
         *
         * |[
         * g_dbus_method_invocation_return_error (invocation, ...);
         * return TRUE;    // handled
         * ]|
         */
        export const DBUS_METHOD_INVOCATION_HANDLED: boolean;
        /**
         * The value returned by handlers of the signals generated by
         * the `gdbus-codegen` tool to indicate that a method call has not been
         * handled by an implementation. It is equal to %FALSE, but using
         * this macro is sometimes more readable.
         *
         * In code that needs to be backwards-compatible with older GLib,
         * use %FALSE instead.
         */
        export const DBUS_METHOD_INVOCATION_UNHANDLED: boolean;
        /**
         * Extension point for debug control functionality.
         * See [Extending GIO][extending-gio].
         */
        export const DEBUG_CONTROLLER_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for default handler to URI association. See
         * [Extending GIO][extending-gio].
         */
        export const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: string;
        /**
         * The string used to obtain a Unix device path with g_drive_get_identifier().
         */
        export const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: string;
        /**
         * A key in the "access" namespace for checking deletion privileges.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         *
         * This attribute will be %TRUE if the user is able to delete the file.
         */
        export const FILE_ATTRIBUTE_ACCESS_CAN_DELETE: string;
        /**
         * A key in the "access" namespace for getting execution privileges.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         *
         * This attribute will be %TRUE if the user is able to execute the file.
         */
        export const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: string;
        /**
         * A key in the "access" namespace for getting read privileges.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         *
         * This attribute will be %TRUE if the user is able to read the file.
         */
        export const FILE_ATTRIBUTE_ACCESS_CAN_READ: string;
        /**
         * A key in the "access" namespace for checking renaming privileges.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         *
         * This attribute will be %TRUE if the user is able to rename the file.
         */
        export const FILE_ATTRIBUTE_ACCESS_CAN_RENAME: string;
        /**
         * A key in the "access" namespace for checking trashing privileges.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         *
         * This attribute will be %TRUE if the user is able to move the file to
         * the trash.
         */
        export const FILE_ATTRIBUTE_ACCESS_CAN_TRASH: string;
        /**
         * A key in the "access" namespace for getting write privileges.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         *
         * This attribute will be %TRUE if the user is able to write to the file.
         */
        export const FILE_ATTRIBUTE_ACCESS_CAN_WRITE: string;
        /**
         * A key in the "dos" namespace for checking if the file's archive flag
         * is set.
         *
         * This attribute is %TRUE if the archive flag is set.
         *
         * This attribute is only available for DOS file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_DOS_IS_ARCHIVE: string;
        /**
         * A key in the "dos" namespace for checking if the file is a NTFS mount point
         * (a volume mount or a junction point).
         *
         * This attribute is %TRUE if file is a reparse point of type
         * [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
         *
         * This attribute is only available for DOS file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: string;
        /**
         * A key in the "dos" namespace for checking if the file's backup flag
         * is set.
         *
         * This attribute is %TRUE if the backup flag is set.
         *
         * This attribute is only available for DOS file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_DOS_IS_SYSTEM: string;
        /**
         * A key in the "dos" namespace for getting the file NTFS reparse tag.
         *
         * This value is 0 for files that are not reparse points.
         *
         * See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
         * page for possible reparse tag values.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: string;
        /**
         * A key in the "etag" namespace for getting the value of the file's
         * entity tag.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_ETAG_VALUE: string;
        /**
         * A key in the "filesystem" namespace for getting the number of bytes
         * of free space left on the file system.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_FREE: string;
        /**
         * A key in the "filesystem" namespace for checking if the file system
         * is read only.
         *
         * Is set to %TRUE if the file system is read only.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_READONLY: string;
        /**
         * A key in the "filesystem" namespace for checking if the file system
         * is remote.
         *
         * Is set to %TRUE if the file system is remote.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_REMOTE: string;
        /**
         * A key in the "filesystem" namespace for getting the total size (in
         * bytes) of the file system, used in g_file_query_filesystem_info().
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_SIZE: string;
        /**
         * A key in the "filesystem" namespace for getting the file system's type.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_TYPE: string;
        /**
         * A key in the "filesystem" namespace for getting the number of bytes
         * used by data on the file system.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_USED: string;
        /**
         * A key in the "filesystem" namespace for hinting a file manager
         * application whether it should preview (e.g. thumbnail) files on the
         * file system.
         *
         * The value for this key contain a #GFilesystemPreviewType.
         */
        export const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: string;
        /**
         * A key in the "gvfs" namespace that gets the name of the current
         * GVFS backend in use.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_GVFS_BACKEND: string;
        /**
         * A key in the "id" namespace for getting a file identifier.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         *
         * An example use would be during listing files, to avoid recursive
         * directory scanning.
         */
        export const FILE_ATTRIBUTE_ID_FILE: string;
        /**
         * A key in the "id" namespace for getting the file system identifier.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         *
         * An example use would be during drag and drop to see if the source
         * and target are on the same filesystem (default to move) or not (default
         * to copy).
         */
        export const FILE_ATTRIBUTE_ID_FILESYSTEM: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) can be ejected.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) is mountable.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) can be polled.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) can be started.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_START: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) can be stopped.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: string;
        /**
         * A key in the "mountable" namespace for getting the HAL UDI for the mountable
         * file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: string;
        /**
         * A key in the "mountable" namespace for checking if a file (of
         * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: string;
        /**
         * A key in the "mountable" namespace for getting the #GDriveStartStopType.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: string;
        /**
         * A key in the "mountable" namespace for getting the unix device.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: string;
        /**
         * A key in the "mountable" namespace for getting the unix device file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: string;
        /**
         * A key in the "owner" namespace for getting the file owner's group.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_OWNER_GROUP: string;
        /**
         * A key in the "owner" namespace for getting the user name of the
         * file's owner.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_OWNER_USER: string;
        /**
         * A key in the "owner" namespace for getting the real name of the
         * user that owns the file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_OWNER_USER_REAL: string;
        /**
         * A key in the "preview" namespace for getting a #GIcon that can be
         * used to get preview of the file.
         *
         * For example, it may be a low resolution thumbnail without metadata.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
         *
         * The value for this key should contain a #GIcon.
         */
        export const FILE_ATTRIBUTE_PREVIEW_ICON: string;
        /**
         * A key in the "recent" namespace for getting time, when the metadata for the
         * file in `recent:///` was last changed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT64.
         */
        export const FILE_ATTRIBUTE_RECENT_MODIFIED: string;
        /**
         * A key in the "selinux" namespace for getting the file's SELinux
         * context.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         *
         * Note that this attribute is only available if GLib has been built
         * with SELinux support.
         */
        export const FILE_ATTRIBUTE_SELINUX_CONTEXT: string;
        /**
         * A key in the "standard" namespace for getting the amount of disk space
         * that is consumed by the file (in bytes).
         *
         * This will generally be larger than the file size (due to block size
         * overhead) but can occasionally be smaller (for example, for sparse files).
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: string;
        /**
         * A key in the "standard" namespace for getting the content type of the file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         *
         * The value for this key should contain a valid content type.
         */
        export const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: string;
        /**
         * A key in the "standard" namespace for getting the copy name of the file.
         *
         * The copy name is an optional version of the name. If available it's always
         * in UTF8, and corresponds directly to the original filename (only transcoded to
         * UTF8). This is useful if you want to copy the file to another filesystem that
         * might have a different encoding. If the filename is not a valid string in the
         * encoding selected for the filesystem it is in then the copy name will not be set.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_COPY_NAME: string;
        /**
         * A key in the "standard" namespace for getting the description of the file.
         *
         * The description is a utf8 string that describes the file, generally containing
         * the filename, but can also contain further information. Example descriptions
         * could be "filename (on hostname)" for a remote file or "filename (in trash)"
         * for a file in the trash. This is useful for instance as the window title
         * when displaying a directory or for a bookmarks menu.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_DESCRIPTION: string;
        /**
         * A key in the "standard" namespace for getting the display name of the file.
         *
         * A display name is guaranteed to be in UTF-8 and can thus be displayed in
         * the UI. It is guaranteed to be set on every file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: string;
        /**
         * A key in the "standard" namespace for edit name of the file.
         *
         * An edit name is similar to the display name, but it is meant to be
         * used when you want to rename the file in the UI. The display name
         * might contain information you don't want in the new filename (such as
         * "(invalid unicode)" if the filename was in an invalid encoding).
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_EDIT_NAME: string;
        /**
         * A key in the "standard" namespace for getting the fast content type.
         *
         * The fast content type isn't as reliable as the regular one, as it
         * only uses the filename to guess it, but it is faster to calculate than the
         * regular content type.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: string;
        /**
         * A key in the "standard" namespace for getting the icon for the file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
         *
         * The value for this key should contain a #GIcon.
         */
        export const FILE_ATTRIBUTE_STANDARD_ICON: string;
        /**
         * A key in the "standard" namespace for checking if a file is a backup file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_STANDARD_IS_BACKUP: string;
        /**
         * A key in the "standard" namespace for checking if a file is hidden.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: string;
        /**
         * A key in the "standard" namespace for checking if the file is a symlink.
         * Typically the actual type is something else, if we followed the symlink
         * to get the type.
         *
         * On Windows NTFS mountpoints are considered to be symlinks as well.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: string;
        /**
         * A key in the "standard" namespace for checking if a file is virtual.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: string;
        /**
         * A key in the "standard" namespace for checking if a file is
         * volatile. This is meant for opaque, non-POSIX-like backends to
         * indicate that the URI is not persistent. Applications should look
         * at %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: string;
        /**
         * A key in the "standard" namespace for getting the name of the file.
         *
         * The name is the on-disk filename which may not be in any known encoding,
         * and can thus not be generally displayed as is. It is guaranteed to be set on
         * every file.
         *
         * Use %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
         * name in a user interface.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_NAME: string;
        /**
         * A key in the "standard" namespace for getting the file's size (in bytes).
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_STANDARD_SIZE: string;
        /**
         * A key in the "standard" namespace for setting the sort order of a file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
         *
         * An example use would be in file managers, which would use this key
         * to set the order files are displayed. Files with smaller sort order
         * should be sorted first, and files without sort order as if sort order
         * was zero.
         */
        export const FILE_ATTRIBUTE_STANDARD_SORT_ORDER: string;
        /**
         * A key in the "standard" namespace for getting the symbolic icon for the file.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
         *
         * The value for this key should contain a #GIcon.
         */
        export const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: string;
        /**
         * A key in the "standard" namespace for getting the symlink target, if the file
         * is a symlink.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: string;
        /**
         * A key in the "standard" namespace for getting the target URI for the file, in
         * the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_STANDARD_TARGET_URI: string;
        /**
         * A key in the "standard" namespace for storing file types.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         *
         * The value for this key should contain a #GFileType.
         */
        export const FILE_ATTRIBUTE_STANDARD_TYPE: string;
        /**
         * A key in the "thumbnail" namespace for checking if thumbnailing failed.
         *
         * This attribute is %TRUE if thumbnailing failed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAILING_FAILED: string;
        /**
         * A key in the "thumbnail" namespace for checking if thumbnailing failed
         * for the large image.
         *
         * This attribute is %TRUE if thumbnailing failed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: string;
        /**
         * A key in the "thumbnail" namespace for checking if thumbnailing failed
         * for the normal image.
         *
         * This attribute is %TRUE if thumbnailing failed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: string;
        /**
         * A key in the "thumbnail" namespace for checking if thumbnailing failed
         * for the x-large image.
         *
         * This attribute is %TRUE if thumbnailing failed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: string;
        /**
         * A key in the "thumbnail" namespace for checking if thumbnailing failed
         * for the xx-large image.
         *
         * This attribute is %TRUE if thumbnailing failed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: string;
        /**
         * A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
         *
         * This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
         * and %FALSE if the file has been modified since the thumbnail was generated.
         *
         * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
         * it indicates that thumbnailing may be attempted again and may succeed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: string;
        /**
         * A key in the "thumbnail" namespace for checking whether the large
         * thumbnail is outdated.
         *
         * This attribute is %TRUE if the large thumbnail is up-to-date with the file
         * it represents, and %FALSE if the file has been modified since the thumbnail
         * was generated.
         *
         * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE is %TRUE and this attribute
         * is %FALSE, it indicates that thumbnailing may be attempted again and may
         * succeed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: string;
        /**
         * A key in the "thumbnail" namespace for checking whether the normal
         * thumbnail is outdated.
         *
         * This attribute is %TRUE if the normal thumbnail is up-to-date with the file
         * it represents, and %FALSE if the file has been modified since the thumbnail
         * was generated.
         *
         * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL is %TRUE and this attribute
         * is %FALSE, it indicates that thumbnailing may be attempted again and may
         * succeed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: string;
        /**
         * A key in the "thumbnail" namespace for checking whether the x-large
         * thumbnail is outdated.
         *
         * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
         * it represents, and %FALSE if the file has been modified since the thumbnail
         * was generated.
         *
         * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE is %TRUE and this attribute
         * is %FALSE, it indicates that thumbnailing may be attempted again and may
         * succeed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: string;
        /**
         * A key in the "thumbnail" namespace for checking whether the xx-large
         * thumbnail is outdated.
         *
         * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
         * it represents, and %FALSE if the file has been modified since the thumbnail
         * was generated.
         *
         * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE is %TRUE and this attribute
         * is %FALSE, it indicates that thumbnailing may be attempted again and may
         * succeed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: string;
        /**
         * A key in the "thumbnail" namespace for getting the path to the thumbnail
         * image with the biggest size available.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_PATH: string;
        /**
         * A key in the "thumbnail" namespace for getting the path to the large
         * thumbnail image.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: string;
        /**
         * A key in the "thumbnail" namespace for getting the path to the normal
         * thumbnail image.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: string;
        /**
         * A key in the "thumbnail" namespace for getting the path to the x-large
         * thumbnail image.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: string;
        /**
         * A key in the "thumbnail" namespace for getting the path to the xx-large
         * thumbnail image.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: string;
        /**
         * A key in the "time" namespace for getting the time the file was last
         * accessed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
         * contains the time since the file was last accessed, in seconds since the
         * UNIX epoch.
         */
        export const FILE_ATTRIBUTE_TIME_ACCESS: string;
        /**
         * A key in the "time" namespace for getting the nanoseconds of the time
         * the file was last accessed. This should be used in conjunction with
         * #G_FILE_ATTRIBUTE_TIME_ACCESS. Corresponding #GFileAttributeType is
         * %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_ACCESS_NSEC: string;
        /**
         * A key in the "time" namespace for getting the microseconds of the time
         * the file was last accessed.
         *
         * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_ACCESS.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_ACCESS_USEC: string;
        /**
         * A key in the "time" namespace for getting the time the file was last
         * changed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
         * and contains the time since the file was last changed, in seconds since
         * the UNIX epoch.
         *
         * This corresponds to the traditional UNIX ctime.
         */
        export const FILE_ATTRIBUTE_TIME_CHANGED: string;
        /**
         * A key in the "time" namespace for getting the nanoseconds of the time
         * the file was last changed. This should be used in conjunction with
         * #G_FILE_ATTRIBUTE_TIME_CHANGED. Corresponding #GFileAttributeType is
         * %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_CHANGED_NSEC: string;
        /**
         * A key in the "time" namespace for getting the microseconds of the time
         * the file was last changed.
         *
         * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CHANGED.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_CHANGED_USEC: string;
        /**
         * A key in the "time" namespace for getting the time the file was created.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
         * and contains the time since the file was created, in seconds since the UNIX
         * epoch.
         *
         * This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
         * `st_birthtime` or NTFS `ctime`.
         */
        export const FILE_ATTRIBUTE_TIME_CREATED: string;
        /**
         * A key in the "time" namespace for getting the nanoseconds of the time
         * the file was created. This should be used in conjunction with
         * #G_FILE_ATTRIBUTE_TIME_CREATED. Corresponding #GFileAttributeType is
         * %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_CREATED_NSEC: string;
        /**
         * A key in the "time" namespace for getting the microseconds of the time
         * the file was created.
         *
         * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CREATED.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_CREATED_USEC: string;
        /**
         * A key in the "time" namespace for getting the time the file was last
         * modified.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
         * contains the time since the file was modified, in seconds since the UNIX
         * epoch.
         */
        export const FILE_ATTRIBUTE_TIME_MODIFIED: string;
        /**
         * A key in the "time" namespace for getting the nanoseconds of the time
         * the file was last modified. This should be used in conjunction with
         * #G_FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding #GFileAttributeType is
         * %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: string;
        /**
         * A key in the "time" namespace for getting the microseconds of the time
         * the file was last modified.
         *
         * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_MODIFIED.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TIME_MODIFIED_USEC: string;
        /**
         * A key in the "trash" namespace for getting the deletion date and time
         * of a file inside the `trash:///` folder.
         *
         * The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
         */
        export const FILE_ATTRIBUTE_TRASH_DELETION_DATE: string;
        /**
         * A key in the "trash" namespace for getting the number of (toplevel) items
         * that are present in the `trash:///` folder.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_TRASH_ITEM_COUNT: string;
        /**
         * A key in the "trash" namespace for getting the original path of a file
         * inside the `trash:///` folder before it was trashed.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
         */
        export const FILE_ATTRIBUTE_TRASH_ORIG_PATH: string;
        /**
         * A key in the "unix" namespace for getting the number of blocks allocated
         * for the file.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_UNIX_BLOCKS: string;
        /**
         * A key in the "unix" namespace for getting the block size for the file
         * system.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: string;
        /**
         * A key in the "unix" namespace for getting the device id of the device the
         * file is located on (see stat() documentation).
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_DEVICE: string;
        /**
         * A key in the "unix" namespace for getting the group ID for the file.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_GID: string;
        /**
         * A key in the "unix" namespace for getting the inode of the file.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
         */
        export const FILE_ATTRIBUTE_UNIX_INODE: string;
        /**
         * A key in the "unix" namespace for checking if the file represents a
         * UNIX mount point.
         *
         * This attribute is %TRUE if the file is a UNIX mount point.
         *
         * Since 2.58, `/` is considered to be a mount point.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
         */
        export const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: string;
        /**
         * A key in the "unix" namespace for getting the mode of the file
         * (e.g. whether the file is a regular file, symlink, etc).
         *
         * See the documentation for `lstat()`: this attribute is equivalent to
         * the `st_mode` member of `struct stat`, and includes both the file type
         * and permissions.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_MODE: string;
        /**
         * A key in the "unix" namespace for getting the number of hard links
         * for a file.
         *
         * See the documentation for `lstat()`.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_NLINK: string;
        /**
         * A key in the "unix" namespace for getting the device ID for the file
         * (if it is a special file).
         *
         * See the documentation for `lstat()`.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_RDEV: string;
        /**
         * A key in the "unix" namespace for getting the user ID for the file.
         *
         * This attribute is only available for UNIX file systems.
         *
         * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
         */
        export const FILE_ATTRIBUTE_UNIX_UID: string;
        /**
         * Extension point for memory usage monitoring functionality.
         * See [Extending GIO][extending-gio].
         */
        export const MEMORY_MONITOR_EXTENSION_POINT_NAME: string;
        /**
         * The menu item attribute which holds the action name of the item.  Action
         * names are namespaced with an identifier for the action group in which the
         * action resides. For example, "win." for window-specific actions and "app."
         * for application-wide actions.
         *
         * See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
         */
        export const MENU_ATTRIBUTE_ACTION: string;
        /**
         * The menu item attribute that holds the namespace for all action names in
         * menus that are linked from this item.
         */
        export const MENU_ATTRIBUTE_ACTION_NAMESPACE: string;
        /**
         * The menu item attribute which holds the icon of the item.
         *
         * The icon is stored in the format returned by g_icon_serialize().
         *
         * This attribute is intended only to represent 'noun' icons such as
         * favicons for a webpage, or application icons.  It should not be used
         * for 'verbs' (ie: stock icons).
         */
        export const MENU_ATTRIBUTE_ICON: string;
        /**
         * The menu item attribute which holds the label of the item.
         */
        export const MENU_ATTRIBUTE_LABEL: string;
        /**
         * The menu item attribute which holds the target with which the item's action
         * will be activated.
         *
         * See also g_menu_item_set_action_and_target()
         */
        export const MENU_ATTRIBUTE_TARGET: string;
        /**
         * The maximum number of entries in a menu section supported by
         * g_dbus_connection_export_menu_model().
         *
         * The exact value of the limit may change in future GLib versions.
         */
        export const MENU_EXPORTER_MAX_SECTION_SIZE: number;
        /**
         * The name of the link that associates a menu item with a section.  The linked
         * menu will usually be shown in place of the menu item, using the item's label
         * as a header.
         *
         * See also g_menu_item_set_link().
         */
        export const MENU_LINK_SECTION: string;
        /**
         * The name of the link that associates a menu item with a submenu.
         *
         * See also g_menu_item_set_link().
         */
        export const MENU_LINK_SUBMENU: string;
        export const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for network status monitoring functionality.
         * See [Extending GIO][extending-gio].
         */
        export const NETWORK_MONITOR_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for power profile usage monitoring functionality.
         * See [Extending GIO][extending-gio].
         */
        export const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for proxy functionality.
         * See [Extending GIO][extending-gio].
         */
        export const PROXY_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for proxy resolving functionality.
         * See [Extending GIO][extending-gio].
         */
        export const PROXY_RESOLVER_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for #GSettingsBackend functionality.
         */
        export const SETTINGS_BACKEND_EXTENSION_POINT_NAME: string;
        /**
         * Extension point for TLS functionality via #GTlsBackend.
         * See [Extending GIO][extending-gio].
         */
        export const TLS_BACKEND_EXTENSION_POINT_NAME: string;
        /**
         * The purpose used to verify the client certificate in a TLS connection.
         * Used by TLS servers.
         */
        export const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: string;
        /**
         * The purpose used to verify the server certificate in a TLS connection. This
         * is the most common purpose in use. Used by TLS clients.
         */
        export const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: string;
        /**
         * Extension point for #GVfs functionality.
         * See [Extending GIO][extending-gio].
         */
        export const VFS_EXTENSION_POINT_NAME: string;
        /**
         * The string used to obtain the volume class with g_volume_get_identifier().
         *
         * Known volume classes include `device`, `network`, and `loop`. Other
         * classes may be added in the future.
         *
         * This is intended to be used by applications to classify #GVolume
         * instances into different sections - for example a file manager or
         * file chooser can use this information to show `network` volumes under
         * a "Network" heading and `device` volumes under a "Devices" heading.
         */
        export const VOLUME_IDENTIFIER_KIND_CLASS: string;
        /**
         * The string used to obtain a Hal UDI with g_volume_get_identifier().
         */
        export const VOLUME_IDENTIFIER_KIND_HAL_UDI: string;
        /**
         * The string used to obtain a filesystem label with g_volume_get_identifier().
         */
        export const VOLUME_IDENTIFIER_KIND_LABEL: string;
        /**
         * The string used to obtain a NFS mount with g_volume_get_identifier().
         */
        export const VOLUME_IDENTIFIER_KIND_NFS_MOUNT: string;
        /**
         * The string used to obtain a Unix device path with g_volume_get_identifier().
         */
        export const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: string;
        /**
         * The string used to obtain a UUID with g_volume_get_identifier().
         */
        export const VOLUME_IDENTIFIER_KIND_UUID: string;
        /**
         * Extension point for volume monitor functionality.
         * See [Extending GIO][extending-gio].
         */
        export const VOLUME_MONITOR_EXTENSION_POINT_NAME: string;
        /**
         * Checks if `action_name `is valid.
         *
         * `action_name `is valid if it consists only of alphanumeric characters,
         * plus '-' and '.'.  The empty string is not a valid action name.
         *
         * It is an error to call this function with a non-utf8 `action_name.`
         * `action_name `must not be %NULL.
         */
        export function action_name_is_valid(action_name: string): boolean;
        /**
         * Parses a detailed action name into its separate name and target
         * components.
         *
         * Detailed action names can have three formats.
         *
         * The first format is used to represent an action name with no target
         * value and consists of just an action name containing no whitespace
         * nor the characters `:`, `(` or `)`.  For example: `app.action`.
         *
         * The second format is used to represent an action with a target value
         * that is a non-empty string consisting only of alphanumerics, plus `-`
         * and `.`.  In that case, the action name and target value are
         * separated by a double colon (`::`).  For example:
         * `app.action::target`.
         *
         * The third format is used to represent an action with any type of
         * target value, including strings.  The target value follows the action
         * name, surrounded in parens.  For example: `app.action(42)`.  The
         * target value is parsed using g_variant_parse().  If a tuple-typed
         * value is desired, it must be specified in the same way, resulting in
         * two sets of parens, for example: `app.action((1,2,3))`.  A string
         * target can be specified this way as well: `app.action('target')`.
         * For strings, this third format must be used if target value is
         * empty or contains characters other than alphanumerics, `-` and `.`.
         *
         * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
         * in `action_name `(if a pointer is passed in). A %NULL value may still be
         * returned in target_value, as the `detailed_name `may not contain a target.
         *
         * If returned, the #GVariant in `target_value `is guaranteed to not be floating.
         */
        export function action_parse_detailed_name(detailed_name: string): [boolean, string, GLib.Variant | null];
        /**
         * Formats a detailed action name from `action_name `and `target_value.`
         *
         * It is an error to call this function with an invalid action name.
         *
         * This function is the opposite of g_action_parse_detailed_name().
         * It will produce a string that can be parsed back to the action_name
         * and `target_value `by that function.
         *
         * See that function for the types of strings that will be printed by
         * this function.
         */
        export function action_print_detailed_name(action_name: string, target_value?: GLib.Variant | null): string;
        /**
         * Creates a new #GAppInfo from the given information.
         *
         * Note that for commandline, the quoting rules of the Exec key of the
         * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
         * are applied. For example, if the `commandline `contains
         * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
         * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
         */
        export function app_info_create_from_commandline(
            commandline: string,
            application_name: string | null,
            flags: AppInfoCreateFlags
        ): AppInfo;
        /**
         * Gets a list of all of the applications currently registered
         * on this system.
         *
         * For desktop files, this includes applications that have
         * `NoDisplay=true` set or are excluded from display by means
         * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
         * The returned list does not include applications which have
         * the `Hidden` key set.
         */
        export function app_info_get_all(): AppInfo[];
        /**
         * Gets a list of all #GAppInfos for a given content type,
         * including the recommended and fallback #GAppInfos. See
         * g_app_info_get_recommended_for_type() and
         * g_app_info_get_fallback_for_type().
         */
        export function app_info_get_all_for_type(content_type: string): AppInfo[];
        /**
         * Gets the default #GAppInfo for a given content type.
         */
        export function app_info_get_default_for_type(content_type: string, must_support_uris: boolean): AppInfo | null;
        /**
         * Asynchronously gets the default #GAppInfo for a given content type.
         */
        export function app_info_get_default_for_type_async(
            content_type: string,
            must_support_uris: boolean,
            cancellable?: Cancellable | null
        ): Promise<AppInfo>;
        /**
         * Asynchronously gets the default #GAppInfo for a given content type.
         */
        export function app_info_get_default_for_type_async(
            content_type: string,
            must_support_uris: boolean,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<string> | null
        ): void;
        /**
         * Asynchronously gets the default #GAppInfo for a given content type.
         */
        export function app_info_get_default_for_type_async(
            content_type: string,
            must_support_uris: boolean,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<string> | null
        ): Promise<AppInfo> | void;
        /**
         * Finishes a default #GAppInfo lookup started by
         * g_app_info_get_default_for_type_async().
         *
         * If no #GAppInfo is found, then `error `will be set to %G_IO_ERROR_NOT_FOUND.
         */
        export function app_info_get_default_for_type_finish(result: AsyncResult): AppInfo;
        /**
         * Gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         */
        export function app_info_get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
        /**
         * Asynchronously gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         */
        export function app_info_get_default_for_uri_scheme_async(
            uri_scheme: string,
            cancellable?: Cancellable | null
        ): Promise<AppInfo>;
        /**
         * Asynchronously gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         */
        export function app_info_get_default_for_uri_scheme_async(
            uri_scheme: string,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<string> | null
        ): void;
        /**
         * Asynchronously gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         */
        export function app_info_get_default_for_uri_scheme_async(
            uri_scheme: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<string> | null
        ): Promise<AppInfo> | void;
        /**
         * Finishes a default #GAppInfo lookup started by
         * g_app_info_get_default_for_uri_scheme_async().
         *
         * If no #GAppInfo is found, then `error `will be set to %G_IO_ERROR_NOT_FOUND.
         */
        export function app_info_get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo;
        /**
         * Gets a list of fallback #GAppInfos for a given content type, i.e.
         * those applications which claim to support the given content type
         * by MIME type subclassing and not directly.
         */
        export function app_info_get_fallback_for_type(content_type: string): AppInfo[];
        /**
         * Gets a list of recommended #GAppInfos for a given content type, i.e.
         * those applications which claim to support the given content type exactly,
         * and not by MIME type subclassing.
         * Note that the first application of the list is the last used one, i.e.
         * the last one for which g_app_info_set_as_last_used_for_type() has been
         * called.
         */
        export function app_info_get_recommended_for_type(content_type: string): AppInfo[];
        /**
         * Utility function that launches the default application
         * registered to handle the specified uri. Synchronous I/O
         * is done on the uri to detect the type of the file if
         * required.
         *
         * The D-Bus–activated applications don't have to be started if your application
         * terminates too soon after this function. To prevent this, use
         * g_app_info_launch_default_for_uri_async() instead.
         */
        export function app_info_launch_default_for_uri(uri: string, context?: AppLaunchContext | null): boolean;
        /**
         * Async version of g_app_info_launch_default_for_uri().
         *
         * This version is useful if you are interested in receiving
         * error information in the case where the application is
         * sandboxed and the portal may present an application chooser
         * dialog to the user.
         *
         * This is also useful if you want to be sure that the D-Bus–activated
         * applications are really started before termination and if you are interested
         * in receiving error information from their activation.
         */
        export function app_info_launch_default_for_uri_async(
            uri: string,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null
        ): Promise<boolean>;
        /**
         * Async version of g_app_info_launch_default_for_uri().
         *
         * This version is useful if you are interested in receiving
         * error information in the case where the application is
         * sandboxed and the portal may present an application chooser
         * dialog to the user.
         *
         * This is also useful if you want to be sure that the D-Bus–activated
         * applications are really started before termination and if you are interested
         * in receiving error information from their activation.
         */
        export function app_info_launch_default_for_uri_async(
            uri: string,
            context: AppLaunchContext | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<string> | null
        ): void;
        /**
         * Async version of g_app_info_launch_default_for_uri().
         *
         * This version is useful if you are interested in receiving
         * error information in the case where the application is
         * sandboxed and the portal may present an application chooser
         * dialog to the user.
         *
         * This is also useful if you want to be sure that the D-Bus–activated
         * applications are really started before termination and if you are interested
         * in receiving error information from their activation.
         */
        export function app_info_launch_default_for_uri_async(
            uri: string,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<string> | null
        ): Promise<boolean> | void;
        /**
         * Finishes an asynchronous launch-default-for-uri operation.
         */
        export function app_info_launch_default_for_uri_finish(result: AsyncResult): boolean;
        /**
         * Removes all changes to the type associations done by
         * g_app_info_set_as_default_for_type(),
         * g_app_info_set_as_default_for_extension(),
         * g_app_info_add_supports_type() or
         * g_app_info_remove_supports_type().
         */
        export function app_info_reset_type_associations(content_type: string): void;
        /**
         * Helper function for constructing #GAsyncInitable object. This is
         * similar to g_object_newv() but also initializes the object asynchronously.
         *
         * When the initialization is finished, `callback `will be called. You can
         * then call g_async_initable_new_finish() to get the new object and check
         * for any errors.
         */
        export function async_initable_newv_async(
            object_type: GObject.GType,
            n_parameters: number,
            parameters: GObject.Parameter,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<GObject.GType> | null
        ): void;
        /**
         * Asynchronously connects to the message bus specified by `bus_type.`
         *
         * When the operation is finished, `callback `will be invoked. You can
         * then call g_bus_get_finish() to get the result of the operation.
         *
         * This is an asynchronous failable function. See g_bus_get_sync() for
         * the synchronous version.
         */
        export function bus_get(bus_type: BusType, cancellable?: Cancellable | null): Promise<DBusConnection>;
        /**
         * Asynchronously connects to the message bus specified by `bus_type.`
         *
         * When the operation is finished, `callback `will be invoked. You can
         * then call g_bus_get_finish() to get the result of the operation.
         *
         * This is an asynchronous failable function. See g_bus_get_sync() for
         * the synchronous version.
         */
        export function bus_get(
            bus_type: BusType,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<BusType> | null
        ): void;
        /**
         * Asynchronously connects to the message bus specified by `bus_type.`
         *
         * When the operation is finished, `callback `will be invoked. You can
         * then call g_bus_get_finish() to get the result of the operation.
         *
         * This is an asynchronous failable function. See g_bus_get_sync() for
         * the synchronous version.
         */
        export function bus_get(
            bus_type: BusType,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<BusType> | null
        ): Promise<DBusConnection> | void;
        /**
         * Finishes an operation started with g_bus_get().
         *
         * The returned object is a singleton, that is, shared with other
         * callers of g_bus_get() and g_bus_get_sync() for `bus_type.` In the
         * event that you need a private message bus connection, use
         * g_dbus_address_get_for_bus_sync() and
         * g_dbus_connection_new_for_address() with
         * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
         * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
         *
         * Note that the returned #GDBusConnection object will (usually) have
         * the #GDBusConnection:exit-on-close property set to %TRUE.
         */
        export function bus_get_finish(res: AsyncResult): DBusConnection;
        /**
         * Synchronously connects to the message bus specified by `bus_type.`
         * Note that the returned object may shared with other callers,
         * e.g. if two separate parts of a process calls this function with
         * the same bus_type, they will share the same object.
         *
         * This is a synchronous failable function. See g_bus_get() and
         * g_bus_get_finish() for the asynchronous version.
         *
         * The returned object is a singleton, that is, shared with other
         * callers of g_bus_get() and g_bus_get_sync() for `bus_type.` In the
         * event that you need a private message bus connection, use
         * g_dbus_address_get_for_bus_sync() and
         * g_dbus_connection_new_for_address() with
         * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
         * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
         *
         * Note that the returned #GDBusConnection object will (usually) have
         * the #GDBusConnection:exit-on-close property set to %TRUE.
         */
        export function bus_get_sync(bus_type: BusType, cancellable?: Cancellable | null): DBusConnection;
        /**
         * Version of g_bus_own_name_on_connection() using closures instead of
         * callbacks for easier binding in other languages.
         */
        export function bus_own_name_on_connection(
            connection: DBusConnection,
            name: string,
            flags: BusNameOwnerFlags,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null
        ): number;
        /**
         * Version of g_bus_own_name() using closures instead of callbacks for
         * easier binding in other languages.
         */
        export function bus_own_name(
            bus_type: BusType,
            name: string,
            flags: BusNameOwnerFlags,
            bus_acquired_closure?: GObject.Closure | null,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null
        ): number;
        /**
         * Stops owning a name.
         *
         * Note that there may still be D-Bus traffic to process (relating to owning
         * and unowning the name) in the current thread-default #GMainContext after
         * this function has returned. You should continue to iterate the #GMainContext
         * until the #GDestroyNotify function passed to g_bus_own_name() is called, in
         * order to avoid memory leaks through callbacks queued on the #GMainContext
         * after it’s stopped being iterated.
         */
        export function bus_unown_name(owner_id: number): void;
        /**
         * Stops watching a name.
         *
         * Note that there may still be D-Bus traffic to process (relating to watching
         * and unwatching the name) in the current thread-default #GMainContext after
         * this function has returned. You should continue to iterate the #GMainContext
         * until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
         * order to avoid memory leaks through callbacks queued on the #GMainContext
         * after it’s stopped being iterated.
         */
        export function bus_unwatch_name(watcher_id: number): void;
        /**
         * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
         * easier binding in other languages.
         */
        export function bus_watch_name_on_connection(
            connection: DBusConnection,
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null
        ): number;
        /**
         * Version of g_bus_watch_name() using closures instead of callbacks for
         * easier binding in other languages.
         */
        export function bus_watch_name(
            bus_type: BusType,
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null
        ): number;
        /**
         * Checks if a content type can be executable. Note that for instance
         * things like text files can be executables (i.e. scripts and batch files).
         */
        export function content_type_can_be_executable(type: string): boolean;
        /**
         * Compares two content types for equality.
         */
        export function content_type_equals(type1: string, type2: string): boolean;
        /**
         * Tries to find a content type based on the mime type name.
         */
        export function content_type_from_mime_type(mime_type: string): string | null;
        /**
         * Gets the human readable description of the content type.
         */
        export function content_type_get_description(type: string): string;
        /**
         * Gets the generic icon name for a content type.
         *
         * See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on the generic icon name.
         */
        export function content_type_get_generic_icon_name(type: string): string | null;
        /**
         * Gets the icon for a content type.
         */
        export function content_type_get_icon(type: string): Icon;
        /**
         * Get the list of directories which MIME data is loaded from. See
         * g_content_type_set_mime_dirs() for details.
         */
        export function content_type_get_mime_dirs(): string[];
        /**
         * Gets the mime type for the content type, if one is registered.
         */
        export function content_type_get_mime_type(type: string): string | null;
        /**
         * Gets the symbolic icon for a content type.
         */
        export function content_type_get_symbolic_icon(type: string): Icon;
        /**
         * Guesses the content type based on example data. If the function is
         * uncertain, `result_uncertain `will be set to %TRUE. Either filename
         * or `data `may be %NULL, in which case the guess will be based solely
         * on the other argument.
         */
        export function content_type_guess(filename: string | null, data: Uint8Array | null): [string, boolean];
        /**
         * Tries to guess the type of the tree with root root, by
         * looking at the files it contains. The result is an array
         * of content types, with the best guess coming first.
         *
         * The types returned all have the form x-content/foo, e.g.
         * x-content/audio-cdda (for audio CDs) or x-content/image-dcf
         * (for a camera memory card). See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This function is useful in the implementation of
         * g_mount_guess_content_type().
         */
        export function content_type_guess_for_tree(root: File): string[];
        /**
         * Determines if `type `is a subset of `supertype.`
         */
        export function content_type_is_a(type: string, supertype: string): boolean;
        /**
         * Determines if `type `is a subset of `mime_type.`
         * Convenience wrapper around g_content_type_is_a().
         */
        export function content_type_is_mime_type(type: string, mime_type: string): boolean;
        /**
         * Checks if the content type is the generic "unknown" type.
         * On UNIX this is the "application/octet-stream" mimetype,
         * while on win32 it is "*" and on OSX it is a dynamic type
         * or octet-stream.
         */
        export function content_type_is_unknown(type: string): boolean;
        /**
         * Set the list of directories used by GIO to load the MIME database.
         * If `dirs `is %NULL, the directories used are the default:
         *
         * - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
         * - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
         *
         * This function is intended to be used when writing tests that depend on
         * information stored in the MIME database, in order to control the data.
         *
         * Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
         * depend on the system’s MIME database, you should call this function
         * with `dirs `set to %NULL before calling g_test_init(), for instance:
         *
         * |[&lt;!-- language="C" --&gt;
         * // Load MIME data from the system
         * g_content_type_set_mime_dirs (NULL);
         * // Isolate the environment
         * g_test_init (&amp;argc, &amp;argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
         *
         * …
         *
         * return g_test_run ();
         * ]|
         */
        export function content_type_set_mime_dirs(dirs?: string[] | null): void;
        /**
         * Gets a list of strings containing all the registered content types
         * known to the system. The list and its data should be freed using
         * `g_list_free_full (list, g_free)`.
         */
        export function content_types_get_registered(): string[];
        /**
         * Escape `string `so it can appear in a D-Bus address as the value
         * part of a key-value pair.
         *
         * For instance, if `string `is `/run/bus-for-:0`,
         * this function would return `/run/bus-for-%3A0`,
         * which could be used in a D-Bus address like
         * `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
         */
        export function dbus_address_escape_value(string: string): string;
        /**
         * Synchronously looks up the D-Bus address for the well-known message
         * bus instance specified by `bus_type.` This may involve using various
         * platform specific mechanisms.
         *
         * The returned address will be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         */
        export function dbus_address_get_for_bus_sync(bus_type: BusType, cancellable?: Cancellable | null): string;
        /**
         * Asynchronously connects to an endpoint specified by `address `and
         * sets up the connection so it is in a state to run the client-side
         * of the D-Bus authentication conversation. `address `must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * When the operation is finished, `callback `will be invoked. You can
         * then call g_dbus_address_get_stream_finish() to get the result of
         * the operation.
         *
         * This is an asynchronous failable function. See
         * g_dbus_address_get_stream_sync() for the synchronous version.
         */
        export function dbus_address_get_stream(
            address: string,
            cancellable?: Cancellable | null
        ): Promise<[IOStream, string]>;
        /**
         * Asynchronously connects to an endpoint specified by `address `and
         * sets up the connection so it is in a state to run the client-side
         * of the D-Bus authentication conversation. `address `must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * When the operation is finished, `callback `will be invoked. You can
         * then call g_dbus_address_get_stream_finish() to get the result of
         * the operation.
         *
         * This is an asynchronous failable function. See
         * g_dbus_address_get_stream_sync() for the synchronous version.
         */
        export function dbus_address_get_stream(
            address: string,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<string> | null
        ): void;
        /**
         * Asynchronously connects to an endpoint specified by `address `and
         * sets up the connection so it is in a state to run the client-side
         * of the D-Bus authentication conversation. `address `must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * When the operation is finished, `callback `will be invoked. You can
         * then call g_dbus_address_get_stream_finish() to get the result of
         * the operation.
         *
         * This is an asynchronous failable function. See
         * g_dbus_address_get_stream_sync() for the synchronous version.
         */
        export function dbus_address_get_stream(
            address: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<string> | null
        ): Promise<[IOStream, string]> | void;
        /**
         * Finishes an operation started with g_dbus_address_get_stream().
         *
         * A server is not required to set a GUID, so `out_guid `may be set to %NULL
         * even on success.
         */
        export function dbus_address_get_stream_finish(res: AsyncResult): [IOStream, string];
        /**
         * Synchronously connects to an endpoint specified by `address `and
         * sets up the connection so it is in a state to run the client-side
         * of the D-Bus authentication conversation. `address `must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * A server is not required to set a GUID, so `out_guid `may be set to %NULL
         * even on success.
         *
         * This is a synchronous failable function. See
         * g_dbus_address_get_stream() for the asynchronous version.
         */
        export function dbus_address_get_stream_sync(
            address: string,
            cancellable?: Cancellable | null
        ): [IOStream, string];
        /**
         * Looks up the value of an annotation.
         *
         * The cost of this function is O(n) in number of annotations.
         */
        export function dbus_annotation_info_lookup(
            annotations: DBusAnnotationInfo[] | null,
            name: string
        ): string | null;
        /**
         * Creates a D-Bus error name to use for `error.` If `error `matches
         * a registered error (cf. g_dbus_error_register_error()), the corresponding
         * D-Bus error name will be returned.
         *
         * Otherwise the a name of the form
         * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
         * will be used. This allows other GDBus applications to map the error
         * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
         *
         * This function is typically only used in object mappings to put a
         * #GError on the wire. Regular applications should not use it.
         */
        export function dbus_error_encode_gerror(error: GLib.Error): string;
        /**
         * Gets the D-Bus error name used for error, if any.
         *
         * This function is guaranteed to return a D-Bus error name for all
         * #GErrors returned from functions handling remote method calls
         * (e.g. g_dbus_connection_call_finish()) unless
         * g_dbus_error_strip_remote_error() has been used on `error.`
         */
        export function dbus_error_get_remote_error(error: GLib.Error): string | null;
        /**
         * Checks if `error `represents an error received via D-Bus from a remote peer. If so,
         * use g_dbus_error_get_remote_error() to get the name of the error.
         */
        export function dbus_error_is_remote_error(error: GLib.Error): boolean;
        /**
         * Creates a #GError based on the contents of `dbus_error_name `and
         * `dbus_error_message.`
         *
         * Errors registered with g_dbus_error_register_error() will be looked
         * up using `dbus_error_name `and if a match is found, the error domain
         * and code is used. Applications can use g_dbus_error_get_remote_error()
         * to recover `dbus_error_name.`
         *
         * If a match against a registered error is not found and the D-Bus
         * error name is in a form as returned by g_dbus_error_encode_gerror()
         * the error domain and code encoded in the name is used to
         * create the #GError. Also, `dbus_error_name `is added to the error message
         * such that it can be recovered with g_dbus_error_get_remote_error().
         *
         * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
         * in the %G_IO_ERROR error domain is returned. Also, `dbus_error_name `is
         * added to the error message such that it can be recovered with
         * g_dbus_error_get_remote_error().
         *
         * In all three cases, `dbus_error_name `can always be recovered from the
         * returned #GError using the g_dbus_error_get_remote_error() function
         * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
         *
         * This function is typically only used in object mappings to prepare
         * #GError instances for applications. Regular applications should not use
         * it.
         */
        export function dbus_error_new_for_dbus_error(dbus_error_name: string, dbus_error_message: string): GLib.Error;
        export function dbus_error_quark(): GLib.Quark;
        /**
         * Creates an association to map between `dbus_error_name `and
         * #GErrors specified by `error_domain `and `error_code.`
         *
         * This is typically done in the routine that returns the #GQuark for
         * an error domain.
         */
        export function dbus_error_register_error(
            error_domain: GLib.Quark,
            error_code: number,
            dbus_error_name: string
        ): boolean;
        /**
         * Helper function for associating a #GError error domain with D-Bus error names.
         *
         * While `quark_volatile `has a `volatile` qualifier, this is a historical
         * artifact and the argument passed to it should not be `volatile`.
         */
        export function dbus_error_register_error_domain(
            error_domain_quark_name: string,
            quark_volatile: number,
            entries: DBusErrorEntry[]
        ): void;
        /**
         * Looks for extra information in the error message used to recover
         * the D-Bus error name and strips it if found. If stripped, the
         * message field in `error `will correspond exactly to what was
         * received on the wire.
         *
         * This is typically used when presenting errors to the end user.
         */
        export function dbus_error_strip_remote_error(error: GLib.Error): boolean;
        /**
         * Destroys an association previously set up with g_dbus_error_register_error().
         */
        export function dbus_error_unregister_error(
            error_domain: GLib.Quark,
            error_code: number,
            dbus_error_name: string
        ): boolean;
        /**
         * This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
         */
        export function dbus_escape_object_path(s: string): string;
        /**
         * Escapes `bytes `for use in a D-Bus object path component.
         * `bytes `is an array of zero or more nonzero bytes in an
         * unspecified encoding, followed by a single zero byte.
         *
         * The escaping method consists of replacing all non-alphanumeric
         * characters (see g_ascii_isalnum()) with their hexadecimal value
         * preceded by an underscore (`_`). For example:
         * `foo.bar.baz` will become `foo_2ebar_2ebaz`.
         *
         * This method is appropriate to use when the input is nearly
         * a valid object path component but is not when your input
         * is far from being a valid object path component.
         * Other escaping algorithms are also valid to use with
         * D-Bus object paths.
         *
         * This can be reversed with g_dbus_unescape_object_path().
         */
        export function dbus_escape_object_path_bytestring(bytes: Uint8Array | string): string;
        /**
         * Generate a D-Bus GUID that can be used with
         * e.g. g_dbus_connection_new().
         *
         * See the
         * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
         * regarding what strings are valid D-Bus GUIDs. The specification refers to
         * these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
         * ‘GUIDs’. The terms are interchangeable.
         *
         * Note that D-Bus GUIDs do not follow
         * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
         */
        export function dbus_generate_guid(): string;
        /**
         * Converts a #GValue to a #GVariant of the type indicated by the type
         * parameter.
         *
         * The conversion is using the following rules:
         *
         * - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
         * - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
         * - `G_TYPE_BOOLEAN`: 'b'
         * - `G_TYPE_UCHAR`: 'y'
         * - `G_TYPE_INT`: 'i', 'n'
         * - `G_TYPE_UINT`: 'u', 'q'
         * - `G_TYPE_INT64`: 'x'
         * - `G_TYPE_UINT64`: 't'
         * - `G_TYPE_DOUBLE`: 'd'
         * - `G_TYPE_VARIANT`: Any #GVariantType
         *
         * This can fail if e.g. `gvalue `is of type %G_TYPE_STRING and type
         * is 'i', i.e. %G_VARIANT_TYPE_INT32. It will also fail for any #GType
         * (including e.g. %G_TYPE_OBJECT and %G_TYPE_BOXED derived-types) not
         * in the table above.
         *
         * Note that if `gvalue `is of type %G_TYPE_VARIANT and its value is
         * %NULL, the empty #GVariant instance (never %NULL) for `type `is
         * returned (e.g. 0 for scalar types, the empty string for string types,
         * '/' for object path types, the empty array for any array type and so on).
         *
         * See the g_dbus_gvariant_to_gvalue() function for how to convert a
         * #GVariant to a #GValue.
         */
        export function dbus_gvalue_to_gvariant(gvalue: GObject.Value | any, type: GLib.VariantType): GLib.Variant;
        /**
         * Converts a #GVariant to a #GValue. If `value `is floating, it is consumed.
         *
         * The rules specified in the g_dbus_gvalue_to_gvariant() function are
         * used - this function is essentially its reverse form. So, a #GVariant
         * containing any basic or string array type will be converted to a #GValue
         * containing a basic value or string array. Any other #GVariant (handle,
         * variant, tuple, dict entry) will be converted to a #GValue containing that
         * #GVariant.
         *
         * The conversion never fails - a valid #GValue is always returned in
         * `out_gvalue.`
         */
        export function dbus_gvariant_to_gvalue(value: GLib.Variant): unknown;
        /**
         * Checks if `string `is a
         * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * This doesn't check if `string `is actually supported by #GDBusServer
         * or #GDBusConnection - use g_dbus_is_supported_address() to do more
         * checks.
         */
        export function dbus_is_address(string: string): boolean;
        /**
         * Check whether `string `is a valid D-Bus error name.
         *
         * This function returns the same result as g_dbus_is_interface_name(),
         * because D-Bus error names are defined to have exactly the
         * same syntax as interface names.
         */
        export function dbus_is_error_name(string: string): boolean;
        /**
         * Checks if `string `is a D-Bus GUID.
         *
         * See the documentation for g_dbus_generate_guid() for more information about
         * the format of a GUID.
         */
        export function dbus_is_guid(string: string): boolean;
        /**
         * Checks if `string `is a valid D-Bus interface name.
         */
        export function dbus_is_interface_name(string: string): boolean;
        /**
         * Checks if `string `is a valid D-Bus member (e.g. signal or method) name.
         */
        export function dbus_is_member_name(string: string): boolean;
        /**
         * Checks if `string `is a valid D-Bus bus name (either unique or well-known).
         */
        export function dbus_is_name(string: string): boolean;
        /**
         * Like g_dbus_is_address() but also checks if the library supports the
         * transports in `string `and that key/value pairs for each transport
         * are valid. See the specification of the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         */
        export function dbus_is_supported_address(string: string): boolean;
        /**
         * Checks if `string `is a valid D-Bus unique bus name.
         */
        export function dbus_is_unique_name(string: string): boolean;
        /**
         * Unescapes an string that was previously escaped with
         * g_dbus_escape_object_path(). If the string is in a format that could
         * not have been returned by g_dbus_escape_object_path(), this function
         * returns %NULL.
         *
         * Encoding alphanumeric characters which do not need to be
         * encoded is not allowed (e.g `_63` is not valid, the string
         * should contain `c` instead).
         */
        export function dbus_unescape_object_path(s: string): Uint8Array | null;
        /**
         * Creates a new #GDtlsClientConnection wrapping `base_socket `which is
         * assumed to communicate with the server identified by `server_identity.`
         */
        export function dtls_client_connection_new(
            base_socket: DatagramBased,
            server_identity?: SocketConnectable | null
        ): DtlsClientConnection;
        /**
         * Creates a new #GDtlsServerConnection wrapping `base_socket.`
         */
        export function dtls_server_connection_new(
            base_socket: DatagramBased,
            certificate?: TlsCertificate | null
        ): DtlsServerConnection;
        /**
         * Creates a #GFile with the given argument from the command line.
         * The value of `arg `can be either a URI, an absolute path or a
         * relative path resolved relative to the current working directory.
         * This operation never fails, but the returned object might not
         * support any I/O operation if `arg `points to a malformed path.
         *
         * Note that on Windows, this function expects its argument to be in
         * UTF-8 -- not the system code page.  This means that you
         * should not use this function with string from argv as it is passed
         * to main().  g_win32_get_command_line() will return a UTF-8 version of
         * the commandline.  #GApplication also uses UTF-8 but
         * g_application_command_line_create_file_for_arg() may be more useful
         * for you there.  It is also always possible to use this function with
         * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
         */
        export function file_new_for_commandline_arg(arg: string): File;
        /**
         * Creates a #GFile with the given argument from the command line.
         *
         * This function is similar to g_file_new_for_commandline_arg() except
         * that it allows for passing the current working directory as an
         * argument instead of using the current working directory of the
         * process.
         *
         * This is useful if the commandline argument was given in a context
         * other than the invocation of the current process.
         *
         * See also g_application_command_line_create_file_for_arg().
         */
        export function file_new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
        /**
         * Constructs a #GFile for a given path. This operation never
         * fails, but the returned object might not support any I/O
         * operation if `path `is malformed.
         */
        export function file_new_for_path(path: string): File;
        /**
         * Constructs a #GFile for a given URI. This operation never
         * fails, but the returned object might not support any I/O
         * operation if `uri `is malformed or if the uri type is
         * not supported.
         */
        export function file_new_for_uri(uri: string): File;
        /**
         * Opens a file in the preferred directory for temporary files (as
         * returned by g_get_tmp_dir()) and returns a #GFile and
         * #GFileIOStream pointing to it.
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         *
         * Unlike the other #GFile constructors, this will return %NULL if
         * a temporary file could not be created.
         */
        export function file_new_tmp(tmpl: string | null): [File, FileIOStream];
        /**
         * Asynchronously opens a file in the preferred directory for temporary files
         * (as returned by g_get_tmp_dir()) as g_file_new_tmp().
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         */
        export function file_new_tmp_async(
            tmpl: string | null,
            io_priority: number,
            cancellable?: Cancellable | null
        ): Promise<[File, FileIOStream]>;
        /**
         * Asynchronously opens a file in the preferred directory for temporary files
         * (as returned by g_get_tmp_dir()) as g_file_new_tmp().
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         */
        export function file_new_tmp_async(
            tmpl: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<string | null> | null
        ): void;
        /**
         * Asynchronously opens a file in the preferred directory for temporary files
         * (as returned by g_get_tmp_dir()) as g_file_new_tmp().
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         */
        export function file_new_tmp_async(
            tmpl: string | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<string | null> | null
        ): Promise<[File, FileIOStream]> | void;
        /**
         * Asynchronously creates a directory in the preferred directory for
         * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         */
        export function file_new_tmp_dir_async(
            tmpl: string | null,
            io_priority: number,
            cancellable?: Cancellable | null
        ): Promise<File>;
        /**
         * Asynchronously creates a directory in the preferred directory for
         * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         */
        export function file_new_tmp_dir_async(
            tmpl: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<string | null> | null
        ): void;
        /**
         * Asynchronously creates a directory in the preferred directory for
         * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
         *
         * `tmpl `should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         */
        export function file_new_tmp_dir_async(
            tmpl: string | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<string | null> | null
        ): Promise<File> | void;
        /**
         * Finishes a temporary directory creation started by
         * g_file_new_tmp_dir_async().
         */
        export function file_new_tmp_dir_finish(result: AsyncResult): File;
        /**
         * Finishes a temporary file creation started by g_file_new_tmp_async().
         */
        export function file_new_tmp_finish(result: AsyncResult): [File, FileIOStream];
        /**
         * Constructs a #GFile with the given `parse_name `(i.e. something
         * given by g_file_get_parse_name()). This operation never fails,
         * but the returned object might not support any I/O operation if
         * the `parse_name `cannot be parsed.
         */
        export function file_parse_name(parse_name: string): File;
        /**
         * Deserializes a #GIcon previously serialized using g_icon_serialize().
         */
        export function icon_deserialize(value: GLib.Variant): Icon | null;
        /**
         * Generate a #GIcon instance from `str.` This function can fail if
         * `str `is not valid - see g_icon_to_string() for discussion.
         *
         * If your application or library provides one or more #GIcon
         * implementations you need to ensure that each #GType is registered
         * with the type system prior to calling g_icon_new_for_string().
         */
        export function icon_new_for_string(str: string): Icon;
        /**
         * Helper function for constructing #GInitable object. This is
         * similar to g_object_newv() but also initializes the object
         * and returns %NULL, setting an error on failure.
         */
        export function initable_newv<T = GObject.Object>(
            object_type: GObject.GType,
            parameters: GObject.Parameter[],
            cancellable?: Cancellable | null
        ): T;
        /**
         * Converts errno.h error codes into GIO error codes. The fallback
         * value %G_IO_ERROR_FAILED is returned for error codes not currently
         * handled (but note that future GLib releases may return a more
         * specific value instead).
         *
         * As %errno is global and may be modified by intermediate function
         * calls, you should save its value as soon as the call which sets it
         */
        export function io_error_from_errno(err_no: number): IOErrorEnum;
        /**
         * Converts #GFileError error codes into GIO error codes.
         */
        export function io_error_from_file_error(file_error: GLib.FileError): IOErrorEnum;
        /**
         * Gets the GIO Error Quark.
         */
        export function io_error_quark(): GLib.Quark;
        /**
         * Registers `type `as extension for the extension point with name
         * `extension_point_name.`
         *
         * If `type `has already been registered as an extension for this
         * extension point, the existing #GIOExtension object is returned.
         */
        export function io_extension_point_implement(
            extension_point_name: string,
            type: GObject.GType,
            extension_name: string,
            priority: number
        ): IOExtension;
        /**
         * Looks up an existing extension point.
         */
        export function io_extension_point_lookup(name: string): IOExtensionPoint;
        /**
         * Registers an extension point.
         */
        export function io_extension_point_register(name: string): IOExtensionPoint;
        /**
         * Loads all the modules in the specified directory.
         *
         * If don't require all modules to be initialized (and thus registering
         * all gtypes) then you can use g_io_modules_scan_all_in_directory()
         * which allows delayed/lazy loading of modules.
         */
        export function io_modules_load_all_in_directory(dirname: string): IOModule[];
        /**
         * Loads all the modules in the specified directory.
         *
         * If don't require all modules to be initialized (and thus registering
         * all gtypes) then you can use g_io_modules_scan_all_in_directory()
         * which allows delayed/lazy loading of modules.
         */
        export function io_modules_load_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): IOModule[];
        /**
         * Scans all the modules in the specified directory, ensuring that
         * any extension point implemented by a module is registered.
         *
         * This may not actually load and initialize all the types in each
         * module, some modules may be lazily loaded and initialized when
         * an extension point it implements is used with e.g.
         * g_io_extension_point_get_extensions() or
         * g_io_extension_point_get_extension_by_name().
         *
         * If you need to guarantee that all types are loaded in all the modules,
         * use g_io_modules_load_all_in_directory().
         */
        export function io_modules_scan_all_in_directory(dirname: string): void;
        /**
         * Scans all the modules in the specified directory, ensuring that
         * any extension point implemented by a module is registered.
         *
         * This may not actually load and initialize all the types in each
         * module, some modules may be lazily loaded and initialized when
         * an extension point it implements is used with e.g.
         * g_io_extension_point_get_extensions() or
         * g_io_extension_point_get_extension_by_name().
         *
         * If you need to guarantee that all types are loaded in all the modules,
         * use g_io_modules_load_all_in_directory().
         */
        export function io_modules_scan_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): void;
        /**
         * Cancels all cancellable I/O jobs.
         *
         * A job is cancellable if a #GCancellable was passed into
         * g_io_scheduler_push_job().
         */
        export function io_scheduler_cancel_all_jobs(): void;
        /**
         * Schedules the I/O job to run in another thread.
         *
         * `notify `will be called on `user_data `after `job_func `has returned,
         * regardless whether the job was cancelled or has run to completion.
         *
         * If `cancellable `is not %NULL, it can be used to cancel the I/O job
         * by calling g_cancellable_cancel() or by calling
         * g_io_scheduler_cancel_all_jobs().
         */
        export function io_scheduler_push_job(
            job_func: IOSchedulerJobFunc,
            notify: GLib.DestroyNotify | null,
            io_priority: number,
            cancellable?: Cancellable | null
        ): void;
        /**
         * Creates a keyfile-backed #GSettingsBackend.
         *
         * The filename of the keyfile to use is given by `filename.`
         *
         * All settings read to or written from the backend must fall under the
         * path given in `root_path `(which must start and end with a slash and
         * not contain two consecutive slashes).  `root_path `may be "/".
         *
         * If `root_group `is non-%NULL then it specifies the name of the keyfile
         * group used for keys that are written directly below `root_path.`  For
         * example, if `root_path `is "/apps/example/" and `root_group `is
         * "toplevel", then settings the key "/apps/example/enabled" to a value
         * of %TRUE will cause the following to appear in the keyfile:
         *
         * |[
         * [toplevel]
         * enabled=true
         * ]|
         *
         * If `root_group `is %NULL then it is not permitted to store keys
         * directly below the `root_path.`
         *
         * For keys not stored directly below `root_path `(ie: in a sub-path),
         * the name of the subpath (with the final slash stripped) is used as
         * the name of the keyfile group.  To continue the example, if
         * "/apps/example/profiles/default/font-size" were set to
         * 12 then the following would appear in the keyfile:
         *
         * |[
         * [profiles/default]
         * font-size=12
         * ]|
         *
         * The backend will refuse writes (and return writability as being
         * %FALSE) for keys outside of `root_path `and, in the event that
         * `root_group `is %NULL, also for keys directly under `root_path.`
         * Writes will also be refused if the backend detects that it has the
         * inability to rewrite the keyfile (ie: the containing directory is not
         * writable).
         *
         * There is no checking done for your key namespace clashing with the
         * syntax of the key file format.  For example, if you have '[' or ']'
         * characters in your path names or '=' in your key names you may be in
         * trouble.
         *
         * The backend reads default values from a keyfile called `defaults` in
         * the directory specified by the #GKeyfileSettingsBackend:defaults-dir property,
         * and a list of locked keys from a text file with the name `locks` in
         * the same location.
         */
        export function keyfile_settings_backend_new(
            filename: string,
            root_path: string,
            root_group?: string | null
        ): SettingsBackend;
        /**
         * Gets a reference to the default #GMemoryMonitor for the system.
         */
        export function memory_monitor_dup_default(): MemoryMonitor;
        /**
         * Creates a memory-backed #GSettingsBackend.
         *
         * This backend allows changes to settings, but does not write them
         * to any backing storage, so the next time you run your application,
         * the memory backend will start out with the default values again.
         */
        export function memory_settings_backend_new(): SettingsBackend;
        /**
         * Gets the default #GNetworkMonitor for the system.
         */
        export function network_monitor_get_default(): NetworkMonitor;
        /**
         * Initializes the platform networking libraries (eg, on Windows, this
         * calls WSAStartup()). GLib will call this itself if it is needed, so
         * you only need to call it if you directly call system networking
         * functions (without calling any GLib networking functions first).
         */
        export function networking_init(): void;
        /**
         * Creates a readonly #GSettingsBackend.
         *
         * This backend does not allow changes to settings, so all settings
         * will always have their default values.
         */
        export function null_settings_backend_new(): SettingsBackend;
        /**
         * Utility method for #GPollableInputStream and #GPollableOutputStream
         * implementations. Creates a new #GSource that expects a callback of
         * type #GPollableSourceFunc. The new source does not actually do
         * anything on its own; use g_source_add_child_source() to add other
         * sources to it to cause it to trigger.
         */
        export function pollable_source_new(pollable_stream: GObject.Object): GLib.Source;
        /**
         * Utility method for #GPollableInputStream and #GPollableOutputStream
         * implementations. Creates a new #GSource, as with
         * g_pollable_source_new(), but also attaching `child_source `(with a
         * dummy callback), and cancellable, if they are non-%NULL.
         */
        export function pollable_source_new_full(
            pollable_stream: GObject.Object,
            child_source?: GLib.Source | null,
            cancellable?: Cancellable | null
        ): GLib.Source;
        /**
         * Tries to read from stream, as with g_input_stream_read() (if
         * `blocking `is %TRUE) or g_pollable_input_stream_read_nonblocking()
         * (if `blocking `is %FALSE). This can be used to more easily share
         * code between blocking and non-blocking implementations of a method.
         *
         * If `blocking `is %FALSE, then `stream `must be a
         * #GPollableInputStream for which g_pollable_input_stream_can_poll()
         * returns %TRUE, or else the behavior is undefined. If `blocking `is
         * %TRUE, then `stream `does not need to be a #GPollableInputStream.
         */
        export function pollable_stream_read(
            stream: InputStream,
            buffer: Uint8Array | string,
            blocking: boolean,
            cancellable?: Cancellable | null
        ): number;
        /**
         * Tries to write to stream, as with g_output_stream_write() (if
         * `blocking `is %TRUE) or g_pollable_output_stream_write_nonblocking()
         * (if `blocking `is %FALSE). This can be used to more easily share
         * code between blocking and non-blocking implementations of a method.
         *
         * If `blocking `is %FALSE, then `stream `must be a
         * #GPollableOutputStream for which
         * g_pollable_output_stream_can_poll() returns %TRUE or else the
         * behavior is undefined. If `blocking `is %TRUE, then `stream `does not
         * need to be a #GPollableOutputStream.
         */
        export function pollable_stream_write(
            stream: OutputStream,
            buffer: Uint8Array | string,
            blocking: boolean,
            cancellable?: Cancellable | null
        ): number;
        /**
         * Tries to write `count `bytes to stream, as with
         * g_output_stream_write_all(), but using g_pollable_stream_write()
         * rather than g_output_stream_write().
         *
         * On a successful write of `count `bytes, %TRUE is returned, and
         * `bytes_written `is set to `count.`
         *
         * If there is an error during the operation (including
         * %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
         * returned and `error `is set to indicate the error status,
         * `bytes_written `is updated to contain the number of bytes written
         * into the stream before the error occurred.
         *
         * As with g_pollable_stream_write(), if `blocking `is %FALSE, then
         * `stream `must be a #GPollableOutputStream for which
         * g_pollable_output_stream_can_poll() returns %TRUE or else the
         * behavior is undefined. If `blocking `is %TRUE, then `stream `does not
         * need to be a #GPollableOutputStream.
         */
        export function pollable_stream_write_all(
            stream: OutputStream,
            buffer: Uint8Array | string,
            blocking: boolean,
            cancellable?: Cancellable | null
        ): [boolean, number];
        /**
         * Gets a reference to the default #GPowerProfileMonitor for the system.
         */
        export function power_profile_monitor_dup_default(): PowerProfileMonitor;
        /**
         * Find the `gio-proxy` extension point for a proxy implementation that supports
         * the specified protocol.
         */
        export function proxy_get_default_for_protocol(protocol: string): Proxy | null;
        /**
         * Gets the default #GProxyResolver for the system.
         */
        export function proxy_resolver_get_default(): ProxyResolver;
        /**
         * Gets the #GResolver Error Quark.
         */
        export function resolver_error_quark(): GLib.Quark;
        /**
         * Gets the #GResource Error Quark.
         */
        export function resource_error_quark(): GLib.Quark;
        /**
         * Loads a binary resource bundle and creates a #GResource representation of it, allowing
         * you to query it for data.
         *
         * If you want to use this resource in the global resource namespace you need
         * to register it with g_resources_register().
         *
         * If `filename `is empty or the data in it is corrupt,
         * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename `doesn’t exist, or
         * there is an error in reading it, an error from g_mapped_file_new() will be
         * returned.
         */
        export function resource_load(filename: string): Resource;
        /**
         * Returns all the names of children at the specified `path `in the set of
         * globally registered resources.
         * The return result is a %NULL terminated list of strings which should
         * be released with g_strfreev().
         *
         * `lookup_flags `controls the behaviour of the lookup.
         */
        export function resources_enumerate_children(path: string, lookup_flags: ResourceLookupFlags): string[];
        /**
         * Looks for a file at the specified `path `in the set of
         * globally registered resources and if found returns information about it.
         *
         * `lookup_flags `controls the behaviour of the lookup.
         */
        export function resources_get_info(path: string, lookup_flags: ResourceLookupFlags): [boolean, number, number];
        /**
         * Looks for a file at the specified `path `in the set of
         * globally registered resources and returns a #GBytes that
         * lets you directly access the data in memory.
         *
         * The data is always followed by a zero byte, so you
         * can safely use the data as a C string. However, that byte
         * is not included in the size of the GBytes.
         *
         * For uncompressed resource files this is a pointer directly into
         * the resource bundle, which is typically in some readonly data section
         * in the program binary. For compressed files we allocate memory on
         * the heap and automatically uncompress the data.
         *
         * `lookup_flags `controls the behaviour of the lookup.
         */
        export function resources_lookup_data(path: string, lookup_flags: ResourceLookupFlags): GLib.Bytes;
        /**
         * Looks for a file at the specified `path `in the set of
         * globally registered resources and returns a #GInputStream
         * that lets you read the data.
         *
         * `lookup_flags `controls the behaviour of the lookup.
         */
        export function resources_open_stream(path: string, lookup_flags: ResourceLookupFlags): InputStream;
        /**
         * Registers the resource with the process-global set of resources.
         * Once a resource is registered the files in it can be accessed
         * with the global resource lookup functions like g_resources_lookup_data().
         */
        export function resources_register(resource: Resource): void;
        /**
         * Unregisters the resource from the process-global set of resources.
         */
        export function resources_unregister(resource: Resource): void;
        /**
         * Gets the default system schema source.
         *
         * This function is not required for normal uses of #GSettings but it
         * may be useful to authors of plugin management systems or to those who
         * want to introspect the content of schemas.
         *
         * If no schemas are installed, %NULL will be returned.
         *
         * The returned source may actually consist of multiple schema sources
         * from different directories, depending on which directories were given
         * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
         * lookups performed against the default source should probably be done
         * recursively.
         */
        export function settings_schema_source_get_default(): SettingsSchemaSource | null;
        /**
         * Reports an error in an idle function. Similar to
         * g_simple_async_report_error_in_idle(), but takes a #GError rather
         * than building a new one.
         */
        export function simple_async_report_gerror_in_idle(
            object: GObject.Object | null,
            callback: AsyncReadyCallback<GObject.Object | null> | null,
            error: GLib.Error
        ): void;
        /**
         * Gets the default #GTlsBackend for the system.
         */
        export function tls_backend_get_default(): TlsBackend;
        /**
         * Gets the TLS channel binding error quark.
         */
        export function tls_channel_binding_error_quark(): GLib.Quark;
        /**
         * Creates a new #GTlsClientConnection wrapping `base_io_stream `(which
         * must have pollable input and output streams) which is assumed to
         * communicate with the server identified by `server_identity.`
         *
         * See the documentation for #GTlsConnection:base-io-stream for restrictions
         * on when application code can run operations on the `base_io_stream `after
         * this function has returned.
         */
        export function tls_client_connection_new(
            base_io_stream: IOStream,
            server_identity?: SocketConnectable | null
        ): TlsClientConnection;
        /**
         * Gets the TLS error quark.
         */
        export function tls_error_quark(): GLib.Quark;
        /**
         * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
         * in `anchors `to verify certificate chains.
         *
         * The certificates in `anchors `must be PEM encoded.
         */
        export function tls_file_database_new(anchors: string): TlsFileDatabase;
        /**
         * Creates a new #GTlsServerConnection wrapping `base_io_stream `(which
         * must have pollable input and output streams).
         *
         * See the documentation for #GTlsConnection:base-io-stream for restrictions
         * on when application code can run operations on the `base_io_stream `after
         * this function has returned.
         */
        export function tls_server_connection_new(
            base_io_stream: IOStream,
            certificate?: TlsCertificate | null
        ): TlsServerConnection;
        /**
         * Determines if `mount_path `is considered an implementation of the
         * OS. This is primarily used for hiding mountable and mounted volumes
         * that only are used in the OS and has little to no relevance to the
         * casual user.
         */
        export function unix_is_mount_path_system_internal(mount_path: string): boolean;
        /**
         * Determines if `device_path `is considered a block device path which is only
         * used in implementation of the OS. This is primarily used for hiding
         * mounted volumes that are intended as APIs for programs to read, and system
         * administrators at a shell; rather than something that should, for example,
         * appear in a GUI. For example, the Linux `/proc` filesystem.
         *
         * The list of device paths considered ‘system’ ones may change over time.
         */
        export function unix_is_system_device_path(device_path: string): boolean;
        /**
         * Determines if `fs_type `is considered a type of file system which is only
         * used in implementation of the OS. This is primarily used for hiding
         * mounted volumes that are intended as APIs for programs to read, and system
         * administrators at a shell; rather than something that should, for example,
         * appear in a GUI. For example, the Linux `/proc` filesystem.
         *
         * The list of file system types considered ‘system’ ones may change over time.
         */
        export function unix_is_system_fs_type(fs_type: string): boolean;
        /**
         * Gets a #GUnixMountEntry for a given mount path. If time_read
         * is set, it will be filled with a unix timestamp for checking
         * if the mounts have changed since with g_unix_mounts_changed_since().
         *
         * If more mounts have the same mount path, the last matching mount
         * is returned.
         *
         * This will return %NULL if there is no mount point at `mount_path.`
         */
        export function unix_mount_at(mount_path: string): [UnixMountEntry | null, number];
        /**
         * Compares two unix mounts.
         */
        export function unix_mount_compare(mount1: UnixMountEntry, mount2: UnixMountEntry): number;
        /**
         * Makes a copy of `mount_entry.`
         */
        export function unix_mount_copy(mount_entry: UnixMountEntry): UnixMountEntry;
        /**
         * Gets a #GUnixMountEntry for a given file path. If time_read
         * is set, it will be filled with a unix timestamp for checking
         * if the mounts have changed since with g_unix_mounts_changed_since().
         *
         * If more mounts have the same mount path, the last matching mount
         * is returned.
         *
         * This will return %NULL if looking up the mount entry fails, if
         * `file_path `doesn’t exist or there is an I/O error.
         */
        export function unix_mount_for(file_path: string): [UnixMountEntry | null, number];
        /**
         * Frees a unix mount.
         */
        export function unix_mount_free(mount_entry: UnixMountEntry): void;
        /**
         * Gets the device path for a unix mount.
         */
        export function unix_mount_get_device_path(mount_entry: UnixMountEntry): string;
        /**
         * Gets the filesystem type for the unix mount.
         */
        export function unix_mount_get_fs_type(mount_entry: UnixMountEntry): string;
        /**
         * Gets the mount path for a unix mount.
         */
        export function unix_mount_get_mount_path(mount_entry: UnixMountEntry): string;
        /**
         * Gets a comma-separated list of mount options for the unix mount. For example,
         * `rw,relatime,seclabel,data=ordered`.
         *
         * This is similar to g_unix_mount_point_get_options(), but it takes
         * a #GUnixMountEntry as an argument.
         */
        export function unix_mount_get_options(mount_entry: UnixMountEntry): string | null;
        /**
         * Gets the root of the mount within the filesystem. This is useful e.g. for
         * mounts created by bind operation, or btrfs subvolumes.
         *
         * For example, the root path is equal to "/" for mount created by
         * "mount /dev/sda1 /mnt/foo" and "/bar" for
         * "mount --bind /mnt/foo/bar /mnt/bar".
         */
        export function unix_mount_get_root_path(mount_entry: UnixMountEntry): string | null;
        /**
         * Guesses whether a Unix mount can be ejected.
         */
        export function unix_mount_guess_can_eject(mount_entry: UnixMountEntry): boolean;
        /**
         * Guesses the icon of a Unix mount.
         */
        export function unix_mount_guess_icon(mount_entry: UnixMountEntry): Icon;
        /**
         * Guesses the name of a Unix mount.
         * The result is a translated string.
         */
        export function unix_mount_guess_name(mount_entry: UnixMountEntry): string;
        /**
         * Guesses whether a Unix mount should be displayed in the UI.
         */
        export function unix_mount_guess_should_display(mount_entry: UnixMountEntry): boolean;
        /**
         * Guesses the symbolic icon of a Unix mount.
         */
        export function unix_mount_guess_symbolic_icon(mount_entry: UnixMountEntry): Icon;
        /**
         * Checks if a unix mount is mounted read only.
         */
        export function unix_mount_is_readonly(mount_entry: UnixMountEntry): boolean;
        /**
         * Checks if a Unix mount is a system mount. This is the Boolean OR of
         * g_unix_is_system_fs_type(), g_unix_is_system_device_path() and
         * g_unix_is_mount_path_system_internal() on mount_entry’s properties.
         *
         * The definition of what a ‘system’ mount entry is may change over time as new
         * file system types and device paths are ignored.
         */
        export function unix_mount_is_system_internal(mount_entry: UnixMountEntry): boolean;
        /**
         * Gets a #GUnixMountPoint for a given mount path. If `time_read `is set, it
         * will be filled with a unix timestamp for checking if the mount points have
         * changed since with g_unix_mount_points_changed_since().
         *
         * If more mount points have the same mount path, the last matching mount point
         * is returned.
         */
        export function unix_mount_point_at(mount_path: string): [UnixMountPoint | null, number];
        /**
         * Checks if the unix mount points have changed since a given unix time.
         */
        export function unix_mount_points_changed_since(time: number): boolean;
        /**
         * Gets a #GList of #GUnixMountPoint containing the unix mount points.
         * If `time_read `is set, it will be filled with the mount timestamp,
         * allowing for checking if the mounts have changed with
         * g_unix_mount_points_changed_since().
         */
        export function unix_mount_points_get(): [UnixMountPoint[], number];
        /**
         * Checks if the unix mounts have changed since a given unix time.
         */
        export function unix_mounts_changed_since(time: number): boolean;
        /**
         * Gets a #GList of #GUnixMountEntry containing the unix mounts.
         * If `time_read `is set, it will be filled with the mount
         * timestamp, allowing for checking if the mounts have changed
         * with g_unix_mounts_changed_since().
         */
        export function unix_mounts_get(): [UnixMountEntry[], number];
        export type AsyncReadyCallback<A = GObject.Object> = (
            source_object: A | null,
            res: AsyncResult,
            data?: any | null
        ) => void;
        export type BusAcquiredCallback = (connection: DBusConnection, name: string) => void;
        export type BusNameAcquiredCallback = (connection: DBusConnection, name: string) => void;
        export type BusNameAppearedCallback = (connection: DBusConnection, name: string, name_owner: string) => void;
        export type BusNameLostCallback = (connection: DBusConnection, name: string) => void;
        export type BusNameVanishedCallback = (connection: DBusConnection, name: string) => void;
        export type CancellableSourceFunc = (cancellable?: Cancellable | null, data?: any | null) => boolean;
        export type DBusInterfaceGetPropertyFunc = (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            property_name: string,
            error: GLib.Error
        ) => GLib.Variant;
        export type DBusInterfaceMethodCallFunc = (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            method_name: string,
            parameters: GLib.Variant,
            invocation: DBusMethodInvocation
        ) => void;
        export type DBusInterfaceSetPropertyFunc = (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            property_name: string,
            value: GLib.Variant,
            error: GLib.Error
        ) => boolean;
        export type DBusMessageFilterFunction = (
            connection: DBusConnection,
            message: DBusMessage,
            incoming: boolean
        ) => DBusMessage | null;
        export type DBusProxyTypeFunc = (
            manager: DBusObjectManagerClient,
            object_path: string,
            interface_name?: string | null,
            data?: any | null
        ) => GObject.GType;
        export type DBusSignalCallback = (
            connection: DBusConnection,
            sender_name: string | null,
            object_path: string,
            interface_name: string,
            signal_name: string,
            parameters: GLib.Variant
        ) => void;
        export type DBusSubtreeDispatchFunc = (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            node: string,
            out_user_data: any
        ) => DBusInterfaceVTable | null;
        export type DBusSubtreeEnumerateFunc = (
            connection: DBusConnection,
            sender: string,
            object_path: string
        ) => string[];
        export type DBusSubtreeIntrospectFunc = (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            node: string
        ) => DBusInterfaceInfo[] | null;
        export type DatagramBasedSourceFunc = (
            datagram_based: DatagramBased,
            condition: GLib.IOCondition,
            data?: any | null
        ) => boolean;
        export type DesktopAppLaunchCallback = (appinfo: DesktopAppInfo, pid: GLib.Pid) => void;
        export type FileMeasureProgressCallback = (
            reporting: boolean,
            current_size: number,
            num_dirs: number,
            num_files: number,
            data?: any | null
        ) => void;
        export type FileProgressCallback = (
            current_num_bytes: number,
            total_num_bytes: number,
            data?: any | null
        ) => void;
        export type FileReadMoreCallback = (
            file_contents: string,
            file_size: number,
            callback_data?: any | null
        ) => boolean;
        export type IOSchedulerJobFunc = (
            job: IOSchedulerJob,
            cancellable?: Cancellable | null,
            data?: any | null
        ) => boolean;
        export type PollableSourceFunc<A = GObject.Object> = (pollable_stream: A, data?: any | null) => boolean;
        export type ReallocFunc = (data: any | null, size: number) => any | null;
        export type SettingsBindGetMapping = (value: GObject.Value | any, variant: GLib.Variant) => boolean;
        export type SettingsBindSetMapping = (
            value: GObject.Value | any,
            expected_type: GLib.VariantType
        ) => GLib.Variant;
        export type SettingsGetMapping = (value: GLib.Variant) => boolean;
        export type SimpleAsyncThreadFunc<A = GObject.Object> = (
            res: SimpleAsyncResult,
            object: A,
            cancellable?: Cancellable | null
        ) => void;
        export type SocketSourceFunc = (socket: Socket, condition: GLib.IOCondition, data?: any | null) => boolean;
        export type TaskThreadFunc<A = GObject.Object> = (
            task: Task,
            source_object: A,
            task_data?: any | null,
            cancellable?: Cancellable | null
        ) => void;
        export type VfsFileLookupFunc = (vfs: Vfs, identifier: string) => File;

        export namespace AppInfoCreateFlags {
            export const $gtype: GObject.GType<AppInfoCreateFlags>;
        }

        /**
         * Flags used when creating a #GAppInfo.
         */
        export enum AppInfoCreateFlags {
            /**
             * No flags.
             */
            NONE = 0,
            /**
             * Application opens in a terminal window.
             */
            NEEDS_TERMINAL = 1,
            /**
             * Application supports URI arguments.
             */
            SUPPORTS_URIS = 2,
            /**
             * Application supports startup notification. Since 2.26
             */
            SUPPORTS_STARTUP_NOTIFICATION = 4,
        }

        export namespace ApplicationFlags {
            export const $gtype: GObject.GType<ApplicationFlags>;
        }

        /**
         * Flags used to define the behaviour of a #GApplication.
         */
        export enum ApplicationFlags {
            /**
             * Default. Deprecated in 2.74, use
             * %G_APPLICATION_DEFAULT_FLAGS instead
             */
            FLAGS_NONE = 0,
            /**
             * Default flags. Since: 2.74
             */
            DEFAULT_FLAGS = 0,
            /**
             * Run as a service. In this mode, registration
             * fails if the service is already running, and the application
             * will initially wait up to 10 seconds for an initial activation
             * message to arrive.
             */
            IS_SERVICE = 1,
            /**
             * Don't try to become the primary instance.
             */
            IS_LAUNCHER = 2,
            /**
             * This application handles opening files (in
             * the primary instance). Note that this flag only affects the default
             * implementation of local_command_line(), and has no effect if
             * %G_APPLICATION_HANDLES_COMMAND_LINE is given.
             * See g_application_run() for details.
             */
            HANDLES_OPEN = 4,
            /**
             * This application handles command line
             * arguments (in the primary instance). Note that this flag only affect
             * the default implementation of local_command_line().
             * See g_application_run() for details.
             */
            HANDLES_COMMAND_LINE = 8,
            /**
             * Send the environment of the
             * launching process to the primary instance. Set this flag if your
             * application is expected to behave differently depending on certain
             * environment variables. For instance, an editor might be expected
             * to use the `GIT_COMMITTER_NAME` environment variable
             * when editing a git commit message. The environment is available
             * to the #GApplication::command-line signal handler, via
             * g_application_command_line_getenv().
             */
            SEND_ENVIRONMENT = 16,
            /**
             * Make no attempts to do any of the typical
             * single-instance application negotiation, even if the application
             * ID is given.  The application neither attempts to become the
             * owner of the application ID nor does it check if an existing
             * owner already exists.  Everything occurs in the local process.
             * Since: 2.30.
             */
            NON_UNIQUE = 32,
            /**
             * Allow users to override the
             * application ID from the command line with `--gapplication-app-id`.
             * Since: 2.48
             */
            CAN_OVERRIDE_APP_ID = 64,
            /**
             * Allow another instance to take over
             * the bus name. Since: 2.60
             */
            ALLOW_REPLACEMENT = 128,
            /**
             * Take over from another instance. This flag is
             * usually set by passing `--gapplication-replace` on the commandline.
             * Since: 2.60
             */
            REPLACE = 256,
        }

        export namespace AskPasswordFlags {
            export const $gtype: GObject.GType<AskPasswordFlags>;
        }

        /**
         * #GAskPasswordFlags are used to request specific information from the
         * user, or to notify the user of their choices in an authentication
         * situation.
         */
        export enum AskPasswordFlags {
            /**
             * operation requires a password.
             */
            NEED_PASSWORD = 1,
            /**
             * operation requires a username.
             */
            NEED_USERNAME = 2,
            /**
             * operation requires a domain.
             */
            NEED_DOMAIN = 4,
            /**
             * operation supports saving settings.
             */
            SAVING_SUPPORTED = 8,
            /**
             * operation supports anonymous users.
             */
            ANONYMOUS_SUPPORTED = 16,
            /**
             * operation takes TCRYPT parameters (Since: 2.58)
             */
            TCRYPT = 32,
        }

        export namespace BusNameOwnerFlags {
            export const $gtype: GObject.GType<BusNameOwnerFlags>;
        }

        /**
         * Flags used in g_bus_own_name().
         */
        export enum BusNameOwnerFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Allow another message bus connection to claim the name.
             */
            ALLOW_REPLACEMENT = 1,
            /**
             * If another message bus connection owns the name and have
             * specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
             */
            REPLACE = 2,
            /**
             * If another message bus connection owns the name, immediately
             * return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
             */
            DO_NOT_QUEUE = 4,
        }

        export namespace BusNameWatcherFlags {
            export const $gtype: GObject.GType<BusNameWatcherFlags>;
        }

        /**
         * Flags used in g_bus_watch_name().
         */
        export enum BusNameWatcherFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * If no-one owns the name when
             * beginning to watch the name, ask the bus to launch an owner for the
             * name.
             */
            AUTO_START = 1,
        }

        export namespace ConverterFlags {
            export const $gtype: GObject.GType<ConverterFlags>;
        }

        /**
         * Flags used when calling a g_converter_convert().
         */
        export enum ConverterFlags {
            /**
             * No flags.
             */
            NONE = 0,
            /**
             * At end of input data
             */
            INPUT_AT_END = 1,
            /**
             * Flush data
             */
            FLUSH = 2,
        }

        export namespace DBusCallFlags {
            export const $gtype: GObject.GType<DBusCallFlags>;
        }

        /**
         * Flags used in g_dbus_connection_call() and similar APIs.
         */
        export enum DBusCallFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * The bus must not launch
             * an owner for the destination name in response to this method
             * invocation.
             */
            NO_AUTO_START = 1,
            /**
             * the caller is prepared to
             * wait for interactive authorization. Since 2.46.
             */
            ALLOW_INTERACTIVE_AUTHORIZATION = 2,
        }

        export namespace DBusCapabilityFlags {
            export const $gtype: GObject.GType<DBusCapabilityFlags>;
        }

        /**
         * Capabilities negotiated with the remote peer.
         */
        export enum DBusCapabilityFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * The connection
             * supports exchanging UNIX file descriptors with the remote peer.
             */
            UNIX_FD_PASSING = 1,
        }

        export namespace DBusConnectionFlags {
            export const $gtype: GObject.GType<DBusConnectionFlags>;
        }

        /**
         * Flags used when creating a new #GDBusConnection.
         */
        export enum DBusConnectionFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Perform authentication against server.
             */
            AUTHENTICATION_CLIENT = 1,
            /**
             * Perform authentication against client.
             */
            AUTHENTICATION_SERVER = 2,
            /**
             * When
             * authenticating as a server, allow the anonymous authentication
             * method.
             */
            AUTHENTICATION_ALLOW_ANONYMOUS = 4,
            /**
             * Pass this flag if connecting to a peer that is a
             * message bus. This means that the Hello() method will be invoked as part of the connection setup.
             */
            MESSAGE_BUS_CONNECTION = 8,
            /**
             * If set, processing of D-Bus messages is
             * delayed until g_dbus_connection_start_message_processing() is called.
             */
            DELAY_MESSAGE_PROCESSING = 16,
            /**
             * When authenticating
             * as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
             */
            AUTHENTICATION_REQUIRE_SAME_USER = 32,
            /**
             * When authenticating, try to use
             * protocols that work across a Linux user namespace boundary, even if this
             * reduces interoperability with older D-Bus implementations. This currently
             * affects client-side `EXTERNAL` authentication, for which this flag makes
             * connections to a server in another user namespace succeed, but causes
             * a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74
             */
            CROSS_NAMESPACE = 64,
        }

        export namespace DBusInterfaceSkeletonFlags {
            export const $gtype: GObject.GType<DBusInterfaceSkeletonFlags>;
        }

        /**
         * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
         */
        export enum DBusInterfaceSkeletonFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Each method invocation is handled in
             * a thread dedicated to the invocation. This means that the method implementation can use blocking IO
             * without blocking any other part of the process. It also means that the method implementation must
             * use locking to access data structures used by other threads.
             */
            HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1,
        }

        export namespace DBusMessageFlags {
            export const $gtype: GObject.GType<DBusMessageFlags>;
        }

        /**
         * Message flags used in #GDBusMessage.
         */
        export enum DBusMessageFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * A reply is not expected.
             */
            NO_REPLY_EXPECTED = 1,
            /**
             * The bus must not launch an
             * owner for the destination name in response to this message.
             */
            NO_AUTO_START = 2,
            /**
             * If set on a method
             * call, this flag means that the caller is prepared to wait for interactive
             * authorization. Since 2.46.
             */
            ALLOW_INTERACTIVE_AUTHORIZATION = 4,
        }

        export namespace DBusObjectManagerClientFlags {
            export const $gtype: GObject.GType<DBusObjectManagerClientFlags>;
        }

        /**
         * Flags used when constructing a #GDBusObjectManagerClient.
         */
        export enum DBusObjectManagerClientFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * If not set and the
             * manager is for a well-known name, then request the bus to launch
             * an owner for the name if no-one owns the name. This flag can only
             * be used in managers for well-known names.
             */
            DO_NOT_AUTO_START = 1,
        }

        export namespace DBusPropertyInfoFlags {
            export const $gtype: GObject.GType<DBusPropertyInfoFlags>;
        }

        /**
         * Flags describing the access control of a D-Bus property.
         */
        export enum DBusPropertyInfoFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Property is readable.
             */
            READABLE = 1,
            /**
             * Property is writable.
             */
            WRITABLE = 2,
        }

        export namespace DBusProxyFlags {
            export const $gtype: GObject.GType<DBusProxyFlags>;
        }

        /**
         * Flags used when constructing an instance of a #GDBusProxy derived class.
         */
        export enum DBusProxyFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Don't load properties.
             */
            DO_NOT_LOAD_PROPERTIES = 1,
            /**
             * Don't connect to signals on the remote object.
             */
            DO_NOT_CONNECT_SIGNALS = 2,
            /**
             * If the proxy is for a well-known name,
             * do not ask the bus to launch an owner during proxy initialization or a method call.
             * This flag is only meaningful in proxies for well-known names.
             */
            DO_NOT_AUTO_START = 4,
            /**
             * If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
             */
            GET_INVALIDATED_PROPERTIES = 8,
            /**
             * If the proxy is for a well-known name,
             * do not ask the bus to launch an owner during proxy initialization, but allow it to be
             * autostarted by a method call. This flag is only meaningful in proxies for well-known names,
             * and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
             */
            DO_NOT_AUTO_START_AT_CONSTRUCTION = 16,
            /**
             * Don't actually send the AddMatch D-Bus
             * call for this signal subscription. This gives you more control
             * over which match rules you add (but you must add them manually). (Since: 2.72)
             */
            NO_MATCH_RULE = 32,
        }

        export namespace DBusSendMessageFlags {
            export const $gtype: GObject.GType<DBusSendMessageFlags>;
        }

        /**
         * Flags used when sending #GDBusMessages on a #GDBusConnection.
         */
        export enum DBusSendMessageFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Do not automatically
             * assign a serial number from the #GDBusConnection object when
             * sending a message.
             */
            PRESERVE_SERIAL = 1,
        }

        export namespace DBusServerFlags {
            export const $gtype: GObject.GType<DBusServerFlags>;
        }

        /**
         * Flags used when creating a #GDBusServer.
         */
        export enum DBusServerFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * All #GDBusServer::new-connection
             * signals will run in separated dedicated threads (see signal for
             * details).
             */
            RUN_IN_THREAD = 1,
            /**
             * Allow the anonymous
             * authentication method.
             */
            AUTHENTICATION_ALLOW_ANONYMOUS = 2,
            /**
             * Require the UID of the
             * peer to be the same as the UID of the server when authenticating. (Since: 2.68)
             */
            AUTHENTICATION_REQUIRE_SAME_USER = 4,
        }

        export namespace DBusSignalFlags {
            export const $gtype: GObject.GType<DBusSignalFlags>;
        }

        /**
         * Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
         */
        export enum DBusSignalFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Don't actually send the AddMatch
             * D-Bus call for this signal subscription.  This gives you more control
             * over which match rules you add (but you must add them manually).
             */
            NO_MATCH_RULE = 1,
            /**
             * Match first arguments that
             * contain a bus or interface name with the given namespace.
             */
            MATCH_ARG0_NAMESPACE = 2,
            /**
             * Match first arguments that
             * contain an object path that is either equivalent to the given path,
             * or one of the paths is a subpath of the other.
             */
            MATCH_ARG0_PATH = 4,
        }

        export namespace DBusSubtreeFlags {
            export const $gtype: GObject.GType<DBusSubtreeFlags>;
        }

        /**
         * Flags passed to g_dbus_connection_register_subtree().
         */
        export enum DBusSubtreeFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Method calls to objects not in the enumerated range
             * will still be dispatched. This is useful if you want
             * to dynamically spawn objects in the subtree.
             */
            DISPATCH_TO_UNENUMERATED_NODES = 1,
        }

        export namespace DriveStartFlags {
            export const $gtype: GObject.GType<DriveStartFlags>;
        }

        /**
         * Flags used when starting a drive.
         */
        export enum DriveStartFlags {
            /**
             * No flags set.
             */
            NONE = 0,
        }

        export namespace FileAttributeInfoFlags {
            export const $gtype: GObject.GType<FileAttributeInfoFlags>;
        }

        /**
         * Flags specifying the behaviour of an attribute.
         */
        export enum FileAttributeInfoFlags {
            /**
             * no flags set.
             */
            NONE = 0,
            /**
             * copy the attribute values when the file is copied.
             */
            COPY_WITH_FILE = 1,
            /**
             * copy the attribute values when the file is moved.
             */
            COPY_WHEN_MOVED = 2,
        }

        export namespace FileCopyFlags {
            export const $gtype: GObject.GType<FileCopyFlags>;
        }

        /**
         * Flags used when copying or moving files.
         */
        export enum FileCopyFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Overwrite any existing files
             */
            OVERWRITE = 1,
            /**
             * Make a backup of any existing files.
             */
            BACKUP = 2,
            /**
             * Don't follow symlinks.
             */
            NOFOLLOW_SYMLINKS = 4,
            /**
             * Copy all file metadata instead of just default set used for copy (see #GFileInfo).
             */
            ALL_METADATA = 8,
            /**
             * Don't use copy and delete fallback if native move not supported.
             */
            NO_FALLBACK_FOR_MOVE = 16,
            /**
             * Leaves target file with default perms, instead of setting the source file perms.
             */
            TARGET_DEFAULT_PERMS = 32,
        }

        export namespace FileCreateFlags {
            export const $gtype: GObject.GType<FileCreateFlags>;
        }

        /**
         * Flags used when an operation may create a file.
         */
        export enum FileCreateFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Create a file that can only be
             * accessed by the current user.
             */
            PRIVATE = 1,
            /**
             * Replace the destination
             * as if it didn't exist before. Don't try to keep any old
             * permissions, replace instead of following links. This
             * is generally useful if you're doing a "copy over"
             * rather than a "save new version of" replace operation.
             * You can think of it as "unlink destination" before
             * writing to it, although the implementation may not
             * be exactly like that. This flag can only be used with
             * g_file_replace() and its variants, including g_file_replace_contents().
             * Since 2.20
             */
            REPLACE_DESTINATION = 2,
        }

        export namespace FileMeasureFlags {
            export const $gtype: GObject.GType<FileMeasureFlags>;
        }

        /**
         * Flags that can be used with g_file_measure_disk_usage().
         */
        export enum FileMeasureFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Report any error encountered
             * while traversing the directory tree.  Normally errors are only
             * reported for the toplevel file.
             */
            REPORT_ANY_ERROR = 2,
            /**
             * Tally usage based on apparent file
             * sizes.  Normally, the block-size is used, if available, as this is a
             * more accurate representation of disk space used.
             * Compare with `du --apparent-size`.
             */
            APPARENT_SIZE = 4,
            /**
             * Do not cross mount point boundaries.
             * Compare with `du -x`.
             */
            NO_XDEV = 8,
        }

        export namespace FileMonitorFlags {
            export const $gtype: GObject.GType<FileMonitorFlags>;
        }

        /**
         * Flags used to set what a #GFileMonitor will watch for.
         */
        export enum FileMonitorFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Watch for mount events.
             */
            WATCH_MOUNTS = 1,
            /**
             * Pair DELETED and CREATED events caused
             * by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
             * event instead (NB: not supported on all backends; the default
             * behaviour -without specifying this flag- is to send single DELETED
             * and CREATED events).  Deprecated since 2.46: use
             * %G_FILE_MONITOR_WATCH_MOVES instead.
             */
            SEND_MOVED = 2,
            /**
             * Watch for changes to the file made
             * via another hard link. Since 2.36.
             */
            WATCH_HARD_LINKS = 4,
            /**
             * Watch for rename operations on a
             * monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
             * %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
             * events to be emitted when possible.  Since: 2.46.
             */
            WATCH_MOVES = 8,
        }

        export namespace FileQueryInfoFlags {
            export const $gtype: GObject.GType<FileQueryInfoFlags>;
        }

        /**
         * Flags used when querying a #GFileInfo.
         */
        export enum FileQueryInfoFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Don't follow symlinks.
             */
            NOFOLLOW_SYMLINKS = 1,
        }

        export namespace IOStreamSpliceFlags {
            export const $gtype: GObject.GType<IOStreamSpliceFlags>;
        }

        /**
         * GIOStreamSpliceFlags determine how streams should be spliced.
         */
        export enum IOStreamSpliceFlags {
            /**
             * Do not close either stream.
             */
            NONE = 0,
            /**
             * Close the first stream after
             * the splice.
             */
            CLOSE_STREAM1 = 1,
            /**
             * Close the second stream after
             * the splice.
             */
            CLOSE_STREAM2 = 2,
            /**
             * Wait for both splice operations to finish
             * before calling the callback.
             */
            WAIT_FOR_BOTH = 4,
        }

        export namespace MountMountFlags {
            export const $gtype: GObject.GType<MountMountFlags>;
        }

        /**
         * Flags used when mounting a mount.
         */
        export enum MountMountFlags {
            /**
             * No flags set.
             */
            NONE = 0,
        }

        export namespace MountUnmountFlags {
            export const $gtype: GObject.GType<MountUnmountFlags>;
        }

        /**
         * Flags used when an unmounting a mount.
         */
        export enum MountUnmountFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * Unmount even if there are outstanding
             * file operations on the mount.
             */
            FORCE = 1,
        }

        export namespace OutputStreamSpliceFlags {
            export const $gtype: GObject.GType<OutputStreamSpliceFlags>;
        }

        /**
         * GOutputStreamSpliceFlags determine how streams should be spliced.
         */
        export enum OutputStreamSpliceFlags {
            /**
             * Do not close either stream.
             */
            NONE = 0,
            /**
             * Close the source stream after
             * the splice.
             */
            CLOSE_SOURCE = 1,
            /**
             * Close the target stream after
             * the splice.
             */
            CLOSE_TARGET = 2,
        }

        export namespace ResolverNameLookupFlags {
            export const $gtype: GObject.GType<ResolverNameLookupFlags>;
        }

        /**
         * Flags to modify lookup behavior.
         */
        export enum ResolverNameLookupFlags {
            /**
             * default behavior (same as g_resolver_lookup_by_name())
             */
            DEFAULT = 0,
            /**
             * only resolve ipv4 addresses
             */
            IPV4_ONLY = 1,
            /**
             * only resolve ipv6 addresses
             */
            IPV6_ONLY = 2,
        }

        export namespace ResourceFlags {
            export const $gtype: GObject.GType<ResourceFlags>;
        }

        /**
         * GResourceFlags give information about a particular file inside a resource
         * bundle.
         */
        export enum ResourceFlags {
            /**
             * No flags set.
             */
            NONE = 0,
            /**
             * The file is compressed.
             */
            COMPRESSED = 1,
        }

        export namespace ResourceLookupFlags {
            export const $gtype: GObject.GType<ResourceLookupFlags>;
        }

        /**
         * GResourceLookupFlags determine how resource path lookups are handled.
         */
        export enum ResourceLookupFlags {
            /**
             * No flags set.
             */
            NONE = 0,
        }

        export namespace SettingsBindFlags {
            export const $gtype: GObject.GType<SettingsBindFlags>;
        }

        /**
         * Flags used when creating a binding. These flags determine in which
         * direction the binding works. The default is to synchronize in both
         * directions.
         */
        export enum SettingsBindFlags {
            /**
             * Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
             */
            DEFAULT = 0,
            /**
             * Update the #GObject property when the setting changes.
             * It is an error to use this flag if the property is not writable.
             */
            GET = 1,
            /**
             * Update the setting when the #GObject property changes.
             * It is an error to use this flag if the property is not readable.
             */
            SET = 2,
            /**
             * Do not try to bind a "sensitivity" property to the writability of the setting
             */
            NO_SENSITIVITY = 4,
            /**
             * When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property
             * value initially from the setting, but do not listen for changes of the setting
             */
            GET_NO_CHANGES = 8,
            /**
             * When passed to g_settings_bind(), uses a pair of mapping functions that invert
             * the boolean value when mapping between the setting and the property.  The setting and property must both
             * be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
             */
            INVERT_BOOLEAN = 16,
        }

        export namespace SocketMsgFlags {
            export const $gtype: GObject.GType<SocketMsgFlags>;
        }

        /**
         * Flags used in g_socket_receive_message() and g_socket_send_message().
         * The flags listed in the enum are some commonly available flags, but the
         * values used for them are the same as on the platform, and any other flags
         * are passed in/out as is. So to use a platform specific flag, just include
         * the right system header and pass in the flag.
         */
        export enum SocketMsgFlags {
            /**
             * No flags.
             */
            NONE = 0,
            /**
             * Request to send/receive out of band data.
             */
            OOB = 1,
            /**
             * Read data from the socket without removing it from
             * the queue.
             */
            PEEK = 2,
            /**
             * Don't use a gateway to send out the packet,
             * only send to hosts on directly connected networks.
             */
            DONTROUTE = 4,
        }

        export namespace SubprocessFlags {
            export const $gtype: GObject.GType<SubprocessFlags>;
        }

        /**
         * Flags to define the behaviour of a #GSubprocess.
         *
         * Note that the default for stdin is to redirect from `/dev/null`.  For
         * stdout and stderr the default are for them to inherit the
         * corresponding descriptor from the calling process.
         *
         * Note that it is a programmer error to mix 'incompatible' flags.  For
         * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
         * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
         */
        export enum SubprocessFlags {
            /**
             * No flags.
             */
            NONE = 0,
            /**
             * create a pipe for the stdin of the
             * spawned process that can be accessed with
             * g_subprocess_get_stdin_pipe().
             */
            STDIN_PIPE = 1,
            /**
             * stdin is inherited from the
             * calling process.
             */
            STDIN_INHERIT = 2,
            /**
             * create a pipe for the stdout of the
             * spawned process that can be accessed with
             * g_subprocess_get_stdout_pipe().
             */
            STDOUT_PIPE = 4,
            /**
             * silence the stdout of the spawned
             * process (ie: redirect to `/dev/null`).
             */
            STDOUT_SILENCE = 8,
            /**
             * create a pipe for the stderr of the
             * spawned process that can be accessed with
             * g_subprocess_get_stderr_pipe().
             */
            STDERR_PIPE = 16,
            /**
             * silence the stderr of the spawned
             * process (ie: redirect to `/dev/null`).
             */
            STDERR_SILENCE = 32,
            /**
             * merge the stderr of the spawned
             * process with whatever the stdout happens to be.  This is a good way
             * of directing both streams to a common log file, for example.
             */
            STDERR_MERGE = 64,
            /**
             * spawned processes will inherit the
             * file descriptors of their parent, unless those descriptors have
             * been explicitly marked as close-on-exec.  This flag has no effect
             * over the "standard" file descriptors (stdin, stdout, stderr).
             */
            INHERIT_FDS = 128,
            /**
             * if path searching is
             * needed when spawning the subprocess, use the `PATH` in the launcher
             * environment. (Since: 2.72)
             */
            SEARCH_PATH_FROM_ENVP = 256,
        }

        export namespace TestDBusFlags {
            export const $gtype: GObject.GType<TestDBusFlags>;
        }

        /**
         * Flags to define future #GTestDBus behaviour.
         */
        export enum TestDBusFlags {
            /**
             * No flags.
             */
            NONE = 0,
        }

        export namespace TlsCertificateFlags {
            export const $gtype: GObject.GType<TlsCertificateFlags>;
        }

        /**
         * A set of flags describing TLS certification validation. This can be
         * used to describe why a particular certificate was rejected (for
         * example, in #GTlsConnection::accept-certificate).
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate.
         */
        export enum TlsCertificateFlags {
            /**
             * No flags set. Since: 2.74
             */
            NO_FLAGS = 0,
            /**
             * The signing certificate authority is
             * not known.
             */
            UNKNOWN_CA = 1,
            /**
             * The certificate does not match the
             * expected identity of the site that it was retrieved from.
             */
            BAD_IDENTITY = 2,
            /**
             * The certificate's activation time
             * is still in the future
             */
            NOT_ACTIVATED = 4,
            /**
             * The certificate has expired
             */
            EXPIRED = 8,
            /**
             * The certificate has been revoked
             * according to the #GTlsConnection's certificate revocation list.
             */
            REVOKED = 16,
            /**
             * The certificate's algorithm is
             * considered insecure.
             */
            INSECURE = 32,
            /**
             * Some other error occurred validating
             * the certificate
             */
            GENERIC_ERROR = 64,
            /**
             * the combination of all of the above
             * flags
             */
            VALIDATE_ALL = 127,
        }

        export namespace TlsDatabaseVerifyFlags {
            export const $gtype: GObject.GType<TlsDatabaseVerifyFlags>;
        }

        /**
         * Flags for g_tls_database_verify_chain().
         */
        export enum TlsDatabaseVerifyFlags {
            /**
             * No verification flags
             */
            NONE = 0,
        }

        export namespace TlsPasswordFlags {
            export const $gtype: GObject.GType<TlsPasswordFlags>;
        }

        /**
         * Various flags for the password.
         */
        export enum TlsPasswordFlags {
            /**
             * No flags
             */
            NONE = 0,
            /**
             * The password was wrong, and the user should retry.
             */
            RETRY = 2,
            /**
             * Hint to the user that the password has been
             * wrong many times, and the user may not have many chances left.
             */
            MANY_TRIES = 4,
            /**
             * Hint to the user that this is the last try to get
             * this password right.
             */
            FINAL_TRY = 8,
            /**
             * For PKCS #11, the user PIN is required.
             * Since: 2.70.
             */
            PKCS11_USER = 16,
            /**
             * For PKCS #11, the security officer
             * PIN is required. Since: 2.70.
             */
            PKCS11_SECURITY_OFFICER = 32,
            /**
             * For PKCS #11, the context-specific
             * PIN is required. Since: 2.70.
             */
            PKCS11_CONTEXT_SPECIFIC = 64,
        }
        export module AppInfoMonitor {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class AppInfoMonitor extends GObject.Object {
            static $gtype: GObject.GType<AppInfoMonitor>;

            constructor(properties?: Partial<AppInfoMonitor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<AppInfoMonitor.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "changed", callback: (_source: this) => void): number;
            connect_after(signal: "changed", callback: (_source: this) => void): number;
            emit(signal: "changed"): void;

            // Members

            /**
             * Gets the #GAppInfoMonitor for the current thread-default main
             * context.
             *
             * The #GAppInfoMonitor will emit a "changed" signal in the
             * thread-default main context whenever the list of installed
             * applications (as reported by g_app_info_get_all()) may have changed.
             *
             * You must only call g_object_unref() on the return value from under
             * the same main context as you created it.
             */
            static get(): AppInfoMonitor;
        }
        export module AppLaunchContext {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class AppLaunchContext extends GObject.Object {
            static $gtype: GObject.GType<AppLaunchContext>;

            constructor(properties?: Partial<AppLaunchContext.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<AppLaunchContext.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "launch-failed", callback: (_source: this, startup_notify_id: string) => void): number;
            connect_after(
                signal: "launch-failed",
                callback: (_source: this, startup_notify_id: string) => void
            ): number;
            emit(signal: "launch-failed", startup_notify_id: string): void;
            connect(
                signal: "launch-started",
                callback: (_source: this, info: AppInfo, platform_data: GLib.Variant | null) => void
            ): number;
            connect_after(
                signal: "launch-started",
                callback: (_source: this, info: AppInfo, platform_data: GLib.Variant | null) => void
            ): number;
            emit(signal: "launch-started", info: AppInfo, platform_data?: GLib.Variant | null): void;
            connect(
                signal: "launched",
                callback: (_source: this, info: AppInfo, platform_data: GLib.Variant) => void
            ): number;
            connect_after(
                signal: "launched",
                callback: (_source: this, info: AppInfo, platform_data: GLib.Variant) => void
            ): number;
            emit(signal: "launched", info: AppInfo, platform_data: GLib.Variant): void;

            // Constructors

            static ["new"](): AppLaunchContext;

            // Members

            /**
             * Gets the display string for the `context.` This is used to ensure new
             * applications are started on the same display as the launching
             * application, by setting the `DISPLAY` environment variable.
             */
            get_display(info: AppInfo, files: File[]): string | null;
            /**
             * Gets the complete environment variable list to be passed to
             * the child process when `context `is used to launch an application.
             * This is a %NULL-terminated array of strings, where each string has
             * the form `KEY=VALUE`.
             */
            get_environment(): string[];
            /**
             * Initiates startup notification for the application and returns the
             * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
             * if supported.
             *
             * The returned token may be referred to equivalently as an ‘activation token’
             * (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
             * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
             *
             * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
             * and startup notification IDs are defined in the
             * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
             *
             * Support for the XDG Activation Protocol was added in GLib 2.76.
             */
            get_startup_notify_id(info: AppInfo, files: File[]): string | null;
            /**
             * Called when an application has failed to launch, so that it can cancel
             * the application startup notification started in g_app_launch_context_get_startup_notify_id().
             */
            launch_failed(startup_notify_id: string): void;
            /**
             * Arranges for `variable `to be set to `value `in the child's
             * environment when `context `is used to launch an application.
             */
            setenv(variable: string, value: string): void;
            /**
             * Arranges for `variable `to be unset in the child's environment
             * when `context `is used to launch an application.
             */
            unsetenv(variable: string): void;
            /**
             * Gets the display string for the `context.` This is used to ensure new
             * applications are started on the same display as the launching
             * application, by setting the `DISPLAY` environment variable.
             */
            vfunc_get_display(info: AppInfo, files: File[]): string | null;
            /**
             * Initiates startup notification for the application and returns the
             * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
             * if supported.
             *
             * The returned token may be referred to equivalently as an ‘activation token’
             * (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
             * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
             *
             * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
             * and startup notification IDs are defined in the
             * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
             *
             * Support for the XDG Activation Protocol was added in GLib 2.76.
             */
            vfunc_get_startup_notify_id(info: AppInfo, files: File[]): string | null;
            /**
             * Called when an application has failed to launch, so that it can cancel
             * the application startup notification started in g_app_launch_context_get_startup_notify_id().
             */
            vfunc_launch_failed(startup_notify_id: string): void;
            vfunc_launch_started(info: AppInfo, platform_data: GLib.Variant): void;
            vfunc_launched(info: AppInfo, platform_data: GLib.Variant): void;
        }
        export module Application {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                action_group: ActionGroup;
                actionGroup: ActionGroup;
                application_id: string;
                applicationId: string;
                flags: ApplicationFlags;
                inactivity_timeout: number;
                inactivityTimeout: number;
                is_busy: boolean;
                isBusy: boolean;
                is_registered: boolean;
                isRegistered: boolean;
                is_remote: boolean;
                isRemote: boolean;
                resource_base_path: string;
                resourceBasePath: string;
            }
        }
        export class Application extends GObject.Object implements ActionGroup, ActionMap {
            static $gtype: GObject.GType<Application>;

            constructor(properties?: Partial<Application.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Application.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set action_group(val: ActionGroup);
            set actionGroup(val: ActionGroup);
            get application_id(): string;
            set application_id(val: string);
            get applicationId(): string;
            set applicationId(val: string);
            get flags(): ApplicationFlags;
            set flags(val: ApplicationFlags);
            get inactivity_timeout(): number;
            set inactivity_timeout(val: number);
            get inactivityTimeout(): number;
            set inactivityTimeout(val: number);
            get is_busy(): boolean;
            get isBusy(): boolean;
            get is_registered(): boolean;
            get isRegistered(): boolean;
            get is_remote(): boolean;
            get isRemote(): boolean;
            get resource_base_path(): string;
            set resource_base_path(val: string);
            get resourceBasePath(): string;
            set resourceBasePath(val: string);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "activate", callback: (_source: this) => void): number;
            connect_after(signal: "activate", callback: (_source: this) => void): number;
            emit(signal: "activate"): void;
            connect(
                signal: "command-line",
                callback: (_source: this, command_line: ApplicationCommandLine) => number
            ): number;
            connect_after(
                signal: "command-line",
                callback: (_source: this, command_line: ApplicationCommandLine) => number
            ): number;
            emit(signal: "command-line", command_line: ApplicationCommandLine): void;
            connect(
                signal: "handle-local-options",
                callback: (_source: this, options: GLib.VariantDict) => number
            ): number;
            connect_after(
                signal: "handle-local-options",
                callback: (_source: this, options: GLib.VariantDict) => number
            ): number;
            emit(signal: "handle-local-options", options: GLib.VariantDict): void;
            connect(signal: "name-lost", callback: (_source: this) => boolean): number;
            connect_after(signal: "name-lost", callback: (_source: this) => boolean): number;
            emit(signal: "name-lost"): void;
            connect(signal: "open", callback: (_source: this, files: File[], hint: string) => void): number;
            connect_after(signal: "open", callback: (_source: this, files: File[], hint: string) => void): number;
            emit(signal: "open", files: File[], hint: string): void;
            connect(signal: "shutdown", callback: (_source: this) => void): number;
            connect_after(signal: "shutdown", callback: (_source: this) => void): number;
            emit(signal: "shutdown"): void;
            connect(signal: "startup", callback: (_source: this) => void): number;
            connect_after(signal: "startup", callback: (_source: this) => void): number;
            emit(signal: "startup"): void;

            // Constructors

            static ["new"](application_id: string | null, flags: ApplicationFlags): Application;

            // Members

            /**
             * Activates the application.
             *
             * In essence, this results in the #GApplication::activate signal being
             * emitted in the primary instance.
             *
             * The application must be registered before calling this function.
             */
            activate(): void;
            /**
             * Add an option to be handled by `application.`
             *
             * Calling this function is the equivalent of calling
             * g_application_add_main_option_entries() with a single #GOptionEntry
             * that has its arg_data member set to %NULL.
             *
             * The parsed arguments will be packed into a #GVariantDict which
             * is passed to #GApplication::handle-local-options. If
             * %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
             * be sent to the primary instance. See
             * g_application_add_main_option_entries() for more details.
             *
             * See #GOptionEntry for more documentation of the arguments.
             */
            add_main_option(
                long_name: string,
                short_name: number,
                flags: GLib.OptionFlags,
                arg: GLib.OptionArg,
                description: string,
                arg_description?: string | null
            ): void;
            /**
             * Adds main option entries to be handled by `application.`
             *
             * This function is comparable to g_option_context_add_main_entries().
             *
             * After the commandline arguments are parsed, the
             * #GApplication::handle-local-options signal will be emitted.  At this
             * point, the application can inspect the values pointed to by arg_data
             * in the given #GOptionEntrys.
             *
             * Unlike #GOptionContext, #GApplication supports giving a %NULL
             * `arg_data `for a non-callback #GOptionEntry.  This results in the
             * argument in question being packed into a #GVariantDict which is also
             * passed to #GApplication::handle-local-options, where it can be
             * inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
             * set, then the resulting dictionary is sent to the primary instance,
             * where g_application_command_line_get_options_dict() will return it.
             * As it has been passed outside the process at this point, the types of all
             * values in the options dict must be checked before being used.
             * This "packing" is done according to the type of the argument --
             * booleans for normal flags, strings for strings, bytestrings for
             * filenames, etc.  The packing only occurs if the flag is given (ie: we
             * do not pack a "false" #GVariant in the case that a flag is missing).
             *
             * In general, it is recommended that all commandline arguments are
             * parsed locally.  The options dictionary should then be used to
             * transmit the result of the parsing to the primary instance, where
             * g_variant_dict_lookup() can be used.  For local options, it is
             * possible to either use `arg_data `in the usual way, or to consult (and
             * potentially remove) the option from the options dictionary.
             *
             * This function is new in GLib 2.40.  Before then, the only real choice
             * was to send all of the commandline arguments (options and all) to the
             * primary instance for handling.  #GApplication ignored them completely
             * on the local side.  Calling this function "opts in" to the new
             * behaviour, and in particular, means that unrecognised options will be
             * treated as errors.  Unrecognised options have never been ignored when
             * %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
             *
             * If #GApplication::handle-local-options needs to see the list of
             * filenames, then the use of %G_OPTION_REMAINING is recommended.  If
             * `arg_data `is %NULL then %G_OPTION_REMAINING can be used as a key into
             * the options dictionary.  If you do use %G_OPTION_REMAINING then you
             * need to handle these arguments for yourself because once they are
             * consumed, they will no longer be visible to the default handling
             * (which treats them as filenames to be opened).
             *
             * It is important to use the proper GVariant format when retrieving
             * the options with g_variant_dict_lookup():
             * - for %G_OPTION_ARG_NONE, use `b`
             * - for %G_OPTION_ARG_STRING, use `&amp;s`
             * - for %G_OPTION_ARG_INT, use `i`
             * - for %G_OPTION_ARG_INT64, use `x`
             * - for %G_OPTION_ARG_DOUBLE, use `d`
             * - for %G_OPTION_ARG_FILENAME, use `^&amp;ay`
             * - for %G_OPTION_ARG_STRING_ARRAY, use `^a&amp;s`
             * - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&amp;ay`
             */
            add_main_option_entries(entries: GLib.OptionEntry[]): void;
            /**
             * Adds a #GOptionGroup to the commandline handling of `application.`
             *
             * This function is comparable to g_option_context_add_group().
             *
             * Unlike g_application_add_main_option_entries(), this function does
             * not deal with %NULL `arg_data `and never transmits options to the
             * primary instance.
             *
             * The reason for that is because, by the time the options arrive at the
             * primary instance, it is typically too late to do anything with them.
             * Taking the GTK option group as an example: GTK will already have been
             * initialised by the time the #GApplication::command-line handler runs.
             * In the case that this is not the first-running instance of the
             * application, the existing instance may already have been running for
             * a very long time.
             *
             * This means that the options from #GOptionGroup are only really usable
             * in the case that the instance of the application being run is the
             * first instance.  Passing options like `--display=` or `--gdk-debug=`
             * on future runs will have no effect on the existing primary instance.
             *
             * Calling this function will cause the options in the supplied option
             * group to be parsed, but it does not cause you to be "opted in" to the
             * new functionality whereby unrecognised options are rejected even if
             * %G_APPLICATION_HANDLES_COMMAND_LINE was given.
             */
            add_option_group(group: GLib.OptionGroup): void;
            /**
             * Marks `application `as busy (see g_application_mark_busy()) while
             * `property `on `object `is %TRUE.
             *
             * The binding holds a reference to `application `while it is active, but
             * not to `object.` Instead, the binding is destroyed when `object `is
             * finalized.
             */
            bind_busy_property(object: GObject.Object, property: string): void;
            /**
             * Gets the unique identifier for `application.`
             */
            get_application_id(): string | null;
            /**
             * Gets the #GDBusConnection being used by the application, or %NULL.
             *
             * If #GApplication is using its D-Bus backend then this function will
             * return the #GDBusConnection being used for uniqueness and
             * communication with the desktop environment and other instances of the
             * application.
             *
             * If #GApplication is not using D-Bus then this function will return
             * %NULL.  This includes the situation where the D-Bus backend would
             * normally be in use but we were unable to connect to the bus.
             *
             * This function must not be called before the application has been
             * registered.  See g_application_get_is_registered().
             */
            get_dbus_connection(): DBusConnection | null;
            /**
             * Gets the D-Bus object path being used by the application, or %NULL.
             *
             * If #GApplication is using its D-Bus backend then this function will
             * return the D-Bus object path that #GApplication is using.  If the
             * application is the primary instance then there is an object published
             * at this path.  If the application is not the primary instance then
             * the result of this function is undefined.
             *
             * If #GApplication is not using D-Bus then this function will return
             * %NULL.  This includes the situation where the D-Bus backend would
             * normally be in use but we were unable to connect to the bus.
             *
             * This function must not be called before the application has been
             * registered.  See g_application_get_is_registered().
             */
            get_dbus_object_path(): string | null;
            /**
             * Gets the flags for `application.`
             *
             * See #GApplicationFlags.
             */
            get_flags(): ApplicationFlags;
            /**
             * Gets the current inactivity timeout for the application.
             *
             * This is the amount of time (in milliseconds) after the last call to
             * g_application_release() before the application stops running.
             */
            get_inactivity_timeout(): number;
            /**
             * Gets the application's current busy state, as set through
             * g_application_mark_busy() or g_application_bind_busy_property().
             */
            get_is_busy(): boolean;
            /**
             * Checks if `application `is registered.
             *
             * An application is registered if g_application_register() has been
             * successfully called.
             */
            get_is_registered(): boolean;
            /**
             * Checks if `application `is remote.
             *
             * If `application `is remote then it means that another instance of
             * application already exists (the 'primary' instance).  Calls to
             * perform actions on `application `will result in the actions being
             * performed by the primary instance.
             *
             * The value of this property cannot be accessed before
             * g_application_register() has been called.  See
             * g_application_get_is_registered().
             */
            get_is_remote(): boolean;
            /**
             * Gets the resource base path of `application.`
             *
             * See g_application_set_resource_base_path() for more information.
             */
            get_resource_base_path(): string | null;
            /**
             * Increases the use count of `application.`
             *
             * Use this function to indicate that the application has a reason to
             * continue to run.  For example, g_application_hold() is called by GTK+
             * when a toplevel window is on the screen.
             *
             * To cancel the hold, call g_application_release().
             */
            hold(): void;
            /**
             * Increases the busy count of `application.`
             *
             * Use this function to indicate that the application is busy, for instance
             * while a long running operation is pending.
             *
             * The busy state will be exposed to other processes, so a session shell will
             * use that information to indicate the state to the user (e.g. with a
             * spinner).
             *
             * To cancel the busy indication, use g_application_unmark_busy().
             *
             * The application must be registered before calling this function.
             */
            mark_busy(): void;
            /**
             * Opens the given files.
             *
             * In essence, this results in the #GApplication::open signal being emitted
             * in the primary instance.
             *
             * `n_files `must be greater than zero.
             *
             * `hint `is simply passed through to the ::open signal.  It is
             * intended to be used by applications that have multiple modes for
             * opening files (eg: "view" vs "edit", etc).  Unless you have a need
             * for this functionality, you should use "".
             *
             * The application must be registered before calling this function
             * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
             */
            open(files: File[], hint: string): void;
            /**
             * Immediately quits the application.
             *
             * Upon return to the mainloop, g_application_run() will return,
             * calling only the 'shutdown' function before doing so.
             *
             * The hold count is ignored.
             * Take care if your code has called g_application_hold() on the application and
             * is therefore still expecting it to exist.
             * (Note that you may have called g_application_hold() indirectly, for example
             * through gtk_application_add_window().)
             *
             * The result of calling g_application_run() again after it returns is
             * unspecified.
             */
            quit(): void;
            /**
             * Attempts registration of the application.
             *
             * This is the point at which the application discovers if it is the
             * primary instance or merely acting as a remote for an already-existing
             * primary instance.  This is implemented by attempting to acquire the
             * application identifier as a unique bus name on the session bus using
             * GDBus.
             *
             * If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
             * given, then this process will always become the primary instance.
             *
             * Due to the internal architecture of GDBus, method calls can be
             * dispatched at any time (even if a main loop is not running).  For
             * this reason, you must ensure that any object paths that you wish to
             * register are registered before calling this function.
             *
             * If the application has already been registered then %TRUE is
             * returned with no work performed.
             *
             * The #GApplication::startup signal is emitted if registration succeeds
             * and `application `is the primary instance (including the non-unique
             * case).
             *
             * In the event of an error (such as `cancellable `being cancelled, or a
             * failure to connect to the session bus), %FALSE is returned and error
             * is set appropriately.
             *
             * Note: the return value of this function is not an indicator that this
             * instance is or is not the primary instance of the application.  See
             * g_application_get_is_remote() for that.
             */
            register(cancellable?: Cancellable | null): boolean;
            /**
             * Decrease the use count of `application.`
             *
             * When the use count reaches zero, the application will stop running.
             *
             * Never call this function except to cancel the effect of a previous
             * call to g_application_hold().
             */
            release(): void;
            /**
             * Runs the application.
             *
             * This function is intended to be run from main() and its return value
             * is intended to be returned by main(). Although you are expected to pass
             * the argc, `argv `parameters from main() to this function, it is possible
             * to pass %NULL if `argv `is not available or commandline handling is not
             * required.  Note that on Windows, `argc `and `argv `are ignored, and
             * g_win32_get_command_line() is called internally (for proper support
             * of Unicode commandline arguments).
             *
             * #GApplication will attempt to parse the commandline arguments.  You
             * can add commandline flags to the list of recognised options by way of
             * g_application_add_main_option_entries().  After this, the
             * #GApplication::handle-local-options signal is emitted, from which the
             * application can inspect the values of its #GOptionEntrys.
             *
             * #GApplication::handle-local-options is a good place to handle options
             * such as `--version`, where an immediate reply from the local process is
             * desired (instead of communicating with an already-running instance).
             * A #GApplication::handle-local-options handler can stop further processing
             * by returning a non-negative value, which then becomes the exit status of
             * the process.
             *
             * What happens next depends on the flags: if
             * %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
             * commandline arguments are sent to the primary instance, where a
             * #GApplication::command-line signal is emitted.  Otherwise, the
             * remaining commandline arguments are assumed to be a list of files.
             * If there are no files listed, the application is activated via the
             * #GApplication::activate signal.  If there are one or more files, and
             * %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
             * via the #GApplication::open signal.
             *
             * If you are interested in doing more complicated local handling of the
             * commandline then you should implement your own #GApplication subclass
             * and override local_command_line(). In this case, you most likely want
             * to return %TRUE from your local_command_line() implementation to
             * suppress the default handling. See
             * [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
             * for an example.
             *
             * If, after the above is done, the use count of the application is zero
             * then the exit status is returned immediately.  If the use count is
             * non-zero then the default main context is iterated until the use count
             * falls to zero, at which point 0 is returned.
             *
             * If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
             * run for as much as 10 seconds with a use count of zero while waiting
             * for the message that caused the activation to arrive.  After that,
             * if the use count falls to zero the application will exit immediately,
             * except in the case that g_application_set_inactivity_timeout() is in
             * use.
             *
             * This function sets the prgname (g_set_prgname()), if not already set,
             * to the basename of argv[0].
             *
             * Much like g_main_loop_run(), this function will acquire the main context
             * for the duration that the application is running.
             *
             * Since 2.40, applications that are not explicitly flagged as services
             * or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
             * %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
             * default handler for local_command_line) if "--gapplication-service"
             * was given in the command line.  If this flag is present then normal
             * commandline processing is interrupted and the
             * %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
             * solution whereby running an application directly from the commandline
             * will invoke it in the normal way (which can be useful for debugging)
             * while still allowing applications to be D-Bus activated in service
             * mode.  The D-Bus service file should invoke the executable with
             * "--gapplication-service" as the sole commandline argument.  This
             * approach is suitable for use by most graphical applications but
             * should not be used from applications like editors that need precise
             * control over when processes invoked via the commandline will exit and
             * what their exit status will be.
             */
            run(argv?: string[] | null): number;
            /**
             * Sends a notification on behalf of `application `to the desktop shell.
             * There is no guarantee that the notification is displayed immediately,
             * or even at all.
             *
             * Notifications may persist after the application exits. It will be
             * D-Bus-activated when the notification or one of its actions is
             * activated.
             *
             * Modifying `notification `after this call has no effect. However, the
             * object can be reused for a later call to this function.
             *
             * `id `may be any string that uniquely identifies the event for the
             * application. It does not need to be in any special format. For
             * example, "new-message" might be appropriate for a notification about
             * new messages.
             *
             * If a previous notification was sent with the same id, it will be
             * replaced with `notification `and shown again as if it was a new
             * notification. This works even for notifications sent from a previous
             * execution of the application, as long as `id `is the same string.
             *
             * `id `may be %NULL, but it is impossible to replace or withdraw
             * notifications without an id.
             *
             * If `notification `is no longer relevant, it can be withdrawn with
             * g_application_withdraw_notification().
             */
            send_notification(id: string | null, notification: Notification): void;
            /**
             * This used to be how actions were associated with a #GApplication.
             * Now there is #GActionMap for that.
             */
            set_action_group(action_group?: ActionGroup | null): void;
            /**
             * Sets the unique identifier for `application.`
             *
             * The application id can only be modified if `application `has not yet
             * been registered.
             *
             * If non-%NULL, the application id must be valid.  See
             * g_application_id_is_valid().
             */
            set_application_id(application_id?: string | null): void;
            /**
             * Sets or unsets the default application for the process, as returned
             * by g_application_get_default().
             *
             * This function does not take its own reference on `application.`  If
             * `application `is destroyed then the default application will revert
             * back to %NULL.
             */
            set_default(): void;
            /**
             * Sets the flags for `application.`
             *
             * The flags can only be modified if `application `has not yet been
             * registered.
             *
             * See #GApplicationFlags.
             */
            set_flags(flags: ApplicationFlags): void;
            /**
             * Sets the current inactivity timeout for the application.
             *
             * This is the amount of time (in milliseconds) after the last call to
             * g_application_release() before the application stops running.
             *
             * This call has no side effects of its own.  The value set here is only
             * used for next time g_application_release() drops the use count to
             * zero.  Any timeouts currently in progress are not impacted.
             */
            set_inactivity_timeout(inactivity_timeout: number): void;
            /**
             * Adds a description to the `application `option context.
             *
             * See g_option_context_set_description() for more information.
             */
            set_option_context_description(description?: string | null): void;
            /**
             * Sets the parameter string to be used by the commandline handling of `application.`
             *
             * This function registers the argument to be passed to g_option_context_new()
             * when the internal #GOptionContext of `application `is created.
             *
             * See g_option_context_new() for more information about `parameter_string.`
             */
            set_option_context_parameter_string(parameter_string?: string | null): void;
            /**
             * Adds a summary to the `application `option context.
             *
             * See g_option_context_set_summary() for more information.
             */
            set_option_context_summary(summary?: string | null): void;
            /**
             * Sets (or unsets) the base resource path of `application.`
             *
             * The path is used to automatically load various [application
             * resources][gresource] such as menu layouts and action descriptions.
             * The various types of resources will be found at fixed names relative
             * to the given base path.
             *
             * By default, the resource base path is determined from the application
             * ID by prefixing '/' and replacing each '.' with '/'.  This is done at
             * the time that the #GApplication object is constructed.  Changes to
             * the application ID after that point will not have an impact on the
             * resource base path.
             *
             * As an example, if the application has an ID of "org.example.app" then
             * the default resource base path will be "/org/example/app".  If this
             * is a #GtkApplication (and you have not manually changed the path)
             * then Gtk will then search for the menus of the application at
             * "/org/example/app/gtk/menus.ui".
             *
             * See #GResource for more information about adding resources to your
             * application.
             *
             * You can disable automatic resource loading functionality by setting
             * the path to %NULL.
             *
             * Changing the resource base path once the application is running is
             * not recommended.  The point at which the resource path is consulted
             * for forming paths for various purposes is unspecified.  When writing
             * a sub-class of #GApplication you should either set the
             * #GApplication:resource-base-path property at construction time, or call
             * this function during the instance initialization. Alternatively, you
             * can call this function in the #GApplicationClass.startup virtual function,
             * before chaining up to the parent implementation.
             */
            set_resource_base_path(resource_path?: string | null): void;
            /**
             * Destroys a binding between `property `and the busy state of
             * `application `that was previously created with
             * g_application_bind_busy_property().
             */
            unbind_busy_property(object: GObject.Object, property: string): void;
            /**
             * Decreases the busy count of `application.`
             *
             * When the busy count reaches zero, the new state will be propagated
             * to other processes.
             *
             * This function must only be called to cancel the effect of a previous
             * call to g_application_mark_busy().
             */
            unmark_busy(): void;
            /**
             * Withdraws a notification that was sent with
             * g_application_send_notification().
             *
             * This call does nothing if a notification with `id `doesn't exist or
             * the notification was never sent.
             *
             * This function works even for notifications sent in previous
             * executions of this application, as long `id `is the same as it was for
             * the sent notification.
             *
             * Note that notifications are dismissed when the user clicks on one
             * of the buttons in a notification or triggers its default action, so
             * there is no need to explicitly withdraw the notification in that case.
             */
            withdraw_notification(id: string): void;
            /**
             * Activates the application.
             *
             * In essence, this results in the #GApplication::activate signal being
             * emitted in the primary instance.
             *
             * The application must be registered before calling this function.
             */
            vfunc_activate(): void;
            vfunc_add_platform_data(builder: GLib.VariantBuilder): void;
            vfunc_after_emit(platform_data: GLib.Variant): void;
            vfunc_before_emit(platform_data: GLib.Variant): void;
            vfunc_command_line(command_line: ApplicationCommandLine): number;
            vfunc_dbus_register(connection: DBusConnection, object_path: string): boolean;
            vfunc_dbus_unregister(connection: DBusConnection, object_path: string): void;
            vfunc_handle_local_options(options: GLib.VariantDict): number;
            /**
             * This virtual function is always invoked in the local instance. It
             * gets passed a pointer to a %NULL-terminated copy of `argv `and is
             * expected to remove arguments that it handled (shifting up remaining
             * arguments).
             *
             * The last argument to local_command_line() is a pointer to the status
             * variable which can used to set the exit status that is returned from
             * g_application_run().
             *
             * See g_application_run() for more details on #GApplication startup.
             */
            vfunc_local_command_line(_arguments: string[]): [boolean, string[], number];
            vfunc_name_lost(): boolean;
            /**
             * Opens the given files.
             *
             * In essence, this results in the #GApplication::open signal being emitted
             * in the primary instance.
             *
             * `n_files `must be greater than zero.
             *
             * `hint `is simply passed through to the ::open signal.  It is
             * intended to be used by applications that have multiple modes for
             * opening files (eg: "view" vs "edit", etc).  Unless you have a need
             * for this functionality, you should use "".
             *
             * The application must be registered before calling this function
             * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
             */
            vfunc_open(files: File[], hint: string): void;
            vfunc_quit_mainloop(): void;
            vfunc_run_mainloop(): void;
            vfunc_shutdown(): void;
            vfunc_startup(): void;
            /**
             * Returns the default #GApplication instance for this process.
             *
             * Normally there is only one #GApplication per process and it becomes
             * the default when it is created.  You can exercise more control over
             * this by using g_application_set_default().
             *
             * If there is no default application then %NULL is returned.
             */
            static get_default(): Application | null;
            /**
             * Checks if `application_id `is a valid application identifier.
             *
             * A valid ID is required for calls to g_application_new() and
             * g_application_set_application_id().
             *
             * Application identifiers follow the same format as
             * [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
             * For convenience, the restrictions on application identifiers are
             * reproduced here:
             *
             * - Application identifiers are composed of 1 or more elements separated by a
             * period (`.`) character. All elements must contain at least one character.
             *
             * - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
             * with `-` discouraged in new application identifiers. Each element must not
             * begin with a digit.
             *
             * - Application identifiers must contain at least one `.` (period) character
             * (and thus at least two elements).
             *
             * - Application identifiers must not begin with a `.` (period) character.
             *
             * - Application identifiers must not exceed 255 characters.
             *
             * Note that the hyphen (`-`) character is allowed in application identifiers,
             * but is problematic or not allowed in various specifications and APIs that
             * refer to D-Bus, such as
             * [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
             * the
             * [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
             * and the convention that an application's "main" interface and object path
             * resemble its application identifier and bus name. To avoid situations that
             * require special-case handling, it is recommended that new application
             * identifiers consistently replace hyphens with underscores.
             *
             * Like D-Bus interface names, application identifiers should start with the
             * reversed DNS domain name of the author of the interface (in lower-case), and
             * it is conventional for the rest of the application identifier to consist of
             * words run together, with initial capital letters.
             *
             * As with D-Bus interface names, if the author's DNS domain name contains
             * hyphen/minus characters they should be replaced by underscores, and if it
             * contains leading digits they should be escaped by prepending an underscore.
             * For example, if the owner of 7-zip.org used an application identifier for an
             * archiving application, it might be named `org._7_zip.Archiver`.
             */
            static id_is_valid(application_id: string): boolean;

            // Implemented Members

            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            vfunc_has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            vfunc_list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            vfunc_query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Adds an action to the `action_map.`
             *
             * If the action map already contains an action with the same name
             * as `action `then the old action is dropped from the action map.
             *
             * The action map takes its own reference on `action.`
             */
            add_action(action: Action): void;
            /**
             * A convenience function for creating multiple #GSimpleAction instances
             * and adding them to a #GActionMap.
             *
             * Each action is constructed as per one #GActionEntry.
             *
             * |[&lt;!-- language="C" --&gt;
             * static void
             * activate_quit (GSimpleAction *simple,
             * GVariant      *parameter,
             * gpointer       user_data)
             * {
             * exit (0);
             * }
             *
             * static void
             * activate_print_string (GSimpleAction *simple,
             * GVariant      *parameter,
             * gpointer       user_data)
             * {
             * g_print ("%s\n", g_variant_get_string (parameter, NULL));
             * }
             *
             * static GActionGroup *
             * create_action_group (void)
             * {
             * const GActionEntry entries[] = {
             * { "quit",         activate_quit              },
             * { "print-string", activate_print_string, "s" }
             * };
             * GSimpleActionGroup *group;
             *
             * group = g_simple_action_group_new ();
             * g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
             *
             * return G_ACTION_GROUP (group);
             * }
             * ]|
             */
            add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
            /**
             * Looks up the action with the name `action_name `in `action_map.`
             *
             * If no such action exists, returns %NULL.
             */
            lookup_action(action_name: string): Action | null;
            /**
             * Removes the named action from the action map.
             *
             * If no action of this name is in the map then nothing happens.
             */
            remove_action(action_name: string): void;
            /**
             * Adds an action to the `action_map.`
             *
             * If the action map already contains an action with the same name
             * as `action `then the old action is dropped from the action map.
             *
             * The action map takes its own reference on `action.`
             */
            vfunc_add_action(action: Action): void;
            /**
             * Looks up the action with the name `action_name `in `action_map.`
             *
             * If no such action exists, returns %NULL.
             */
            vfunc_lookup_action(action_name: string): Action | null;
            /**
             * Removes the named action from the action map.
             *
             * If no action of this name is in the map then nothing happens.
             */
            vfunc_remove_action(action_name: string): void;
        }
        export module ApplicationCommandLine {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                arguments: GLib.Variant;
                is_remote: boolean;
                isRemote: boolean;
                options: GLib.Variant;
                platform_data: GLib.Variant;
                platformData: GLib.Variant;
            }
        }
        export class ApplicationCommandLine extends GObject.Object {
            static $gtype: GObject.GType<ApplicationCommandLine>;

            constructor(properties?: Partial<ApplicationCommandLine.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ApplicationCommandLine.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set arguments(val: GLib.Variant);
            get is_remote(): boolean;
            get isRemote(): boolean;
            set options(val: GLib.Variant);
            set platform_data(val: GLib.Variant);
            set platformData(val: GLib.Variant);

            // Members

            /**
             * Creates a #GFile corresponding to a filename that was given as part
             * of the invocation of `cmdline.`
             *
             * This differs from g_file_new_for_commandline_arg() in that it
             * resolves relative pathnames using the current working directory of
             * the invoking process rather than the local process.
             */
            create_file_for_arg(arg: string): File;
            /**
             * Gets the list of arguments that was passed on the command line.
             *
             * The strings in the array may contain non-UTF-8 data on UNIX (such as
             * filenames or arguments given in the system locale) but are always in
             * UTF-8 on Windows.
             *
             * If you wish to use the return value with #GOptionContext, you must
             * use g_option_context_parse_strv().
             *
             * The return value is %NULL-terminated and should be freed using
             * g_strfreev().
             */
            get_arguments(): string[];
            /**
             * Gets the working directory of the command line invocation.
             * The string may contain non-utf8 data.
             *
             * It is possible that the remote application did not send a working
             * directory, so this may be %NULL.
             *
             * The return value should not be modified or freed and is valid for as
             * long as `cmdline `exists.
             */
            get_cwd(): string | null;
            /**
             * Gets the contents of the 'environ' variable of the command line
             * invocation, as would be returned by g_get_environ(), ie as a
             * %NULL-terminated list of strings in the form 'NAME=VALUE'.
             * The strings may contain non-utf8 data.
             *
             * The remote application usually does not send an environment.  Use
             * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
             * set it is possible that the environment is still not available (due
             * to invocation messages from other applications).
             *
             * The return value should not be modified or freed and is valid for as
             * long as `cmdline `exists.
             *
             * See g_application_command_line_getenv() if you are only interested
             * in the value of a single environment variable.
             */
            get_environ(): string[];
            /**
             * Gets the exit status of `cmdline.`  See
             * g_application_command_line_set_exit_status() for more information.
             */
            get_exit_status(): number;
            /**
             * Determines if `cmdline `represents a remote invocation.
             */
            get_is_remote(): boolean;
            /**
             * Gets the options that were passed to g_application_command_line().
             *
             * If you did not override local_command_line() then these are the same
             * options that were parsed according to the #GOptionEntrys added to the
             * application with g_application_add_main_option_entries() and possibly
             * modified from your GApplication::handle-local-options handler.
             *
             * If no options were sent then an empty dictionary is returned so that
             * you don't need to check for %NULL.
             *
             * The data has been passed via an untrusted external process, so the types of
             * all values must be checked before being used.
             */
            get_options_dict(): GLib.VariantDict;
            /**
             * Gets the platform data associated with the invocation of `cmdline.`
             *
             * This is a #GVariant dictionary containing information about the
             * context in which the invocation occurred.  It typically contains
             * information like the current working directory and the startup
             * notification ID.
             *
             * It comes from an untrusted external process and hence the types of all
             * values must be validated before being used.
             *
             * For local invocation, it will be %NULL.
             */
            get_platform_data(): GLib.Variant | null;
            /**
             * Gets the stdin of the invoking process.
             *
             * The #GInputStream can be used to read data passed to the standard
             * input of the invoking process.
             * This doesn't work on all platforms.  Presently, it is only available
             * on UNIX when using a D-Bus daemon capable of passing file descriptors.
             * If stdin is not available then %NULL will be returned.  In the
             * future, support may be expanded to other platforms.
             *
             * You must only call this function once per commandline invocation.
             */
            get_stdin(): InputStream | null;
            /**
             * Gets the value of a particular environment variable of the command
             * line invocation, as would be returned by g_getenv().  The strings may
             * contain non-utf8 data.
             *
             * The remote application usually does not send an environment.  Use
             * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
             * set it is possible that the environment is still not available (due
             * to invocation messages from other applications).
             *
             * The return value should not be modified or freed and is valid for as
             * long as `cmdline `exists.
             */
            getenv(name: string): string | null;
            /**
             * Sets the exit status that will be used when the invoking process
             * exits.
             *
             * The return value of the #GApplication::command-line signal is
             * passed to this function when the handler returns.  This is the usual
             * way of setting the exit status.
             *
             * In the event that you want the remote invocation to continue running
             * and want to decide on the exit status in the future, you can use this
             * call.  For the case of a remote invocation, the remote process will
             * typically exit when the last reference is dropped on `cmdline.`  The
             * exit status of the remote process will be equal to the last value
             * that was set with this function.
             *
             * In the case that the commandline invocation is local, the situation
             * is slightly more complicated.  If the commandline invocation results
             * in the mainloop running (ie: because the use-count of the application
             * increased to a non-zero value) then the application is considered to
             * have been 'successful' in a certain sense, and the exit status is
             * always zero.  If the application use count is zero, though, the exit
             * status of the local #GApplicationCommandLine is used.
             */
            set_exit_status(exit_status: number): void;
            /**
             * Gets the stdin of the invoking process.
             *
             * The #GInputStream can be used to read data passed to the standard
             * input of the invoking process.
             * This doesn't work on all platforms.  Presently, it is only available
             * on UNIX when using a D-Bus daemon capable of passing file descriptors.
             * If stdin is not available then %NULL will be returned.  In the
             * future, support may be expanded to other platforms.
             *
             * You must only call this function once per commandline invocation.
             */
            vfunc_get_stdin(): InputStream | null;
            vfunc_print_literal(message: string): void;
            vfunc_printerr_literal(message: string): void;
        }
        export module BufferedInputStream {
            export interface ConstructorProperties extends FilterInputStream.ConstructorProperties {
                [key: string]: any;
                buffer_size: number;
                bufferSize: number;
            }
        }
        export class BufferedInputStream extends FilterInputStream implements Seekable {
            static $gtype: GObject.GType<BufferedInputStream>;

            constructor(properties?: Partial<BufferedInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<BufferedInputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get buffer_size(): number;
            set buffer_size(val: number);
            get bufferSize(): number;
            set bufferSize(val: number);

            // Constructors

            static ["new"](base_stream: InputStream): BufferedInputStream;
            static new_sized(base_stream: InputStream, size: number): BufferedInputStream;

            // Members

            /**
             * Tries to read `count `bytes from the stream into the buffer.
             * Will block during this read.
             *
             * If `count `is zero, returns zero and does nothing. A value of count
             * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * If `count `is -1 then the attempted read size is equal to the number of
             * bytes that are required to fill the buffer.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error -1 is returned and `error `is set accordingly.
             *
             * For the asynchronous, non-blocking, version of this function, see
             * g_buffered_input_stream_fill_async().
             */
            fill(count: number, cancellable?: Cancellable | null): number;
            /**
             * Reads data into stream's buffer asynchronously, up to `count `size.
             * `io_priority `can be used to prioritize reads. For the synchronous
             * version of this function, see g_buffered_input_stream_fill().
             *
             * If `count `is -1 then the attempted read size is equal to the number
             * of bytes that are required to fill the buffer.
             */
            fill_async(count: number, io_priority: number, cancellable?: Cancellable | null): Promise<number>;
            /**
             * Reads data into stream's buffer asynchronously, up to `count `size.
             * `io_priority `can be used to prioritize reads. For the synchronous
             * version of this function, see g_buffered_input_stream_fill().
             *
             * If `count `is -1 then the attempted read size is equal to the number
             * of bytes that are required to fill the buffer.
             */
            fill_async(
                count: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Reads data into stream's buffer asynchronously, up to `count `size.
             * `io_priority `can be used to prioritize reads. For the synchronous
             * version of this function, see g_buffered_input_stream_fill().
             *
             * If `count `is -1 then the attempted read size is equal to the number
             * of bytes that are required to fill the buffer.
             */
            fill_async(
                count: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes an asynchronous read.
             */
            fill_finish(result: AsyncResult): number;
            /**
             * Gets the size of the available data within the stream.
             */
            get_available(): number;
            /**
             * Gets the size of the input buffer.
             */
            get_buffer_size(): number;
            /**
             * Peeks in the buffer, copying data of size `count `into buffer,
             * offset `offset `bytes.
             */
            peek(buffer: Uint8Array | string, offset: number): number;
            /**
             * Returns the buffer with the currently available bytes. The returned
             * buffer must not be modified and will become invalid when reading from
             * the stream or filling the buffer.
             */
            peek_buffer(): Uint8Array;
            /**
             * Tries to read a single byte from the stream or the buffer. Will block
             * during this read.
             *
             * On success, the byte read from the stream is returned. On end of stream
             * -1 is returned but it's not an exceptional error and `error `is not set.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            read_byte(cancellable?: Cancellable | null): number;
            /**
             * Sets the size of the internal buffer of `stream `to size, or to the
             * size of the contents of the buffer. The buffer can never be resized
             * smaller than its current contents.
             */
            set_buffer_size(size: number): void;
            /**
             * Tries to read `count `bytes from the stream into the buffer.
             * Will block during this read.
             *
             * If `count `is zero, returns zero and does nothing. A value of count
             * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * If `count `is -1 then the attempted read size is equal to the number of
             * bytes that are required to fill the buffer.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error -1 is returned and `error `is set accordingly.
             *
             * For the asynchronous, non-blocking, version of this function, see
             * g_buffered_input_stream_fill_async().
             */
            vfunc_fill(count: number, cancellable?: Cancellable | null): number;
            /**
             * Reads data into stream's buffer asynchronously, up to `count `size.
             * `io_priority `can be used to prioritize reads. For the synchronous
             * version of this function, see g_buffered_input_stream_fill().
             *
             * If `count `is -1 then the attempted read size is equal to the number
             * of bytes that are required to fill the buffer.
             */
            vfunc_fill_async(count: number, io_priority: number, cancellable?: Cancellable | null): Promise<number>;
            /**
             * Reads data into stream's buffer asynchronously, up to `count `size.
             * `io_priority `can be used to prioritize reads. For the synchronous
             * version of this function, see g_buffered_input_stream_fill().
             *
             * If `count `is -1 then the attempted read size is equal to the number
             * of bytes that are required to fill the buffer.
             */
            vfunc_fill_async(
                count: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Reads data into stream's buffer asynchronously, up to `count `size.
             * `io_priority `can be used to prioritize reads. For the synchronous
             * version of this function, see g_buffered_input_stream_fill().
             *
             * If `count `is -1 then the attempted read size is equal to the number
             * of bytes that are required to fill the buffer.
             */
            vfunc_fill_async(
                count: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes an asynchronous read.
             */
            vfunc_fill_finish(result: AsyncResult): number;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module BufferedOutputStream {
            export interface ConstructorProperties extends FilterOutputStream.ConstructorProperties {
                [key: string]: any;
                auto_grow: boolean;
                autoGrow: boolean;
                buffer_size: number;
                bufferSize: number;
            }
        }
        export class BufferedOutputStream extends FilterOutputStream implements Seekable {
            static $gtype: GObject.GType<BufferedOutputStream>;

            constructor(properties?: Partial<BufferedOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<BufferedOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get auto_grow(): boolean;
            set auto_grow(val: boolean);
            get autoGrow(): boolean;
            set autoGrow(val: boolean);
            get buffer_size(): number;
            set buffer_size(val: number);
            get bufferSize(): number;
            set bufferSize(val: number);

            // Constructors

            static ["new"](base_stream: OutputStream): BufferedOutputStream;
            static new_sized(base_stream: OutputStream, size: number): BufferedOutputStream;

            // Members

            /**
             * Checks if the buffer automatically grows as data is added.
             */
            get_auto_grow(): boolean;
            /**
             * Gets the size of the buffer in the `stream.`
             */
            get_buffer_size(): number;
            /**
             * Sets whether or not the stream's buffer should automatically grow.
             * If `auto_grow `is true, then each write will just make the buffer
             * larger, and you must manually flush the buffer to actually write out
             * the data to the underlying stream.
             */
            set_auto_grow(auto_grow: boolean): void;
            /**
             * Sets the size of the internal buffer to `size.`
             */
            set_buffer_size(size: number): void;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module BytesIcon {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                bytes: GLib.Bytes;
            }
        }
        export class BytesIcon extends GObject.Object implements Icon, LoadableIcon {
            static $gtype: GObject.GType<BytesIcon>;

            constructor(properties?: Partial<BytesIcon.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<BytesIcon.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get bytes(): GLib.Bytes;

            // Constructors

            static ["new"](bytes: GLib.Bytes | Uint8Array): BytesIcon;

            // Members

            /**
             * Gets the #GBytes associated with the given `icon.`
             */
            get_bytes(): GLib.Bytes;

            // Implemented Members

            /**
             * Checks if two icons are equal.
             */
            equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            serialize(): GLib.Variant | null;
            /**
             * Generates a textual representation of `icon `that can be used for
             * serialization such as when passing `icon `to a different process or
             * saving it to persistent storage. Use g_icon_new_for_string() to
             * get `icon `back from the returned string.
             *
             * The encoding of the returned string is proprietary to #GIcon except
             * in the following two cases
             *
             * - If `icon `is a #GFileIcon, the returned string is a native path
             * (such as `/path/to/my icon.png`) without escaping
             * if the #GFile for `icon `is a native file.  If the file is not
             * native, the returned string is the result of g_file_get_uri()
             * (such as `sftp://path/to/my%20icon.png`).
             *
             * - If `icon `is a #GThemedIcon with exactly one name and no fallbacks,
             * the encoding is simply the name (such as `network-server`).
             */
            to_string(): string | null;
            /**
             * Checks if two icons are equal.
             */
            vfunc_equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            vfunc_hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            vfunc_serialize(): GLib.Variant | null;
            /**
             * Serializes the `icon `into string tokens.
             * This is can be invoked when g_icon_new_for_string() is called.
             */
            vfunc_to_tokens(): [boolean, string[], number];
            /**
             * Loads a loadable icon. For the asynchronous version of this function,
             * see g_loadable_icon_load_async().
             */
            load(size: number, cancellable?: Cancellable | null): [InputStream, string];
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(size: number, cancellable?: Cancellable | null): Promise<[InputStream, string]>;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(size: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(
                size: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[InputStream, string]> | void;
            /**
             * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
             */
            load_finish(res: AsyncResult): [InputStream, string];
            /**
             * Loads a loadable icon. For the asynchronous version of this function,
             * see g_loadable_icon_load_async().
             */
            vfunc_load(size: number, cancellable?: Cancellable | null): [InputStream, string];
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(size: number, cancellable?: Cancellable | null): Promise<[InputStream, string]>;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(
                size: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(
                size: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[InputStream, string]> | void;
            /**
             * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
             */
            vfunc_load_finish(res: AsyncResult): [InputStream, string];
        }
        export module Cancellable {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class Cancellable extends GObject.Object {
            static $gtype: GObject.GType<Cancellable>;

            constructor(properties?: Partial<Cancellable.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Cancellable.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect_after(signal: "cancelled", callback: (_source: this) => void): number;
            emit(signal: "cancelled"): void;

            // Constructors

            static ["new"](): Cancellable;

            // Members

            /**
             * Will set `cancellable `to cancelled, and will emit the
             * #GCancellable::cancelled signal. (However, see the warning about
             * race conditions in the documentation for that signal if you are
             * planning to connect to it.)
             *
             * This function is thread-safe. In other words, you can safely call
             * it from a thread other than the one running the operation that was
             * passed the `cancellable.`
             *
             * If `cancellable `is %NULL, this function returns immediately for convenience.
             *
             * The convention within GIO is that cancelling an asynchronous
             * operation causes it to complete asynchronously. That is, if you
             * cancel the operation from the same thread in which it is running,
             * then the operation's #GAsyncReadyCallback will not be invoked until
             * the application returns to the main loop.
             */
            cancel(): void;
            /**
             * Convenience function to connect to the #GCancellable::cancelled
             * signal. Also handles the race condition that may happen
             * if the cancellable is cancelled right before connecting.
             *
             * `callback `is called at most once, either directly at the
             * time of the connect if `cancellable `is already cancelled,
             * or when `cancellable `is cancelled in some thread.
             *
             * `data_destroy_func `will be called when the handler is
             * disconnected, or immediately if the cancellable is already
             * cancelled.
             *
             * See #GCancellable::cancelled for details on how to use this.
             *
             * Since GLib 2.40, the lock protecting `cancellable `is not held when
             * `callback `is invoked.  This lifts a restriction in place for
             * earlier GLib versions which now makes it easier to write cleanup
             * code that unconditionally invokes e.g. g_cancellable_cancel().
             */
            connect(callback: GObject.Callback, data_destroy_func?: GLib.DestroyNotify | null): number;
            connect(...args: never[]): any;
            /**
             * Disconnects a handler from a cancellable instance similar to
             * g_signal_handler_disconnect().  Additionally, in the event that a
             * signal handler is currently running, this call will block until the
             * handler has finished.  Calling this function from a
             * #GCancellable::cancelled signal handler will therefore result in a
             * deadlock.
             *
             * This avoids a race condition where a thread cancels at the
             * same time as the cancellable operation is finished and the
             * signal handler is removed. See #GCancellable::cancelled for
             * details on how to use this.
             *
             * If `cancellable `is %NULL or `handler_id `is `0` this function does
             * nothing.
             */
            disconnect(handler_id: number): void;
            /**
             * Gets the file descriptor for a cancellable job. This can be used to
             * implement cancellable operations on Unix systems. The returned fd will
             * turn readable when `cancellable `is cancelled.
             *
             * You are not supposed to read from the fd yourself, just check for
             * readable status. Reading to unset the readable status is done
             * with g_cancellable_reset().
             *
             * After a successful return from this function, you should use
             * g_cancellable_release_fd() to free up resources allocated for
             * the returned file descriptor.
             *
             * See also g_cancellable_make_pollfd().
             */
            get_fd(): number;
            /**
             * Checks if a cancellable job has been cancelled.
             */
            is_cancelled(): boolean;
            /**
             * Creates a #GPollFD corresponding to cancellable; this can be passed
             * to g_poll() and used to poll for cancellation. This is useful both
             * for unix systems without a native poll and for portability to
             * windows.
             *
             * When this function returns %TRUE, you should use
             * g_cancellable_release_fd() to free up resources allocated for the
             * `pollfd.` After a %FALSE return, do not call g_cancellable_release_fd().
             *
             * If this function returns %FALSE, either no `cancellable `was given or
             * resource limits prevent this function from allocating the necessary
             * structures for polling. (On Linux, you will likely have reached
             * the maximum number of file descriptors.) The suggested way to handle
             * these cases is to ignore the `cancellable.`
             *
             * You are not supposed to read from the fd yourself, just check for
             * readable status. Reading to unset the readable status is done
             * with g_cancellable_reset().
             */
            make_pollfd(pollfd: GLib.PollFD): boolean;
            /**
             * Pops `cancellable `off the cancellable stack (verifying that cancellable
             * is on the top of the stack).
             */
            pop_current(): void;
            /**
             * Pushes `cancellable `onto the cancellable stack. The current
             * cancellable can then be received using g_cancellable_get_current().
             *
             * This is useful when implementing cancellable operations in
             * code that does not allow you to pass down the cancellable object.
             *
             * This is typically called automatically by e.g. #GFile operations,
             * so you rarely have to call this yourself.
             */
            push_current(): void;
            /**
             * Releases a resources previously allocated by g_cancellable_get_fd()
             * or g_cancellable_make_pollfd().
             *
             * For compatibility reasons with older releases, calling this function
             * is not strictly required, the resources will be automatically freed
             * when the `cancellable `is finalized. However, the `cancellable `will
             * block scarce file descriptors until it is finalized if this function
             * is not called. This can cause the application to run out of file
             * descriptors when many #GCancellables are used at the same time.
             */
            release_fd(): void;
            /**
             * Resets `cancellable `to its uncancelled state.
             *
             * If cancellable is currently in use by any cancellable operation
             * then the behavior of this function is undefined.
             *
             * Note that it is generally not a good idea to reuse an existing
             * cancellable for more operations after it has been cancelled once,
             * as this function might tempt you to do. The recommended practice
             * is to drop the reference to a cancellable after cancelling it,
             * and let it die with the outstanding async operations. You should
             * create a fresh cancellable for further async operations.
             */
            reset(): void;
            /**
             * If the `cancellable `is cancelled, sets the error to notify
             * that the operation was cancelled.
             */
            set_error_if_cancelled(): boolean;
            /**
             * Creates a source that triggers if `cancellable `is cancelled and
             * calls its callback of type #GCancellableSourceFunc. This is
             * primarily useful for attaching to another (non-cancellable) source
             * with g_source_add_child_source() to add cancellability to it.
             *
             * For convenience, you can call this with a %NULL #GCancellable,
             * in which case the source will never trigger.
             *
             * The new #GSource will hold a reference to the #GCancellable.
             */
            source_new(): GLib.Source;
            vfunc_cancelled(): void;
            /**
             * Gets the top cancellable from the stack.
             */
            static get_current(): Cancellable | null;
        }
        export module CharsetConverter {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                from_charset: string;
                fromCharset: string;
                to_charset: string;
                toCharset: string;
                use_fallback: boolean;
                useFallback: boolean;
            }
        }
        export class CharsetConverter extends GObject.Object implements Converter, Initable {
            static $gtype: GObject.GType<CharsetConverter>;

            constructor(properties?: Partial<CharsetConverter.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<CharsetConverter.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get from_charset(): string;
            get fromCharset(): string;
            get to_charset(): string;
            get toCharset(): string;
            get use_fallback(): boolean;
            set use_fallback(val: boolean);
            get useFallback(): boolean;
            set useFallback(val: boolean);

            // Constructors

            static ["new"](to_charset: string, from_charset: string): CharsetConverter;

            // Members

            /**
             * Gets the number of fallbacks that `converter `has applied so far.
             */
            get_num_fallbacks(): number;
            /**
             * Gets the #GCharsetConverter:use-fallback property.
             */
            get_use_fallback(): boolean;
            /**
             * Sets the #GCharsetConverter:use-fallback property.
             */
            set_use_fallback(use_fallback: boolean): void;

            // Implemented Members

            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            convert(
                inbuf: Uint8Array | string,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            reset(): void;
            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            vfunc_convert(
                inbuf: Uint8Array | null,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            vfunc_reset(): void;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module ConverterInputStream {
            export interface ConstructorProperties extends FilterInputStream.ConstructorProperties {
                [key: string]: any;
                converter: Converter;
            }
        }
        export class ConverterInputStream extends FilterInputStream implements PollableInputStream {
            static $gtype: GObject.GType<ConverterInputStream>;

            constructor(properties?: Partial<ConverterInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ConverterInputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get converter(): Converter;

            // Constructors

            static ["new"](base_stream: InputStream, converter: Converter): ConverterInputStream;

            // Members

            /**
             * Gets the #GConverter that is used by `converter_stream.`
             */
            get_converter(): Converter;

            // Implemented Members

            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            vfunc_read_nonblocking(): [number, Uint8Array | null];
        }
        export module ConverterOutputStream {
            export interface ConstructorProperties extends FilterOutputStream.ConstructorProperties {
                [key: string]: any;
                converter: Converter;
            }
        }
        export class ConverterOutputStream extends FilterOutputStream implements PollableOutputStream {
            static $gtype: GObject.GType<ConverterOutputStream>;

            constructor(properties?: Partial<ConverterOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ConverterOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get converter(): Converter;

            // Constructors

            static ["new"](base_stream: OutputStream, converter: Converter): ConverterOutputStream;

            // Members

            /**
             * Gets the #GConverter that is used by `converter_stream.`
             */
            get_converter(): Converter;

            // Implemented Members

            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
        }
        export module Credentials {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class Credentials extends GObject.Object {
            static $gtype: GObject.GType<Credentials>;

            constructor(properties?: Partial<Credentials.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Credentials.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](): Credentials;

            // Members

            /**
             * Tries to get the UNIX process identifier from `credentials.` This
             * method is only available on UNIX platforms.
             *
             * This operation can fail if #GCredentials is not supported on the
             * OS or if the native credentials type does not contain information
             * about the UNIX process ID.
             */
            get_unix_pid(): number;
            /**
             * Tries to get the UNIX user identifier from `credentials.` This
             * method is only available on UNIX platforms.
             *
             * This operation can fail if #GCredentials is not supported on the
             * OS or if the native credentials type does not contain information
             * about the UNIX user.
             */
            get_unix_user(): number;
            /**
             * Checks if `credentials `and `other_credentials `is the same user.
             *
             * This operation can fail if #GCredentials is not supported on the
             * the OS.
             */
            is_same_user(other_credentials: Credentials): boolean;
            /**
             * Copies the native credentials of type `native_type `from native
             * into `credentials.`
             *
             * It is a programming error (which will cause a warning to be
             * logged) to use this method if there is no #GCredentials support for
             * the OS or if `native_type `isn't supported by the OS.
             */
            set_native(native_type: CredentialsType, _native: any): void;
            /**
             * Tries to set the UNIX user identifier on `credentials.` This method
             * is only available on UNIX platforms.
             *
             * This operation can fail if #GCredentials is not supported on the
             * OS or if the native credentials type does not contain information
             * about the UNIX user. It can also fail if the OS does not allow the
             * use of "spoofed" credentials.
             */
            set_unix_user(uid: number): boolean;
            /**
             * Creates a human-readable textual representation of credentials
             * that can be used in logging and debug messages. The format of the
             * returned string may change in future GLib release.
             */
            to_string(): string;
        }
        export module DBusActionGroup {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class DBusActionGroup extends GObject.Object implements ActionGroup, RemoteActionGroup {
            static $gtype: GObject.GType<DBusActionGroup>;

            constructor(properties?: Partial<DBusActionGroup.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusActionGroup.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Obtains a #GDBusActionGroup for the action group which is exported at
             * the given `bus_name `and `object_path.`
             *
             * The thread default main context is taken at the time of this call.
             * All signals on the menu model (and any linked models) are reported
             * with respect to this context.  All calls on the returned menu model
             * (and linked models) must also originate from this same context, with
             * the thread default main context unchanged.
             *
             * This call is non-blocking.  The returned action group may or may not
             * already be filled in.  The correct thing to do is connect the signals
             * for the action group to monitor for changes and then to call
             * g_action_group_list_actions() to get the initial list.
             */
            static get(connection: DBusConnection, bus_name: string | null, object_path: string): DBusActionGroup;

            // Implemented Members

            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            vfunc_has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            vfunc_list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            vfunc_query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Activates the remote action.
             *
             * This is the same as g_action_group_activate_action() except that it
             * allows for provision of "platform data" to be sent along with the
             * activation request.  This typically contains details such as the user
             * interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            activate_action_full(
                action_name: string,
                parameter: GLib.Variant | null,
                platform_data: GLib.Variant
            ): void;
            /**
             * Changes the state of a remote action.
             *
             * This is the same as g_action_group_change_action_state() except that
             * it allows for provision of "platform data" to be sent along with the
             * state change request.  This typically contains details such as the
             * user interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
            /**
             * Activates the remote action.
             *
             * This is the same as g_action_group_activate_action() except that it
             * allows for provision of "platform data" to be sent along with the
             * activation request.  This typically contains details such as the user
             * interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            vfunc_activate_action_full(
                action_name: string,
                parameter: GLib.Variant | null,
                platform_data: GLib.Variant
            ): void;
            /**
             * Changes the state of a remote action.
             *
             * This is the same as g_action_group_change_action_state() except that
             * it allows for provision of "platform data" to be sent along with the
             * state change request.  This typically contains details such as the
             * user interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            vfunc_change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
        }
        export module DBusAuthObserver {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class DBusAuthObserver extends GObject.Object {
            static $gtype: GObject.GType<DBusAuthObserver>;

            constructor(properties?: Partial<DBusAuthObserver.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusAuthObserver.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "allow-mechanism", callback: (_source: this, mechanism: string) => boolean): number;
            connect_after(signal: "allow-mechanism", callback: (_source: this, mechanism: string) => boolean): number;
            emit(signal: "allow-mechanism", mechanism: string): void;
            connect(
                signal: "authorize-authenticated-peer",
                callback: (_source: this, stream: IOStream, credentials: Credentials | null) => boolean
            ): number;
            connect_after(
                signal: "authorize-authenticated-peer",
                callback: (_source: this, stream: IOStream, credentials: Credentials | null) => boolean
            ): number;
            emit(signal: "authorize-authenticated-peer", stream: IOStream, credentials?: Credentials | null): void;

            // Constructors

            static ["new"](): DBusAuthObserver;

            // Members

            /**
             * Emits the #GDBusAuthObserver::allow-mechanism signal on `observer.`
             */
            allow_mechanism(mechanism: string): boolean;
            /**
             * Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on `observer.`
             */
            authorize_authenticated_peer(stream: IOStream, credentials?: Credentials | null): boolean;
        }
        export module DBusConnection {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                address: string;
                authentication_observer: DBusAuthObserver;
                authenticationObserver: DBusAuthObserver;
                capabilities: DBusCapabilityFlags;
                closed: boolean;
                exit_on_close: boolean;
                exitOnClose: boolean;
                flags: DBusConnectionFlags;
                guid: string;
                stream: IOStream;
                unique_name: string;
                uniqueName: string;
            }
        }
        export class DBusConnection extends GObject.Object implements AsyncInitable<DBusConnection>, Initable {
            static $gtype: GObject.GType<DBusConnection>;

            constructor(properties?: Partial<DBusConnection.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusConnection.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set address(val: string);
            set authentication_observer(val: DBusAuthObserver);
            set authenticationObserver(val: DBusAuthObserver);
            get capabilities(): DBusCapabilityFlags;
            get closed(): boolean;
            get exit_on_close(): boolean;
            set exit_on_close(val: boolean);
            get exitOnClose(): boolean;
            set exitOnClose(val: boolean);
            get flags(): DBusConnectionFlags;
            get guid(): string;
            get stream(): IOStream;
            get unique_name(): string;
            get uniqueName(): string;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "closed",
                callback: (_source: this, remote_peer_vanished: boolean, error: GLib.Error | null) => void
            ): number;
            connect_after(
                signal: "closed",
                callback: (_source: this, remote_peer_vanished: boolean, error: GLib.Error | null) => void
            ): number;
            emit(signal: "closed", remote_peer_vanished: boolean, error?: GLib.Error | null): void;

            // Constructors

            static new_finish(res: AsyncResult): DBusConnection;
            // Conflicted with Gio.AsyncInitable.new_finish
            static new_finish(...args: never[]): any;
            static new_for_address_finish(res: AsyncResult): DBusConnection;
            static new_for_address_sync(
                address: string,
                flags: DBusConnectionFlags,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null
            ): DBusConnection;
            static new_sync(
                stream: IOStream,
                guid: string | null,
                flags: DBusConnectionFlags,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null
            ): DBusConnection;

            // Members

            /**
             * Adds a message filter. Filters are handlers that are run on all
             * incoming and outgoing messages, prior to standard dispatch. Filters
             * are run in the order that they were added.  The same handler can be
             * added as a filter more than once, in which case it will be run more
             * than once.  Filters added during a filter callback won't be run on
             * the message being processed. Filter functions are allowed to modify
             * and even drop messages.
             *
             * Note that filters are run in a dedicated message handling thread so
             * they can't block and, generally, can't do anything but signal a
             * worker thread. Also note that filters are rarely needed - use API
             * such as g_dbus_connection_send_message_with_reply(),
             * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
             *
             * If a filter consumes an incoming message the message is not
             * dispatched anywhere else - not even the standard dispatch machinery
             * (that API such as g_dbus_connection_signal_subscribe() and
             * g_dbus_connection_send_message_with_reply() relies on) will see the
             * message. Similarly, if a filter consumes an outgoing message, the
             * message will not be sent to the other peer.
             *
             * If `user_data_free_func `is non-%NULL, it will be called (in the
             * thread-default main context of the thread you are calling this
             * method from) at some point after `user_data `is no longer
             * needed. (It is not guaranteed to be called synchronously when the
             * filter is removed, and may be called after `connection `has been
             * destroyed.)
             */
            add_filter(filter_function: DBusMessageFilterFunction): number;
            /**
             * Asynchronously invokes the `method_name `method on the
             * `interface_name `D-Bus interface on the remote object at
             * `object_path `owned by `bus_name.`
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `parameters `contains a value
             * not compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If `reply_type `is non-%NULL then the reply will be checked for having this type and an
             * error will be raised if it does not match.  Said another way, if you give a reply_type
             * then any non-%NULL return value will be of this type. Unless it’s
             * %G_VARIANT_TYPE_UNIT, the `reply_type `will be a tuple containing one or more
             * values.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_connection_call (connection,
             * "org.freedesktop.StringThings",
             * "/org/freedesktop/StringThings",
             * "org.freedesktop.StringThings",
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * NULL,
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * (GAsyncReadyCallback) two_strings_done,
             * NULL);
             * ]|
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can then call
             * g_dbus_connection_call_finish() to get the result of the operation.
             * See g_dbus_connection_call_sync() for the synchronous version of this
             * function.
             *
             * If `callback `is %NULL then the D-Bus method call message will be sent with
             * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
             */
            call<T extends string = any>(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType<T> | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null
            ): Promise<GLib.Variant<T>>;
            /**
             * Asynchronously invokes the `method_name `method on the
             * `interface_name `D-Bus interface on the remote object at
             * `object_path `owned by `bus_name.`
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `parameters `contains a value
             * not compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If `reply_type `is non-%NULL then the reply will be checked for having this type and an
             * error will be raised if it does not match.  Said another way, if you give a reply_type
             * then any non-%NULL return value will be of this type. Unless it’s
             * %G_VARIANT_TYPE_UNIT, the `reply_type `will be a tuple containing one or more
             * values.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_connection_call (connection,
             * "org.freedesktop.StringThings",
             * "/org/freedesktop/StringThings",
             * "org.freedesktop.StringThings",
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * NULL,
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * (GAsyncReadyCallback) two_strings_done,
             * NULL);
             * ]|
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can then call
             * g_dbus_connection_call_finish() to get the result of the operation.
             * See g_dbus_connection_call_sync() for the synchronous version of this
             * function.
             *
             * If `callback `is %NULL then the D-Bus method call message will be sent with
             * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
             */
            call<T extends string = any>(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType<T> | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously invokes the `method_name `method on the
             * `interface_name `D-Bus interface on the remote object at
             * `object_path `owned by `bus_name.`
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `parameters `contains a value
             * not compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If `reply_type `is non-%NULL then the reply will be checked for having this type and an
             * error will be raised if it does not match.  Said another way, if you give a reply_type
             * then any non-%NULL return value will be of this type. Unless it’s
             * %G_VARIANT_TYPE_UNIT, the `reply_type `will be a tuple containing one or more
             * values.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_connection_call (connection,
             * "org.freedesktop.StringThings",
             * "/org/freedesktop/StringThings",
             * "org.freedesktop.StringThings",
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * NULL,
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * (GAsyncReadyCallback) two_strings_done,
             * NULL);
             * ]|
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can then call
             * g_dbus_connection_call_finish() to get the result of the operation.
             * See g_dbus_connection_call_sync() for the synchronous version of this
             * function.
             *
             * If `callback `is %NULL then the D-Bus method call message will be sent with
             * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
             */
            call<T extends string = any>(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType<T> | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<GLib.Variant<T>> | void;
            /**
             * Finishes an operation started with g_dbus_connection_call().
             */
            call_finish<T extends string = any>(res: AsyncResult): GLib.Variant<T>;
            /**
             * Synchronously invokes the `method_name `method on the
             * `interface_name `D-Bus interface on the remote object at
             * `object_path `owned by `bus_name.`
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the
             * operation will fail with %G_IO_ERROR_CANCELLED. If parameters
             * contains a value not compatible with the D-Bus protocol, the operation
             * fails with %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If `reply_type `is non-%NULL then the reply will be checked for having
             * this type and an error will be raised if it does not match.  Said
             * another way, if you give a `reply_type `then any non-%NULL return
             * value will be of this type.
             *
             * If the `parameters `#GVariant is floating, it is consumed.
             * This allows convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_connection_call_sync (connection,
             * "org.freedesktop.StringThings",
             * "/org/freedesktop/StringThings",
             * "org.freedesktop.StringThings",
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * NULL,
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * &amp;error);
             * ]|
             *
             * The calling thread is blocked until a reply is received. See
             * g_dbus_connection_call() for the asynchronous version of
             * this method.
             */
            call_sync(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null
            ): GLib.Variant;
            /**
             * Like g_dbus_connection_call() but also takes a #GUnixFDList object.
             *
             * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
             * values in the body of the message. For example, if a message contains
             * two file descriptors, `fd_list `would have length 2, and
             * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
             * somewhere in the body of the message (not necessarily in that order!)
             * to represent the file descriptors at indexes 0 and 1 respectively.
             *
             * When designing D-Bus APIs that are intended to be interoperable,
             * please note that non-GDBus implementations of D-Bus can usually only
             * access file descriptors if they are referenced in this way by a
             * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list?: UnixFDList | null,
                cancellable?: Cancellable | null
            ): Promise<[GLib.Variant, UnixFDList | null]>;
            /**
             * Like g_dbus_connection_call() but also takes a #GUnixFDList object.
             *
             * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
             * values in the body of the message. For example, if a message contains
             * two file descriptors, `fd_list `would have length 2, and
             * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
             * somewhere in the body of the message (not necessarily in that order!)
             * to represent the file descriptors at indexes 0 and 1 respectively.
             *
             * When designing D-Bus APIs that are intended to be interoperable,
             * please note that non-GDBus implementations of D-Bus can usually only
             * access file descriptors if they are referenced in this way by a
             * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list: UnixFDList | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Like g_dbus_connection_call() but also takes a #GUnixFDList object.
             *
             * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
             * values in the body of the message. For example, if a message contains
             * two file descriptors, `fd_list `would have length 2, and
             * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
             * somewhere in the body of the message (not necessarily in that order!)
             * to represent the file descriptors at indexes 0 and 1 respectively.
             *
             * When designing D-Bus APIs that are intended to be interoperable,
             * please note that non-GDBus implementations of D-Bus can usually only
             * access file descriptors if they are referenced in this way by a
             * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list?: UnixFDList | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[GLib.Variant, UnixFDList | null]> | void;
            /**
             * Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().
             *
             * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
             * values in the body of the message. For example,
             * if g_variant_get_handle() returns 5, that is intended to be a reference
             * to the file descriptor that can be accessed by
             * `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
             *
             * When designing D-Bus APIs that are intended to be interoperable,
             * please note that non-GDBus implementations of D-Bus can usually only
             * access file descriptors if they are referenced in this way by a
             * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
             */
            call_with_unix_fd_list_finish(res: AsyncResult): [GLib.Variant, UnixFDList | null];
            /**
             * Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.
             * See g_dbus_connection_call_with_unix_fd_list() and
             * g_dbus_connection_call_with_unix_fd_list_finish() for more details.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list_sync(
                bus_name: string | null,
                object_path: string,
                interface_name: string,
                method_name: string,
                parameters: GLib.Variant | null,
                reply_type: GLib.VariantType | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list?: UnixFDList | null,
                cancellable?: Cancellable | null
            ): [GLib.Variant, UnixFDList | null];
            /**
             * Closes `connection.` Note that this never causes the process to
             * exit (this might only happen if the other end of a shared message
             * bus connection disconnects, see #GDBusConnection:exit-on-close).
             *
             * Once the connection is closed, operations such as sending a message
             * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
             * will not automatically flush the connection so queued messages may
             * be lost. Use g_dbus_connection_flush() if you need such guarantees.
             *
             * If `connection `is already closed, this method fails with
             * %G_IO_ERROR_CLOSED.
             *
             * When `connection `has been closed, the #GDBusConnection::closed
             * signal is emitted in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread that `connection `was constructed in.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_connection_close_finish() to get the result of the
             * operation. See g_dbus_connection_close_sync() for the synchronous
             * version.
             */
            close(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Closes `connection.` Note that this never causes the process to
             * exit (this might only happen if the other end of a shared message
             * bus connection disconnects, see #GDBusConnection:exit-on-close).
             *
             * Once the connection is closed, operations such as sending a message
             * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
             * will not automatically flush the connection so queued messages may
             * be lost. Use g_dbus_connection_flush() if you need such guarantees.
             *
             * If `connection `is already closed, this method fails with
             * %G_IO_ERROR_CLOSED.
             *
             * When `connection `has been closed, the #GDBusConnection::closed
             * signal is emitted in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread that `connection `was constructed in.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_connection_close_finish() to get the result of the
             * operation. See g_dbus_connection_close_sync() for the synchronous
             * version.
             */
            close(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Closes `connection.` Note that this never causes the process to
             * exit (this might only happen if the other end of a shared message
             * bus connection disconnects, see #GDBusConnection:exit-on-close).
             *
             * Once the connection is closed, operations such as sending a message
             * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
             * will not automatically flush the connection so queued messages may
             * be lost. Use g_dbus_connection_flush() if you need such guarantees.
             *
             * If `connection `is already closed, this method fails with
             * %G_IO_ERROR_CLOSED.
             *
             * When `connection `has been closed, the #GDBusConnection::closed
             * signal is emitted in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread that `connection `was constructed in.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_connection_close_finish() to get the result of the
             * operation. See g_dbus_connection_close_sync() for the synchronous
             * version.
             */
            close(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an operation started with g_dbus_connection_close().
             */
            close_finish(res: AsyncResult): boolean;
            /**
             * Synchronously closes `connection.` The calling thread is blocked
             * until this is done. See g_dbus_connection_close() for the
             * asynchronous version of this method and more details about what it
             * does.
             */
            close_sync(cancellable?: Cancellable | null): boolean;
            /**
             * Emits a signal.
             *
             * If the parameters GVariant is floating, it is consumed.
             *
             * This can only fail if `parameters `is not compatible with the D-Bus protocol
             * (%G_IO_ERROR_INVALID_ARGUMENT), or if `connection `has been closed
             * (%G_IO_ERROR_CLOSED).
             */
            emit_signal(
                destination_bus_name: string | null,
                object_path: string,
                interface_name: string,
                signal_name: string,
                parameters?: GLib.Variant | null
            ): boolean;
            /**
             * Exports `action_group `on `connection `at `object_path.`
             *
             * The implemented D-Bus API should be considered private.  It is
             * subject to change in the future.
             *
             * A given object path can only have one action group exported on it.
             * If this constraint is violated, the export will fail and 0 will be
             * returned (with `error `set accordingly).
             *
             * You can unexport the action group using
             * g_dbus_connection_unexport_action_group() with the return value of
             * this function.
             *
             * The thread default main context is taken at the time of this call.
             * All incoming action activations and state change requests are
             * reported from this context.  Any changes on the action group that
             * cause it to emit signals must also come from this same context.
             * Since incoming action activations and state change requests are
             * rather likely to cause changes on the action group, this effectively
             * limits a given action group to being exported from only one main
             * context.
             */
            export_action_group(object_path: string, action_group: ActionGroup): number;
            /**
             * Exports `menu `on `connection `at `object_path.`
             *
             * The implemented D-Bus API should be considered private.
             * It is subject to change in the future.
             *
             * An object path can only have one menu model exported on it. If this
             * constraint is violated, the export will fail and 0 will be
             * returned (with `error `set accordingly).
             *
             * Exporting menus with sections containing more than
             * %G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
             * undefined behavior.
             *
             * You can unexport the menu model using
             * g_dbus_connection_unexport_menu_model() with the return value of
             * this function.
             */
            export_menu_model(object_path: string, menu: MenuModel): number;
            /**
             * Asynchronously flushes connection, that is, writes all queued
             * outgoing message to the transport and then flushes the transport
             * (using g_output_stream_flush_async()). This is useful in programs
             * that wants to emit a D-Bus signal and then exit immediately. Without
             * flushing the connection, there is no guaranteed that the message has
             * been sent to the networking buffers in the OS kernel.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_connection_flush_finish() to get the result of the
             * operation. See g_dbus_connection_flush_sync() for the synchronous
             * version.
             */
            flush(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously flushes connection, that is, writes all queued
             * outgoing message to the transport and then flushes the transport
             * (using g_output_stream_flush_async()). This is useful in programs
             * that wants to emit a D-Bus signal and then exit immediately. Without
             * flushing the connection, there is no guaranteed that the message has
             * been sent to the networking buffers in the OS kernel.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_connection_flush_finish() to get the result of the
             * operation. See g_dbus_connection_flush_sync() for the synchronous
             * version.
             */
            flush(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously flushes connection, that is, writes all queued
             * outgoing message to the transport and then flushes the transport
             * (using g_output_stream_flush_async()). This is useful in programs
             * that wants to emit a D-Bus signal and then exit immediately. Without
             * flushing the connection, there is no guaranteed that the message has
             * been sent to the networking buffers in the OS kernel.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_connection_flush_finish() to get the result of the
             * operation. See g_dbus_connection_flush_sync() for the synchronous
             * version.
             */
            flush(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an operation started with g_dbus_connection_flush().
             */
            flush_finish(res: AsyncResult): boolean;
            /**
             * Synchronously flushes `connection.` The calling thread is blocked
             * until this is done. See g_dbus_connection_flush() for the
             * asynchronous version of this method and more details about what it
             * does.
             */
            flush_sync(cancellable?: Cancellable | null): boolean;
            /**
             * Gets the capabilities negotiated with the remote peer
             */
            get_capabilities(): DBusCapabilityFlags;
            /**
             * Gets whether the process is terminated when `connection `is
             * closed by the remote peer. See
             * #GDBusConnection:exit-on-close for more details.
             */
            get_exit_on_close(): boolean;
            /**
             * Gets the flags used to construct this connection
             */
            get_flags(): DBusConnectionFlags;
            /**
             * The GUID of the peer performing the role of server when
             * authenticating. See #GDBusConnection:guid for more details.
             */
            get_guid(): string;
            /**
             * Retrieves the last serial number assigned to a #GDBusMessage on
             * the current thread. This includes messages sent via both low-level
             * API such as g_dbus_connection_send_message() as well as
             * high-level API such as g_dbus_connection_emit_signal(),
             * g_dbus_connection_call() or g_dbus_proxy_call().
             */
            get_last_serial(): number;
            /**
             * Gets the credentials of the authenticated peer. This will always
             * return %NULL unless `connection `acted as a server
             * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
             * when set up and the client passed credentials as part of the
             * authentication process.
             *
             * In a message bus setup, the message bus is always the server and
             * each application is a client. So this method will always return
             * %NULL for message bus clients.
             */
            get_peer_credentials(): Credentials | null;
            /**
             * Gets the underlying stream used for IO.
             *
             * While the #GDBusConnection is active, it will interact with this
             * stream from a worker thread, so it is not safe to interact with
             * the stream directly.
             */
            get_stream(): IOStream;
            /**
             * Gets the unique name of `connection `as assigned by the message
             * bus. This can also be used to figure out if `connection `is a
             * message bus connection.
             */
            get_unique_name(): string | null;
            /**
             * Gets whether `connection `is closed.
             */
            is_closed(): boolean;
            /**
             * Registers callbacks for exported objects at `object_path `with the
             * D-Bus interface that is described in `interface_info.`
             *
             * Calls to functions in `vtable `(and user_data_free_func) will happen
             * in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from.
             *
             * Note that all #GVariant values passed to functions in `vtable `will match
             * the signature given in `interface_info `- if a remote caller passes
             * incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
             * is returned to the remote caller.
             *
             * Additionally, if the remote caller attempts to invoke methods or
             * access properties not mentioned in `interface_info `the
             * `org.freedesktop.DBus.Error.UnknownMethod` resp.
             * `org.freedesktop.DBus.Error.InvalidArgs` errors
             * are returned to the caller.
             *
             * It is considered a programming error if the
             * #GDBusInterfaceGetPropertyFunc function in `vtable `returns a
             * #GVariant of incorrect type.
             *
             * If an existing callback is already registered at `object_path `and
             * interface_name, then `error `is set to %G_IO_ERROR_EXISTS.
             *
             * GDBus automatically implements the standard D-Bus interfaces
             * org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
             * and org.freedesktop.Peer, so you don't have to implement those for the
             * objects you export. You can implement org.freedesktop.DBus.Properties
             * yourself, e.g. to handle getting and setting of properties asynchronously.
             *
             * Note that the reference count on `interface_info `will be
             * incremented by 1 (unless allocated statically, e.g. if the
             * reference count is -1, see g_dbus_interface_info_ref()) for as long
             * as the object is exported. Also note that `vtable `will be copied.
             *
             * See this [server][gdbus-server] for an example of how to use this method.
             */
            register_object(
                object_path: string,
                interface_info: DBusInterfaceInfo,
                vtable?: DBusInterfaceVTable | null,
                user_data?: any | null
            ): number;
            /**
             * Version of g_dbus_connection_register_object() using closures instead of a
             * #GDBusInterfaceVTable for easier binding in other languages.
             */
            register_object(
                object_path: string,
                interface_info: DBusInterfaceInfo,
                method_call_closure?: GObject.Closure | null,
                get_property_closure?: GObject.Closure | null,
                set_property_closure?: GObject.Closure | null
            ): number;
            /**
             * Registers a whole subtree of dynamic objects.
             *
             * The `enumerate `and `introspection `functions in `vtable `are used to
             * convey, to remote callers, what nodes exist in the subtree rooted
             * by `object_path.`
             *
             * When handling remote calls into any node in the subtree, first the
             * `enumerate `function is used to check if the node exists. If the node exists
             * or the %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
             * the `introspection `function is used to check if the node supports the
             * requested method. If so, the `dispatch `function is used to determine
             * where to dispatch the call. The collected #GDBusInterfaceVTable and
             * #gpointer will be used to call into the interface vtable for processing
             * the request.
             *
             * All calls into user-provided code will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from.
             *
             * If an existing subtree is already registered at `object_path `or
             * then `error `is set to %G_IO_ERROR_EXISTS.
             *
             * Note that it is valid to register regular objects (using
             * g_dbus_connection_register_object()) in a subtree registered with
             * g_dbus_connection_register_subtree() - if so, the subtree handler
             * is tried as the last resort. One way to think about a subtree
             * handler is to consider it a fallback handler for object paths not
             * registered via g_dbus_connection_register_object() or other bindings.
             *
             * Note that `vtable `will be copied so you cannot change it after
             * registration.
             *
             * See this [server][gdbus-subtree-server] for an example of how to use
             * this method.
             */
            register_subtree(
                object_path: string,
                vtable: DBusSubtreeVTable,
                flags: DBusSubtreeFlags,
                user_data?: any | null
            ): number;
            /**
             * Removes a filter.
             *
             * Note that since filters run in a different thread, there is a race
             * condition where it is possible that the filter will be running even
             * after calling g_dbus_connection_remove_filter(), so you cannot just
             * free data that the filter might be using. Instead, you should pass
             * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
             * called when it is guaranteed that the data is no longer needed.
             */
            remove_filter(filter_id: number): void;
            /**
             * Asynchronously sends `message `to the peer represented by `connection.`
             *
             * Unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
             * will be assigned by `connection `and set on `message `via
             * g_dbus_message_set_serial(). If `out_serial `is not %NULL, then the
             * serial number used will be written to this location prior to
             * submitting the message to the underlying transport. While it has a `volatile`
             * qualifier, this is a historical artifact and the argument passed to it should
             * not be `volatile`.
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `message `is not well-formed,
             * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             *
             * Note that `message `must be unlocked, unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
             */
            send_message(message: DBusMessage, flags: DBusSendMessageFlags): [boolean, number];
            /**
             * Asynchronously sends `message `to the peer represented by `connection.`
             *
             * Unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
             * will be assigned by `connection `and set on `message `via
             * g_dbus_message_set_serial(). If `out_serial `is not %NULL, then the
             * serial number used will be written to this location prior to
             * submitting the message to the underlying transport. While it has a `volatile`
             * qualifier, this is a historical artifact and the argument passed to it should
             * not be `volatile`.
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `message `is not well-formed,
             * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * This is an asynchronous method. When the operation is finished, callback
             * will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can then call
             * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
             * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
             *
             * Note that `message `must be unlocked, unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             */
            send_message_with_reply(
                message: DBusMessage,
                flags: DBusSendMessageFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null
            ): [Promise<DBusMessage>, number];
            /**
             * Asynchronously sends `message `to the peer represented by `connection.`
             *
             * Unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
             * will be assigned by `connection `and set on `message `via
             * g_dbus_message_set_serial(). If `out_serial `is not %NULL, then the
             * serial number used will be written to this location prior to
             * submitting the message to the underlying transport. While it has a `volatile`
             * qualifier, this is a historical artifact and the argument passed to it should
             * not be `volatile`.
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `message `is not well-formed,
             * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * This is an asynchronous method. When the operation is finished, callback
             * will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can then call
             * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
             * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
             *
             * Note that `message `must be unlocked, unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             */
            send_message_with_reply(
                message: DBusMessage,
                flags: DBusSendMessageFlags,
                timeout_msec: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): number;
            /**
             * Asynchronously sends `message `to the peer represented by `connection.`
             *
             * Unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
             * will be assigned by `connection `and set on `message `via
             * g_dbus_message_set_serial(). If `out_serial `is not %NULL, then the
             * serial number used will be written to this location prior to
             * submitting the message to the underlying transport. While it has a `volatile`
             * qualifier, this is a historical artifact and the argument passed to it should
             * not be `volatile`.
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `message `is not well-formed,
             * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * This is an asynchronous method. When the operation is finished, callback
             * will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can then call
             * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
             * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
             *
             * Note that `message `must be unlocked, unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             */
            send_message_with_reply(
                message: DBusMessage,
                flags: DBusSendMessageFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): [Promise<DBusMessage> | void, number];
            /**
             * Finishes an operation started with g_dbus_connection_send_message_with_reply().
             *
             * Note that `error `is only set if a local in-process error
             * occurred. That is to say that the returned #GDBusMessage object may
             * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
             * g_dbus_message_to_gerror() to transcode this to a #GError.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             */
            send_message_with_reply_finish(res: AsyncResult): DBusMessage;
            /**
             * Synchronously sends `message `to the peer represented by connection
             * and blocks the calling thread until a reply is received or the
             * timeout is reached. See g_dbus_connection_send_message_with_reply()
             * for the asynchronous version of this method.
             *
             * Unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
             * will be assigned by `connection `and set on `message `via
             * g_dbus_message_set_serial(). If `out_serial `is not %NULL, then the
             * serial number used will be written to this location prior to
             * submitting the message to the underlying transport. While it has a `volatile`
             * qualifier, this is a historical artifact and the argument passed to it should
             * not be `volatile`.
             *
             * If `connection `is closed then the operation will fail with
             * %G_IO_ERROR_CLOSED. If `cancellable `is canceled, the operation will
             * fail with %G_IO_ERROR_CANCELLED. If `message `is not well-formed,
             * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * Note that `error `is only set if a local in-process error
             * occurred. That is to say that the returned #GDBusMessage object may
             * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
             * g_dbus_message_to_gerror() to transcode this to a #GError.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             *
             * Note that `message `must be unlocked, unless `flags `contain the
             * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
             */
            send_message_with_reply_sync(
                message: DBusMessage,
                flags: DBusSendMessageFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null
            ): [DBusMessage, number];
            /**
             * Sets whether the process should be terminated when `connection `is
             * closed by the remote peer. See #GDBusConnection:exit-on-close for
             * more details.
             *
             * Note that this function should be used with care. Most modern UNIX
             * desktops tie the notion of a user session with the session bus, and expect
             * all of a user's applications to quit when their bus connection goes away.
             * If you are setting `exit_on_close `to %FALSE for the shared session
             * bus connection, you should make sure that your application exits
             * when the user session ends.
             */
            set_exit_on_close(exit_on_close: boolean): void;
            /**
             * Subscribes to signals on `connection `and invokes `callback `whenever
             * the signal is received. Note that `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from.
             *
             * If `connection `is not a message bus connection, `sender `must be
             * %NULL.
             *
             * If `sender `is a well-known name note that `callback `is invoked with
             * the unique name for the owner of sender, not the well-known name
             * as one would expect. This is because the message bus rewrites the
             * name. As such, to avoid certain race conditions, users should be
             * tracking the name owner of the well-known name and use that when
             * processing the received signal.
             *
             * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
             * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, arg0 is
             * interpreted as part of a namespace or path.  The first argument
             * of a signal is matched against that part as specified by D-Bus.
             *
             * If `user_data_free_func `is non-%NULL, it will be called (in the
             * thread-default main context of the thread you are calling this
             * method from) at some point after `user_data `is no longer
             * needed. (It is not guaranteed to be called synchronously when the
             * signal is unsubscribed from, and may be called after connection
             * has been destroyed.)
             *
             * As `callback `is potentially invoked in a different thread from where it’s
             * emitted, it’s possible for this to happen after
             * g_dbus_connection_signal_unsubscribe() has been called in another thread.
             * Due to this, `user_data `should have a strong reference which is freed with
             * user_data_free_func, rather than pointing to data whose lifecycle is tied
             * to the signal subscription. For example, if a #GObject is used to store the
             * subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
             * to that #GObject must be passed to user_data, and g_object_unref() passed to
             * `user_data_free_func.` You are responsible for breaking the resulting
             * reference count cycle by explicitly unsubscribing from the signal when
             * dropping the last external reference to the #GObject. Alternatively, a weak
             * reference may be used.
             *
             * It is guaranteed that if you unsubscribe from a signal using
             * g_dbus_connection_signal_unsubscribe() from the same thread which made the
             * corresponding g_dbus_connection_signal_subscribe() call, `callback `will not
             * be invoked after g_dbus_connection_signal_unsubscribe() returns.
             *
             * The returned subscription identifier is an opaque value which is guaranteed
             * to never be zero.
             *
             * This function can never fail.
             */
            signal_subscribe(
                sender: string | null,
                interface_name: string | null,
                member: string | null,
                object_path: string | null,
                arg0: string | null,
                flags: DBusSignalFlags,
                callback: DBusSignalCallback,
                user_data_free_func?: GLib.DestroyNotify | null
            ): number;
            /**
             * Unsubscribes from signals.
             *
             * Note that there may still be D-Bus traffic to process (relating to this
             * signal subscription) in the current thread-default #GMainContext after this
             * function has returned. You should continue to iterate the #GMainContext
             * until the #GDestroyNotify function passed to
             * g_dbus_connection_signal_subscribe() is called, in order to avoid memory
             * leaks through callbacks queued on the #GMainContext after it’s stopped being
             * iterated.
             * Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
             * that was scheduled after unsubscription, also indicates that all resources
             * of this subscription are released.
             */
            signal_unsubscribe(subscription_id: number): void;
            /**
             * If `connection `was created with
             * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
             * starts processing messages. Does nothing on if `connection `wasn't
             * created with this flag or if the method has already been called.
             */
            start_message_processing(): void;
            /**
             * Reverses the effect of a previous call to
             * g_dbus_connection_export_action_group().
             *
             * It is an error to call this function with an ID that wasn't returned
             * from g_dbus_connection_export_action_group() or to call it with the
             * same ID more than once.
             */
            unexport_action_group(export_id: number): void;
            /**
             * Reverses the effect of a previous call to
             * g_dbus_connection_export_menu_model().
             *
             * It is an error to call this function with an ID that wasn't returned
             * from g_dbus_connection_export_menu_model() or to call it with the
             * same ID more than once.
             */
            unexport_menu_model(export_id: number): void;
            /**
             * Unregisters an object.
             */
            unregister_object(registration_id: number): boolean;
            /**
             * Unregisters a subtree.
             */
            unregister_subtree(registration_id: number): boolean;
            /**
             * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
             * with the end represented by `stream.`
             *
             * If `stream `is a #GSocketConnection, then the corresponding #GSocket
             * will be put into non-blocking mode.
             *
             * The D-Bus connection will interact with `stream `from a worker thread.
             * As a result, the caller should not interact with `stream `after this
             * method has been called, except by calling g_object_unref() on it.
             *
             * If `observer `is not %NULL it may be used to control the
             * authentication process.
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_dbus_connection_new_finish() to get the result of the
             * operation.
             *
             * This is an asynchronous failable constructor. See
             * g_dbus_connection_new_sync() for the synchronous
             * version.
             */
            static new(
                stream: IOStream,
                guid: string | null,
                flags: DBusConnectionFlags,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null
            ): Promise<DBusConnection>;
            /**
             * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
             * with the end represented by `stream.`
             *
             * If `stream `is a #GSocketConnection, then the corresponding #GSocket
             * will be put into non-blocking mode.
             *
             * The D-Bus connection will interact with `stream `from a worker thread.
             * As a result, the caller should not interact with `stream `after this
             * method has been called, except by calling g_object_unref() on it.
             *
             * If `observer `is not %NULL it may be used to control the
             * authentication process.
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_dbus_connection_new_finish() to get the result of the
             * operation.
             *
             * This is an asynchronous failable constructor. See
             * g_dbus_connection_new_sync() for the synchronous
             * version.
             */
            static new(
                stream: IOStream,
                guid: string | null,
                flags: DBusConnectionFlags,
                observer: DBusAuthObserver | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<DBusConnection> | null
            ): void;
            /**
             * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
             * with the end represented by `stream.`
             *
             * If `stream `is a #GSocketConnection, then the corresponding #GSocket
             * will be put into non-blocking mode.
             *
             * The D-Bus connection will interact with `stream `from a worker thread.
             * As a result, the caller should not interact with `stream `after this
             * method has been called, except by calling g_object_unref() on it.
             *
             * If `observer `is not %NULL it may be used to control the
             * authentication process.
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_dbus_connection_new_finish() to get the result of the
             * operation.
             *
             * This is an asynchronous failable constructor. See
             * g_dbus_connection_new_sync() for the synchronous
             * version.
             */
            static new(
                stream: IOStream,
                guid: string | null,
                flags: DBusConnectionFlags,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<DBusConnection> | null
            ): Promise<DBusConnection> | void;
            /**
             * Asynchronously connects and sets up a D-Bus client connection for
             * exchanging D-Bus messages with an endpoint specified by address
             * which must be in the
             * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
             *
             * This constructor can only be used to initiate client-side
             * connections - use g_dbus_connection_new() if you need to act as the
             * server. In particular, `flags `cannot contain the
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_dbus_connection_new_for_address_finish() to get the result of
             * the operation.
             *
             * If `observer `is not %NULL it may be used to control the
             * authentication process.
             *
             * This is an asynchronous failable constructor. See
             * g_dbus_connection_new_for_address_sync() for the synchronous
             * version.
             */
            static new_for_address(
                address: string,
                flags: DBusConnectionFlags,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null
            ): Promise<DBusConnection>;
            /**
             * Asynchronously connects and sets up a D-Bus client connection for
             * exchanging D-Bus messages with an endpoint specified by address
             * which must be in the
             * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
             *
             * This constructor can only be used to initiate client-side
             * connections - use g_dbus_connection_new() if you need to act as the
             * server. In particular, `flags `cannot contain the
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_dbus_connection_new_for_address_finish() to get the result of
             * the operation.
             *
             * If `observer `is not %NULL it may be used to control the
             * authentication process.
             *
             * This is an asynchronous failable constructor. See
             * g_dbus_connection_new_for_address_sync() for the synchronous
             * version.
             */
            static new_for_address(
                address: string,
                flags: DBusConnectionFlags,
                observer: DBusAuthObserver | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<DBusConnection> | null
            ): void;
            /**
             * Asynchronously connects and sets up a D-Bus client connection for
             * exchanging D-Bus messages with an endpoint specified by address
             * which must be in the
             * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
             *
             * This constructor can only be used to initiate client-side
             * connections - use g_dbus_connection_new() if you need to act as the
             * server. In particular, `flags `cannot contain the
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_dbus_connection_new_for_address_finish() to get the result of
             * the operation.
             *
             * If `observer `is not %NULL it may be used to control the
             * authentication process.
             *
             * This is an asynchronous failable constructor. See
             * g_dbus_connection_new_for_address_sync() for the synchronous
             * version.
             */
            static new_for_address(
                address: string,
                flags: DBusConnectionFlags,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<DBusConnection> | null
            ): Promise<DBusConnection> | void;
            watch_name(
                name: string,
                flags: BusNameWatcherFlags,
                name_appeared_closure?: GObject.Closure | null,
                name_vanished_closure?: GObject.Closure | null
            ): number;
            unwatch_name(watcher_id: number): void;
            own_name(
                name: string,
                flags: BusNameOwnerFlags,
                name_acquired_closure?: GObject.Closure | null,
                name_lost_closure?: GObject.Closure | null
            ): number;
            unown_name(owner_id: number): void;

            // Implemented Members

            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            init_finish(res: AsyncResult): boolean;
            /**
             * Finishes the async construction for the various g_async_initable_new
             * calls, returning the created object or %NULL on error.
             */
            new_finish(res: AsyncResult): DBusConnection;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            vfunc_init_finish(res: AsyncResult): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module DBusInterfaceSkeleton {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                g_flags: DBusInterfaceSkeletonFlags;
                gFlags: DBusInterfaceSkeletonFlags;
            }
        }
        export abstract class DBusInterfaceSkeleton extends GObject.Object implements DBusInterface {
            static $gtype: GObject.GType<DBusInterfaceSkeleton>;

            constructor(properties?: Partial<DBusInterfaceSkeleton.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusInterfaceSkeleton.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get g_flags(): DBusInterfaceSkeletonFlags;
            set g_flags(val: DBusInterfaceSkeletonFlags);
            get gFlags(): DBusInterfaceSkeletonFlags;
            set gFlags(val: DBusInterfaceSkeletonFlags);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "g-authorize-method",
                callback: (_source: this, invocation: DBusMethodInvocation) => boolean
            ): number;
            connect_after(
                signal: "g-authorize-method",
                callback: (_source: this, invocation: DBusMethodInvocation) => boolean
            ): number;
            emit(signal: "g-authorize-method", invocation: DBusMethodInvocation): void;

            // Members

            /**
             * Exports `interface_ `at `object_path `on `connection.`
             *
             * This can be called multiple times to export the same interface_
             * onto multiple connections however the `object_path `provided must be
             * the same for all connections.
             *
             * Use g_dbus_interface_skeleton_unexport() to unexport the object.
             */
            ["export"](connection: DBusConnection, object_path: string): boolean;
            /**
             * If `interface_ `has outstanding changes, request for these changes to be
             * emitted immediately.
             *
             * For example, an exported D-Bus interface may queue up property
             * changes and emit the
             * `org.freedesktop.DBus.Properties.PropertiesChanged`
             * signal later (e.g. in an idle handler). This technique is useful
             * for collapsing multiple property changes into one.
             */
            flush(): void;
            /**
             * Gets the first connection that `interface_ `is exported on, if any.
             */
            get_connection(): DBusConnection | null;
            /**
             * Gets a list of the connections that `interface_ `is exported on.
             */
            get_connections(): DBusConnection[];
            /**
             * Gets the #GDBusInterfaceSkeletonFlags that describes what the behavior
             * of interface_
             */
            get_flags(): DBusInterfaceSkeletonFlags;
            /**
             * Gets D-Bus introspection information for the D-Bus interface
             * implemented by `interface_.`
             */
            get_info(): DBusInterfaceInfo;
            /**
             * Gets the object path that `interface_ `is exported on, if any.
             */
            get_object_path(): string | null;
            /**
             * Gets all D-Bus properties for `interface_.`
             */
            get_properties(): GLib.Variant;
            /**
             * Checks if `interface_ `is exported on `connection.`
             */
            has_connection(connection: DBusConnection): boolean;
            /**
             * Sets flags describing what the behavior of `skeleton `should be.
             */
            set_flags(flags: DBusInterfaceSkeletonFlags): void;
            /**
             * Stops exporting `interface_ `on all connections it is exported on.
             *
             * To unexport `interface_ `from only a single connection, use
             * g_dbus_interface_skeleton_unexport_from_connection()
             */
            unexport(): void;
            /**
             * Stops exporting `interface_ `on `connection.`
             *
             * To stop exporting on all connections the interface is exported on,
             * use g_dbus_interface_skeleton_unexport().
             */
            unexport_from_connection(connection: DBusConnection): void;
            /**
             * If `interface_ `has outstanding changes, request for these changes to be
             * emitted immediately.
             *
             * For example, an exported D-Bus interface may queue up property
             * changes and emit the
             * `org.freedesktop.DBus.Properties.PropertiesChanged`
             * signal later (e.g. in an idle handler). This technique is useful
             * for collapsing multiple property changes into one.
             */
            vfunc_flush(): void;
            vfunc_g_authorize_method(invocation: DBusMethodInvocation): boolean;
            /**
             * Gets D-Bus introspection information for the D-Bus interface
             * implemented by `interface_.`
             */
            vfunc_get_info(): DBusInterfaceInfo;
            /**
             * Gets all D-Bus properties for `interface_.`
             */
            vfunc_get_properties(): GLib.Variant;

            // Implemented Members

            /**
             * Gets the #GDBusObject that `interface_ `belongs to, if any.
             */
            get_object(): DBusObject | null;
            /**
             * Sets the #GDBusObject for `interface_ `to `object.`
             *
             * Note that `interface_ `will hold a weak reference to `object.`
             */
            set_object(object?: DBusObject | null): void;
            /**
             * Gets the #GDBusObject that `interface_ `belongs to, if any.
             */
            vfunc_dup_object(): DBusObject | null;
            /**
             * Sets the #GDBusObject for `interface_ `to `object.`
             *
             * Note that `interface_ `will hold a weak reference to `object.`
             */
            vfunc_set_object(object?: DBusObject | null): void;
        }
        export module DBusMenuModel {
            export interface ConstructorProperties extends MenuModel.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class DBusMenuModel extends MenuModel {
            static $gtype: GObject.GType<DBusMenuModel>;

            constructor(properties?: Partial<DBusMenuModel.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusMenuModel.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Obtains a #GDBusMenuModel for the menu model which is exported
             * at the given `bus_name `and `object_path.`
             *
             * The thread default main context is taken at the time of this call.
             * All signals on the menu model (and any linked models) are reported
             * with respect to this context.  All calls on the returned menu model
             * (and linked models) must also originate from this same context, with
             * the thread default main context unchanged.
             */
            static get(connection: DBusConnection, bus_name: string | null, object_path: string): DBusMenuModel;
        }
        export module DBusMessage {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                locked: boolean;
            }
        }
        export class DBusMessage extends GObject.Object {
            static $gtype: GObject.GType<DBusMessage>;

            constructor(properties?: Partial<DBusMessage.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusMessage.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get locked(): boolean;

            // Constructors

            static ["new"](): DBusMessage;
            static new_from_blob(blob: Uint8Array | string, capabilities: DBusCapabilityFlags): DBusMessage;
            static new_method_call(
                name: string | null,
                path: string,
                interface_: string | null,
                method: string
            ): DBusMessage;
            static new_signal(path: string, interface_: string, signal: string): DBusMessage;

            // Members

            /**
             * Copies `message.` The copy is a deep copy and the returned
             * #GDBusMessage is completely identical except that it is guaranteed
             * to not be locked.
             *
             * This operation can fail if e.g. `message `contains file descriptors
             * and the per-process or system-wide open files limit is reached.
             */
            copy(): DBusMessage;
            /**
             * Convenience to get the first item in the body of `message.`
             */
            get_arg0(): string | null;
            /**
             * Gets the body of a message.
             */
            get_body(): GLib.Variant | null;
            /**
             * Gets the byte order of `message.`
             */
            get_byte_order(): DBusMessageByteOrder;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
             */
            get_destination(): string | null;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
             */
            get_error_name(): string | null;
            /**
             * Gets the flags for `message.`
             */
            get_flags(): DBusMessageFlags;
            /**
             * Gets a header field on `message.`
             *
             * The caller is responsible for checking the type of the returned #GVariant
             * matches what is expected.
             */
            get_header(header_field: DBusMessageHeaderField): GLib.Variant | null;
            /**
             * Gets an array of all header fields on `message `that are set.
             */
            get_header_fields(): Uint8Array;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
             */
            get_interface(): string | null;
            /**
             * Checks whether `message `is locked. To monitor changes to this
             * value, conncet to the #GObject::notify signal to listen for changes
             * on the #GDBusMessage:locked property.
             */
            get_locked(): boolean;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
             */
            get_member(): string | null;
            /**
             * Gets the type of `message.`
             */
            get_message_type(): DBusMessageType;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
             */
            get_num_unix_fds(): number;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
             */
            get_path(): string | null;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
             */
            get_reply_serial(): number;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
             */
            get_sender(): string | null;
            /**
             * Gets the serial for `message.`
             */
            get_serial(): number;
            /**
             * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
             *
             * This will always be non-%NULL, but may be an empty string.
             */
            get_signature(): string;
            /**
             * Gets the UNIX file descriptors associated with message, if any.
             *
             * This method is only available on UNIX.
             *
             * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
             * values in the body of the message. For example,
             * if g_variant_get_handle() returns 5, that is intended to be a reference
             * to the file descriptor that can be accessed by
             * `g_unix_fd_list_get (list, 5, ...)`.
             */
            get_unix_fd_list(): UnixFDList | null;
            /**
             * If `message `is locked, does nothing. Otherwise locks the message.
             */
            lock(): void;
            /**
             * Creates a new #GDBusMessage that is an error reply to `method_call_message.`
             */
            new_method_error_literal(error_name: string, error_message: string): DBusMessage;
            /**
             * Creates a new #GDBusMessage that is a reply to `method_call_message.`
             */
            new_method_reply(): DBusMessage;
            /**
             * Produces a human-readable multi-line description of `message.`
             *
             * The contents of the description has no ABI guarantees, the contents
             * and formatting is subject to change at any time. Typical output
             * looks something like this:
             * |[
             * Flags:   none
             * Version: 0
             * Serial:  4
             * Headers:
             * path -&gt; objectpath '/org/gtk/GDBus/TestObject'
             * interface -&gt; 'org.gtk.GDBus.TestInterface'
             * member -&gt; 'GimmeStdout'
             * destination -&gt; ':1.146'
             * Body: ()
             * UNIX File Descriptors:
             * (none)
             * ]|
             * or
             * |[
             * Flags:   no-reply-expected
             * Version: 0
             * Serial:  477
             * Headers:
             * reply-serial -&gt; uint32 4
             * destination -&gt; ':1.159'
             * sender -&gt; ':1.146'
             * num-unix-fds -&gt; uint32 1
             * Body: ()
             * UNIX File Descriptors:
             * fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
             * ]|
             */
            print(indent: number): string;
            /**
             * Sets the body `message.` As a side-effect the
             * %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
             * type string of `body `(or cleared if `body `is %NULL).
             *
             * If `body `is floating, `message `assumes ownership of `body.`
             */
            set_body(body: GLib.Variant): void;
            /**
             * Sets the byte order of `message.`
             */
            set_byte_order(byte_order: DBusMessageByteOrder): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
             */
            set_destination(value?: string | null): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
             */
            set_error_name(value: string): void;
            /**
             * Sets the flags to set on `message.`
             */
            set_flags(flags: DBusMessageFlags): void;
            /**
             * Sets a header field on `message.`
             *
             * If `value `is floating, `message `assumes ownership of `value.`
             */
            set_header(header_field: DBusMessageHeaderField, value?: GLib.Variant | null): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
             */
            set_interface(value?: string | null): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
             */
            set_member(value?: string | null): void;
            /**
             * Sets `message `to be of `type.`
             */
            set_message_type(type: DBusMessageType): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
             */
            set_num_unix_fds(value: number): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
             */
            set_path(value?: string | null): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
             */
            set_reply_serial(value: number): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
             */
            set_sender(value?: string | null): void;
            /**
             * Sets the serial for `message.`
             */
            set_serial(serial: number): void;
            /**
             * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
             */
            set_signature(value?: string | null): void;
            /**
             * Sets the UNIX file descriptors associated with `message.` As a
             * side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
             * field is set to the number of fds in `fd_list `(or cleared if
             * `fd_list `is %NULL).
             *
             * This method is only available on UNIX.
             *
             * When designing D-Bus APIs that are intended to be interoperable,
             * please note that non-GDBus implementations of D-Bus can usually only
             * access file descriptors if they are referenced by a value of type
             * %G_VARIANT_TYPE_HANDLE in the body of the message.
             */
            set_unix_fd_list(fd_list?: UnixFDList | null): void;
            /**
             * Serializes `message `to a blob. The byte order returned by
             * g_dbus_message_get_byte_order() will be used.
             */
            to_blob(capabilities: DBusCapabilityFlags): Uint8Array;
            /**
             * If `message `is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
             * nothing and returns %FALSE.
             *
             * Otherwise this method encodes the error in `message `as a #GError
             * using g_dbus_error_set_dbus_error() using the information in the
             * %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of `message `as
             * well as the first string item in message's body.
             */
            to_gerror(): boolean;
            /**
             * Utility function to calculate how many bytes are needed to
             * completely deserialize the D-Bus message stored at `blob.`
             */
            static bytes_needed(blob: Uint8Array | string): number;
        }
        export module DBusMethodInvocation {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class DBusMethodInvocation extends GObject.Object {
            static $gtype: GObject.GType<DBusMethodInvocation>;

            constructor(properties?: Partial<DBusMethodInvocation.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusMethodInvocation.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Gets the #GDBusConnection the method was invoked on.
             */
            get_connection(): DBusConnection;
            /**
             * Gets the name of the D-Bus interface the method was invoked on.
             *
             * If this method call is a property Get, Set or GetAll call that has
             * been redirected to the method call handler then
             * "org.freedesktop.DBus.Properties" will be returned.  See
             * #GDBusInterfaceVTable for more information.
             */
            get_interface_name(): string;
            /**
             * Gets the #GDBusMessage for the method invocation. This is useful if
             * you need to use low-level protocol features, such as UNIX file
             * descriptor passing, that cannot be properly expressed in the
             * #GVariant API.
             *
             * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
             * for an example of how to use this low-level API to send and receive
             * UNIX file descriptors.
             */
            get_message(): DBusMessage;
            /**
             * Gets information about the method call, if any.
             *
             * If this method invocation is a property Get, Set or GetAll call that
             * has been redirected to the method call handler then %NULL will be
             * returned.  See g_dbus_method_invocation_get_property_info() and
             * #GDBusInterfaceVTable for more information.
             */
            get_method_info(): DBusMethodInfo | null;
            /**
             * Gets the name of the method that was invoked.
             */
            get_method_name(): string;
            /**
             * Gets the object path the method was invoked on.
             */
            get_object_path(): string;
            /**
             * Gets the parameters of the method invocation. If there are no input
             * parameters then this will return a GVariant with 0 children rather than NULL.
             */
            get_parameters(): GLib.Variant;
            /**
             * Gets information about the property that this method call is for, if
             * any.
             *
             * This will only be set in the case of an invocation in response to a
             * property Get or Set call that has been directed to the method call
             * handler for an object on account of its property_get() or
             * property_set() vtable pointers being unset.
             *
             * See #GDBusInterfaceVTable for more information.
             *
             * If the call was GetAll, %NULL will be returned.
             */
            get_property_info(): DBusPropertyInfo | null;
            /**
             * Gets the bus name that invoked the method.
             */
            get_sender(): string;
            /**
             * Finishes handling a D-Bus method call by returning an error.
             *
             * This method will take ownership of `invocation.` See
             * #GDBusInterfaceVTable for more information about the ownership of
             * `invocation.`
             */
            return_dbus_error(error_name: string, error_message: string): void;
            /**
             * Like g_dbus_method_invocation_return_error() but without printf()-style formatting.
             *
             * This method will take ownership of `invocation.` See
             * #GDBusInterfaceVTable for more information about the ownership of
             * `invocation.`
             */
            return_error_literal(domain: GLib.Quark, code: number, message: string): void;
            /**
             * Like g_dbus_method_invocation_return_error() but takes a #GError
             * instead of the error domain, error code and message.
             *
             * This method will take ownership of `invocation.` See
             * #GDBusInterfaceVTable for more information about the ownership of
             * `invocation.`
             */
            return_gerror(error: GLib.Error): void;
            /**
             * Finishes handling a D-Bus method call by returning `parameters.`
             * If the `parameters `GVariant is floating, it is consumed.
             *
             * It is an error if `parameters `is not of the right format: it must be a tuple
             * containing the out-parameters of the D-Bus method. Even if the method has a
             * single out-parameter, it must be contained in a tuple. If the method has no
             * out-parameters, `parameters `may be %NULL or an empty tuple.
             *
             * |[&lt;!-- language="C" --&gt;
             * GDBusMethodInvocation *invocation = some_invocation;
             * g_autofree gchar *result_string = NULL;
             * g_autoptr (GError) error = NULL;
             *
             * result_string = calculate_result (&amp;error);
             *
             * if (error != NULL)
             * g_dbus_method_invocation_return_gerror (invocation, error);
             * else
             * g_dbus_method_invocation_return_value (invocation,
             * g_variant_new ("(s)", result_string));
             *
             * // Do not free `invocation `here; returning a value does that
             * ]|
             *
             * This method will take ownership of `invocation.` See
             * #GDBusInterfaceVTable for more information about the ownership of
             * `invocation.`
             *
             * Since 2.48, if the method call requested for a reply not to be sent
             * then this call will sink `parameters `and free invocation, but
             * otherwise do nothing (as per the recommendations of the D-Bus
             * specification).
             */
            return_value(parameters?: GLib.Variant | null): void;
            /**
             * Like g_dbus_method_invocation_return_value() but also takes a #GUnixFDList.
             *
             * This method is only available on UNIX.
             *
             * This method will take ownership of `invocation.` See
             * #GDBusInterfaceVTable for more information about the ownership of
             * `invocation.`
             */
            return_value_with_unix_fd_list(parameters?: GLib.Variant | null, fd_list?: UnixFDList | null): void;
        }
        export module DBusObjectManagerClient {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                bus_type: BusType;
                busType: BusType;
                connection: DBusConnection;
                flags: DBusObjectManagerClientFlags;
                get_proxy_type_destroy_notify: any;
                getProxyTypeDestroyNotify: any;
                get_proxy_type_func: any;
                getProxyTypeFunc: any;
                get_proxy_type_user_data: any;
                getProxyTypeUserData: any;
                name: string;
                name_owner: string;
                nameOwner: string;
                object_path: string;
                objectPath: string;
            }
        }
        export class DBusObjectManagerClient
            extends GObject.Object
            implements AsyncInitable<DBusObjectManagerClient>, DBusObjectManager, Initable
        {
            static $gtype: GObject.GType<DBusObjectManagerClient>;

            constructor(properties?: Partial<DBusObjectManagerClient.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusObjectManagerClient.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set bus_type(val: BusType);
            set busType(val: BusType);
            get connection(): DBusConnection;
            get flags(): DBusObjectManagerClientFlags;
            get get_proxy_type_destroy_notify(): any;
            get getProxyTypeDestroyNotify(): any;
            get get_proxy_type_func(): any;
            get getProxyTypeFunc(): any;
            get get_proxy_type_user_data(): any;
            get getProxyTypeUserData(): any;
            get name(): string;
            get name_owner(): string;
            get nameOwner(): string;
            get object_path(): string;
            get objectPath(): string;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "interface-proxy-properties-changed",
                callback: (
                    _source: this,
                    object_proxy: DBusObjectProxy,
                    interface_proxy: DBusProxy,
                    changed_properties: GLib.Variant,
                    invalidated_properties: string[]
                ) => void
            ): number;
            connect_after(
                signal: "interface-proxy-properties-changed",
                callback: (
                    _source: this,
                    object_proxy: DBusObjectProxy,
                    interface_proxy: DBusProxy,
                    changed_properties: GLib.Variant,
                    invalidated_properties: string[]
                ) => void
            ): number;
            emit(
                signal: "interface-proxy-properties-changed",
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string[]
            ): void;
            connect(
                signal: "interface-proxy-signal",
                callback: (
                    _source: this,
                    object_proxy: DBusObjectProxy,
                    interface_proxy: DBusProxy,
                    sender_name: string,
                    signal_name: string,
                    parameters: GLib.Variant
                ) => void
            ): number;
            connect_after(
                signal: "interface-proxy-signal",
                callback: (
                    _source: this,
                    object_proxy: DBusObjectProxy,
                    interface_proxy: DBusProxy,
                    sender_name: string,
                    signal_name: string,
                    parameters: GLib.Variant
                ) => void
            ): number;
            emit(
                signal: "interface-proxy-signal",
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                sender_name: string,
                signal_name: string,
                parameters: GLib.Variant
            ): void;

            // Constructors

            static new_finish(res: AsyncResult): DBusObjectManagerClient;
            // Conflicted with Gio.AsyncInitable.new_finish
            static new_finish(...args: never[]): any;
            static new_for_bus_finish(res: AsyncResult): DBusObjectManagerClient;
            static new_for_bus_sync(
                bus_type: BusType,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func?: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
                cancellable?: Cancellable | null
            ): DBusObjectManagerClient;
            static new_sync(
                connection: DBusConnection,
                flags: DBusObjectManagerClientFlags,
                name: string | null,
                object_path: string,
                get_proxy_type_func?: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
                cancellable?: Cancellable | null
            ): DBusObjectManagerClient;

            // Members

            /**
             * Gets the #GDBusConnection used by `manager.`
             */
            get_connection(): DBusConnection;
            /**
             * Gets the flags that `manager `was constructed with.
             */
            get_flags(): DBusObjectManagerClientFlags;
            /**
             * Gets the name that `manager `is for, or %NULL if not a message bus
             * connection.
             */
            get_name(): string;
            /**
             * The unique name that owns the name that `manager `is for or %NULL if
             * no-one currently owns that name. You can connect to the
             * #GObject::notify signal to track changes to the
             * #GDBusObjectManagerClient:name-owner property.
             */
            get_name_owner(): string | null;
            vfunc_interface_proxy_properties_changed(
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string
            ): void;
            vfunc_interface_proxy_signal(
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                sender_name: string,
                signal_name: string,
                parameters: GLib.Variant
            ): void;
            /**
             * Asynchronously creates a new #GDBusObjectManagerClient object.
             *
             * This is an asynchronous failable constructor. When the result is
             * ready, `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_object_manager_client_new_finish() to get the result. See
             * g_dbus_object_manager_client_new_sync() for the synchronous version.
             */
            static new(
                connection: DBusConnection,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func?: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
                cancellable?: Cancellable | null
            ): Promise<DBusObjectManagerClient>;
            /**
             * Asynchronously creates a new #GDBusObjectManagerClient object.
             *
             * This is an asynchronous failable constructor. When the result is
             * ready, `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_object_manager_client_new_finish() to get the result. See
             * g_dbus_object_manager_client_new_sync() for the synchronous version.
             */
            static new(
                connection: DBusConnection,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify: GLib.DestroyNotify | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<DBusObjectManagerClient> | null
            ): void;
            /**
             * Asynchronously creates a new #GDBusObjectManagerClient object.
             *
             * This is an asynchronous failable constructor. When the result is
             * ready, `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_object_manager_client_new_finish() to get the result. See
             * g_dbus_object_manager_client_new_sync() for the synchronous version.
             */
            static new(
                connection: DBusConnection,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func?: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<DBusObjectManagerClient> | null
            ): Promise<DBusObjectManagerClient> | void;
            /**
             * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
             * #GDBusConnection.
             *
             * This is an asynchronous failable constructor. When the result is
             * ready, `callback `will be invoked in the
             * [thread-default main loop][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
             * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
             */
            static new_for_bus(
                bus_type: BusType,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func?: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
                cancellable?: Cancellable | null
            ): Promise<DBusObjectManagerClient>;
            /**
             * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
             * #GDBusConnection.
             *
             * This is an asynchronous failable constructor. When the result is
             * ready, `callback `will be invoked in the
             * [thread-default main loop][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
             * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
             */
            static new_for_bus(
                bus_type: BusType,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify: GLib.DestroyNotify | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<DBusObjectManagerClient> | null
            ): void;
            /**
             * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
             * #GDBusConnection.
             *
             * This is an asynchronous failable constructor. When the result is
             * ready, `callback `will be invoked in the
             * [thread-default main loop][g-main-context-push-thread-default]
             * of the thread you are calling this method from. You can
             * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
             * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
             */
            static new_for_bus(
                bus_type: BusType,
                flags: DBusObjectManagerClientFlags,
                name: string,
                object_path: string,
                get_proxy_type_func?: DBusProxyTypeFunc | null,
                get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<DBusObjectManagerClient> | null
            ): Promise<DBusObjectManagerClient> | void;

            // Implemented Members

            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            init_finish(res: AsyncResult): boolean;
            /**
             * Finishes the async construction for the various g_async_initable_new
             * calls, returning the created object or %NULL on error.
             */
            new_finish(res: AsyncResult): DBusObjectManagerClient;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            vfunc_init_finish(res: AsyncResult): boolean;
            /**
             * Gets the interface proxy for `interface_name `at object_path, if
             * any.
             */
            get_interface(object_path: string, interface_name: string): DBusInterface | null;
            /**
             * Gets the #GDBusObject at object_path, if any.
             */
            get_object(object_path: string): DBusObject | null;
            /**
             * Gets the object path that `manager `is for.
             */
            get_object_path(): string;
            /**
             * Gets all #GDBusObject objects known to `manager.`
             */
            get_objects(): DBusObject[];
            /**
             * Gets the interface proxy for `interface_name `at object_path, if
             * any.
             */
            vfunc_get_interface(object_path: string, interface_name: string): DBusInterface | null;
            /**
             * Gets the #GDBusObject at object_path, if any.
             */
            vfunc_get_object(object_path: string): DBusObject | null;
            /**
             * Gets the object path that `manager `is for.
             */
            vfunc_get_object_path(): string;
            /**
             * Gets all #GDBusObject objects known to `manager.`
             */
            vfunc_get_objects(): DBusObject[];
            vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void;
            vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void;
            vfunc_object_added(object: DBusObject): void;
            vfunc_object_removed(object: DBusObject): void;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module DBusObjectManagerServer {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                connection: DBusConnection;
                object_path: string;
                objectPath: string;
            }
        }
        export class DBusObjectManagerServer extends GObject.Object implements DBusObjectManager {
            static $gtype: GObject.GType<DBusObjectManagerServer>;

            constructor(properties?: Partial<DBusObjectManagerServer.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusObjectManagerServer.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get connection(): DBusConnection;
            set connection(val: DBusConnection);
            get object_path(): string;
            get objectPath(): string;

            // Constructors

            static ["new"](object_path: string): DBusObjectManagerServer;

            // Members

            /**
             * Exports `object `on `manager.`
             *
             * If there is already a #GDBusObject exported at the object path,
             * then the old object is removed.
             *
             * The object path for `object `must be in the hierarchy rooted by the
             * object path for `manager.`
             *
             * Note that `manager `will take a reference on `object `for as long as
             * it is exported.
             */
            ["export"](object: DBusObjectSkeleton): void;
            /**
             * Like g_dbus_object_manager_server_export() but appends a string of
             * the form _N (with N being a natural number) to object's object path
             * if an object with the given path already exists. As such, the
             * #GDBusObjectProxy:g-object-path property of `object `may be modified.
             */
            export_uniquely(object: DBusObjectSkeleton): void;
            /**
             * Gets the #GDBusConnection used by `manager.`
             */
            get_connection(): DBusConnection | null;
            /**
             * Returns whether `object `is currently exported on `manager.`
             */
            is_exported(object: DBusObjectSkeleton): boolean;
            /**
             * Exports all objects managed by `manager `on `connection.` If
             * `connection `is %NULL, stops exporting objects.
             */
            set_connection(connection?: DBusConnection | null): void;
            /**
             * If `manager `has an object at path, removes the object. Otherwise
             * does nothing.
             *
             * Note that `object_path `must be in the hierarchy rooted by the
             * object path for `manager.`
             */
            unexport(object_path: string): boolean;

            // Implemented Members

            /**
             * Gets the interface proxy for `interface_name `at object_path, if
             * any.
             */
            get_interface(object_path: string, interface_name: string): DBusInterface | null;
            /**
             * Gets the #GDBusObject at object_path, if any.
             */
            get_object(object_path: string): DBusObject | null;
            /**
             * Gets the object path that `manager `is for.
             */
            get_object_path(): string;
            /**
             * Gets all #GDBusObject objects known to `manager.`
             */
            get_objects(): DBusObject[];
            /**
             * Gets the interface proxy for `interface_name `at object_path, if
             * any.
             */
            vfunc_get_interface(object_path: string, interface_name: string): DBusInterface | null;
            /**
             * Gets the #GDBusObject at object_path, if any.
             */
            vfunc_get_object(object_path: string): DBusObject | null;
            /**
             * Gets the object path that `manager `is for.
             */
            vfunc_get_object_path(): string;
            /**
             * Gets all #GDBusObject objects known to `manager.`
             */
            vfunc_get_objects(): DBusObject[];
            vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void;
            vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void;
            vfunc_object_added(object: DBusObject): void;
            vfunc_object_removed(object: DBusObject): void;
        }
        export module DBusObjectProxy {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                g_connection: DBusConnection;
                gConnection: DBusConnection;
                g_object_path: string;
                gObjectPath: string;
            }
        }
        export class DBusObjectProxy extends GObject.Object implements DBusObject {
            static $gtype: GObject.GType<DBusObjectProxy>;

            constructor(properties?: Partial<DBusObjectProxy.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusObjectProxy.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get g_connection(): DBusConnection;
            get gConnection(): DBusConnection;
            get g_object_path(): string;
            get gObjectPath(): string;

            // Constructors

            static ["new"](connection: DBusConnection, object_path: string): DBusObjectProxy;

            // Members

            /**
             * Gets the connection that `proxy `is for.
             */
            get_connection(): DBusConnection;

            // Implemented Members

            /**
             * Gets the D-Bus interface with name `interface_name `associated with
             * object, if any.
             */
            get_interface(interface_name: string): DBusInterface | null;
            /**
             * Gets the D-Bus interfaces associated with `object.`
             */
            get_interfaces(): DBusInterface[];
            /**
             * Gets the object path for `object.`
             */
            get_object_path(): string;
            /**
             * Gets the D-Bus interface with name `interface_name `associated with
             * object, if any.
             */
            vfunc_get_interface(interface_name: string): DBusInterface | null;
            /**
             * Gets the D-Bus interfaces associated with `object.`
             */
            vfunc_get_interfaces(): DBusInterface[];
            /**
             * Gets the object path for `object.`
             */
            vfunc_get_object_path(): string;
            vfunc_interface_added(interface_: DBusInterface): void;
            vfunc_interface_removed(interface_: DBusInterface): void;
        }
        export module DBusObjectSkeleton {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                g_object_path: string;
                gObjectPath: string;
            }
        }
        export class DBusObjectSkeleton extends GObject.Object implements DBusObject {
            static $gtype: GObject.GType<DBusObjectSkeleton>;

            constructor(properties?: Partial<DBusObjectSkeleton.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusObjectSkeleton.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get g_object_path(): string;
            set g_object_path(val: string);
            get gObjectPath(): string;
            set gObjectPath(val: string);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "authorize-method",
                callback: (
                    _source: this,
                    _interface: DBusInterfaceSkeleton,
                    invocation: DBusMethodInvocation
                ) => boolean
            ): number;
            connect_after(
                signal: "authorize-method",
                callback: (
                    _source: this,
                    _interface: DBusInterfaceSkeleton,
                    invocation: DBusMethodInvocation
                ) => boolean
            ): number;
            emit(signal: "authorize-method", _interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): void;

            // Constructors

            static ["new"](object_path: string): DBusObjectSkeleton;

            // Members

            /**
             * Adds `interface_ `to `object.`
             *
             * If `object `already contains a #GDBusInterfaceSkeleton with the same
             * interface name, it is removed before `interface_ `is added.
             *
             * Note that `object `takes its own reference on `interface_ `and holds
             * it until removed.
             */
            add_interface(interface_: DBusInterfaceSkeleton): void;
            /**
             * This method simply calls g_dbus_interface_skeleton_flush() on all
             * interfaces belonging to `object.` See that method for when flushing
             * is useful.
             */
            flush(): void;
            /**
             * Removes `interface_ `from `object.`
             */
            remove_interface(interface_: DBusInterfaceSkeleton): void;
            /**
             * Removes the #GDBusInterface with `interface_name `from `object.`
             *
             * If no D-Bus interface of the given interface exists, this function
             * does nothing.
             */
            remove_interface_by_name(interface_name: string): void;
            /**
             * Sets the object path for `object.`
             */
            set_object_path(object_path: string): void;
            vfunc_authorize_method(interface_: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): boolean;

            // Implemented Members

            /**
             * Gets the D-Bus interface with name `interface_name `associated with
             * object, if any.
             */
            get_interface(interface_name: string): DBusInterface | null;
            /**
             * Gets the D-Bus interfaces associated with `object.`
             */
            get_interfaces(): DBusInterface[];
            /**
             * Gets the object path for `object.`
             */
            get_object_path(): string;
            /**
             * Gets the D-Bus interface with name `interface_name `associated with
             * object, if any.
             */
            vfunc_get_interface(interface_name: string): DBusInterface | null;
            /**
             * Gets the D-Bus interfaces associated with `object.`
             */
            vfunc_get_interfaces(): DBusInterface[];
            /**
             * Gets the object path for `object.`
             */
            vfunc_get_object_path(): string;
            vfunc_interface_added(interface_: DBusInterface): void;
            vfunc_interface_removed(interface_: DBusInterface): void;
        }
        export module DBusProxy {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                g_bus_type: BusType;
                gBusType: BusType;
                g_connection: DBusConnection;
                gConnection: DBusConnection;
                g_default_timeout: number;
                gDefaultTimeout: number;
                g_flags: DBusProxyFlags;
                gFlags: DBusProxyFlags;
                g_interface_info: DBusInterfaceInfo;
                gInterfaceInfo: DBusInterfaceInfo;
                g_interface_name: string;
                gInterfaceName: string;
                g_name: string;
                gName: string;
                g_name_owner: string;
                gNameOwner: string;
                g_object_path: string;
                gObjectPath: string;
            }
        }
        export class DBusProxy extends GObject.Object implements AsyncInitable<DBusProxy>, DBusInterface, Initable {
            [key: string]: any;

            static $gtype: GObject.GType<DBusProxy>;

            constructor(properties?: Partial<DBusProxy.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusProxy.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set g_bus_type(val: BusType);
            set gBusType(val: BusType);
            get g_connection(): DBusConnection;
            get gConnection(): DBusConnection;
            get g_default_timeout(): number;
            set g_default_timeout(val: number);
            get gDefaultTimeout(): number;
            set gDefaultTimeout(val: number);
            get g_flags(): DBusProxyFlags;
            get gFlags(): DBusProxyFlags;
            get g_interface_info(): DBusInterfaceInfo;
            set g_interface_info(val: DBusInterfaceInfo);
            get gInterfaceInfo(): DBusInterfaceInfo;
            set gInterfaceInfo(val: DBusInterfaceInfo);
            get g_interface_name(): string;
            get gInterfaceName(): string;
            get g_name(): string;
            get gName(): string;
            get g_name_owner(): string;
            get gNameOwner(): string;
            get g_object_path(): string;
            get gObjectPath(): string;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "g-properties-changed",
                callback: (_source: this, changed_properties: GLib.Variant, invalidated_properties: string[]) => void
            ): number;
            connect_after(
                signal: "g-properties-changed",
                callback: (_source: this, changed_properties: GLib.Variant, invalidated_properties: string[]) => void
            ): number;
            emit(
                signal: "g-properties-changed",
                changed_properties: GLib.Variant,
                invalidated_properties: string[]
            ): void;
            connect(
                signal: "g-signal",
                callback: (
                    _source: this,
                    sender_name: string | null,
                    signal_name: string,
                    parameters: GLib.Variant
                ) => void
            ): number;
            connect_after(
                signal: "g-signal",
                callback: (
                    _source: this,
                    sender_name: string | null,
                    signal_name: string,
                    parameters: GLib.Variant
                ) => void
            ): number;
            emit(signal: "g-signal", sender_name: string | null, signal_name: string, parameters: GLib.Variant): void;

            // Constructors

            static new_finish(res: AsyncResult): DBusProxy;
            // Conflicted with Gio.AsyncInitable.new_finish
            static new_finish(...args: never[]): any;
            static new_for_bus_finish(res: AsyncResult): DBusProxy;
            static new_for_bus_sync(
                bus_type: BusType,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string,
                object_path: string,
                interface_name: string,
                cancellable?: Cancellable | null
            ): DBusProxy;
            static new_sync(
                connection: DBusConnection,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string | null,
                object_path: string,
                interface_name: string,
                cancellable?: Cancellable | null
            ): DBusProxy;

            // Members

            /**
             * Asynchronously invokes the `method_name `method on `proxy.`
             *
             * If `method_name `contains any dots, then `name `is split into interface and
             * method name parts. This allows using `proxy `for invoking methods on
             * other interfaces.
             *
             * If the #GDBusConnection associated with `proxy `is closed then
             * the operation will fail with %G_IO_ERROR_CLOSED. If
             * `cancellable `is canceled, the operation will fail with
             * %G_IO_ERROR_CANCELLED. If `parameters `contains a value not
             * compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_proxy_call (proxy,
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * (GAsyncReadyCallback) two_strings_done,
             * &amp;data);
             * ]|
             *
             * If `proxy `has an expected interface (see
             * #GDBusProxy:g-interface-info) and `method_name `is referenced by it,
             * then the return value is checked against the return type.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from.
             * You can then call g_dbus_proxy_call_finish() to get the result of
             * the operation. See g_dbus_proxy_call_sync() for the synchronous
             * version of this method.
             *
             * If `callback `is %NULL then the D-Bus method call message will be sent with
             * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
             */
            call(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null
            ): Promise<GLib.Variant>;
            /**
             * Asynchronously invokes the `method_name `method on `proxy.`
             *
             * If `method_name `contains any dots, then `name `is split into interface and
             * method name parts. This allows using `proxy `for invoking methods on
             * other interfaces.
             *
             * If the #GDBusConnection associated with `proxy `is closed then
             * the operation will fail with %G_IO_ERROR_CLOSED. If
             * `cancellable `is canceled, the operation will fail with
             * %G_IO_ERROR_CANCELLED. If `parameters `contains a value not
             * compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_proxy_call (proxy,
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * (GAsyncReadyCallback) two_strings_done,
             * &amp;data);
             * ]|
             *
             * If `proxy `has an expected interface (see
             * #GDBusProxy:g-interface-info) and `method_name `is referenced by it,
             * then the return value is checked against the return type.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from.
             * You can then call g_dbus_proxy_call_finish() to get the result of
             * the operation. See g_dbus_proxy_call_sync() for the synchronous
             * version of this method.
             *
             * If `callback `is %NULL then the D-Bus method call message will be sent with
             * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
             */
            call(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously invokes the `method_name `method on `proxy.`
             *
             * If `method_name `contains any dots, then `name `is split into interface and
             * method name parts. This allows using `proxy `for invoking methods on
             * other interfaces.
             *
             * If the #GDBusConnection associated with `proxy `is closed then
             * the operation will fail with %G_IO_ERROR_CLOSED. If
             * `cancellable `is canceled, the operation will fail with
             * %G_IO_ERROR_CANCELLED. If `parameters `contains a value not
             * compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_proxy_call (proxy,
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * (GAsyncReadyCallback) two_strings_done,
             * &amp;data);
             * ]|
             *
             * If `proxy `has an expected interface (see
             * #GDBusProxy:g-interface-info) and `method_name `is referenced by it,
             * then the return value is checked against the return type.
             *
             * This is an asynchronous method. When the operation is finished,
             * `callback `will be invoked in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread you are calling this method from.
             * You can then call g_dbus_proxy_call_finish() to get the result of
             * the operation. See g_dbus_proxy_call_sync() for the synchronous
             * version of this method.
             *
             * If `callback `is %NULL then the D-Bus method call message will be sent with
             * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
             */
            call(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<GLib.Variant> | void;
            /**
             * Finishes an operation started with g_dbus_proxy_call().
             */
            call_finish(res: AsyncResult): GLib.Variant;
            /**
             * Synchronously invokes the `method_name `method on `proxy.`
             *
             * If `method_name `contains any dots, then `name `is split into interface and
             * method name parts. This allows using `proxy `for invoking methods on
             * other interfaces.
             *
             * If the #GDBusConnection associated with `proxy `is disconnected then
             * the operation will fail with %G_IO_ERROR_CLOSED. If
             * `cancellable `is canceled, the operation will fail with
             * %G_IO_ERROR_CANCELLED. If `parameters `contains a value not
             * compatible with the D-Bus protocol, the operation fails with
             * %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * If the `parameters `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.:
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_proxy_call_sync (proxy,
             * "TwoStrings",
             * g_variant_new ("(ss)",
             * "Thing One",
             * "Thing Two"),
             * G_DBUS_CALL_FLAGS_NONE,
             * -1,
             * NULL,
             * &amp;error);
             * ]|
             *
             * The calling thread is blocked until a reply is received. See
             * g_dbus_proxy_call() for the asynchronous version of this
             * method.
             *
             * If `proxy `has an expected interface (see
             * #GDBusProxy:g-interface-info) and `method_name `is referenced by it,
             * then the return value is checked against the return type.
             */
            call_sync(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                cancellable?: Cancellable | null
            ): GLib.Variant;
            /**
             * Like g_dbus_proxy_call() but also takes a #GUnixFDList object.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list?: UnixFDList | null,
                cancellable?: Cancellable | null
            ): Promise<[GLib.Variant, UnixFDList | null]>;
            /**
             * Like g_dbus_proxy_call() but also takes a #GUnixFDList object.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list: UnixFDList | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Like g_dbus_proxy_call() but also takes a #GUnixFDList object.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list?: UnixFDList | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[GLib.Variant, UnixFDList | null]> | void;
            /**
             * Finishes an operation started with g_dbus_proxy_call_with_unix_fd_list().
             */
            call_with_unix_fd_list_finish(res: AsyncResult): [GLib.Variant, UnixFDList | null];
            /**
             * Like g_dbus_proxy_call_sync() but also takes and returns #GUnixFDList objects.
             *
             * This method is only available on UNIX.
             */
            call_with_unix_fd_list_sync(
                method_name: string,
                parameters: GLib.Variant | null,
                flags: DBusCallFlags,
                timeout_msec: number,
                fd_list?: UnixFDList | null,
                cancellable?: Cancellable | null
            ): [GLib.Variant, UnixFDList | null];
            /**
             * Looks up the value for a property from the cache. This call does no
             * blocking IO.
             *
             * If `proxy `has an expected interface (see
             * #GDBusProxy:g-interface-info) and `property_name `is referenced by
             * it, then `value `is checked against the type of the property.
             */
            get_cached_property(property_name: string): GLib.Variant | null;
            /**
             * Gets the names of all cached properties on `proxy.`
             */
            get_cached_property_names(): string[] | null;
            /**
             * Gets the connection `proxy `is for.
             */
            get_connection(): DBusConnection;
            /**
             * Gets the timeout to use if -1 (specifying default timeout) is
             * passed as `timeout_msec `in the g_dbus_proxy_call() and
             * g_dbus_proxy_call_sync() functions.
             *
             * See the #GDBusProxy:g-default-timeout property for more details.
             */
            get_default_timeout(): number;
            /**
             * Gets the flags that `proxy `was constructed with.
             */
            get_flags(): DBusProxyFlags;
            /**
             * Returns the #GDBusInterfaceInfo, if any, specifying the interface
             * that `proxy `conforms to. See the #GDBusProxy:g-interface-info
             * property for more details.
             */
            get_interface_info(): DBusInterfaceInfo | null;
            /**
             * Gets the D-Bus interface name `proxy `is for.
             */
            get_interface_name(): string;
            /**
             * Gets the name that `proxy `was constructed for.
             *
             * When connected to a message bus, this will usually be non-%NULL.
             * However, it may be %NULL for a proxy that communicates using a peer-to-peer
             * pattern.
             */
            get_name(): string | null;
            /**
             * The unique name that owns the name that `proxy `is for or %NULL if
             * no-one currently owns that name. You may connect to the
             * #GObject::notify signal to track changes to the
             * #GDBusProxy:g-name-owner property.
             */
            get_name_owner(): string | null;
            /**
             * Gets the object path `proxy `is for.
             */
            get_object_path(): string;
            /**
             * If `value `is not %NULL, sets the cached value for the property with
             * name `property_name `to the value in `value.`
             *
             * If `value `is %NULL, then the cached value is removed from the
             * property cache.
             *
             * If `proxy `has an expected interface (see
             * #GDBusProxy:g-interface-info) and `property_name `is referenced by
             * it, then `value `is checked against the type of the property.
             *
             * If the `value `#GVariant is floating, it is consumed. This allows
             * convenient 'inline' use of g_variant_new(), e.g.
             * |[&lt;!-- language="C" --&gt;
             * g_dbus_proxy_set_cached_property (proxy,
             * "SomeProperty",
             * g_variant_new ("(si)",
             * "A String",
             * 42));
             * ]|
             *
             * Normally you will not need to use this method since proxy
             * is tracking changes using the
             * `org.freedesktop.DBus.Properties.PropertiesChanged`
             * D-Bus signal. However, for performance reasons an object may
             * decide to not use this signal for some properties and instead
             * use a proprietary out-of-band mechanism to transmit changes.
             *
             * As a concrete example, consider an object with a property
             * `ChatroomParticipants` which is an array of strings. Instead of
             * transmitting the same (long) array every time the property changes,
             * it is more efficient to only transmit the delta using e.g. signals
             * `ChatroomParticipantJoined(String name)` and
             * `ChatroomParticipantParted(String name)`.
             */
            set_cached_property(property_name: string, value?: GLib.Variant | null): void;
            /**
             * Sets the timeout to use if -1 (specifying default timeout) is
             * passed as `timeout_msec `in the g_dbus_proxy_call() and
             * g_dbus_proxy_call_sync() functions.
             *
             * See the #GDBusProxy:g-default-timeout property for more details.
             */
            set_default_timeout(timeout_msec: number): void;
            /**
             * Ensure that interactions with `proxy `conform to the given
             * interface. See the #GDBusProxy:g-interface-info property for more
             * details.
             */
            set_interface_info(info?: DBusInterfaceInfo | null): void;
            vfunc_g_properties_changed(changed_properties: GLib.Variant, invalidated_properties: string): void;
            vfunc_g_signal(sender_name: string, signal_name: string, parameters: GLib.Variant): void;
            /**
             * Creates a proxy for accessing `interface_name `on the remote object
             * at `object_path `owned by `name `at `connection `and asynchronously
             * loads D-Bus properties unless the
             * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
             * the #GDBusProxy::g-properties-changed signal to get notified about
             * property changes.
             *
             * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
             * match rules for signals. Connect to the #GDBusProxy::g-signal signal
             * to handle signals from the remote object.
             *
             * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
             * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
             * guaranteed to complete immediately without blocking.
             *
             * If `name `is a well-known name and the
             * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
             * flags aren't set and no name owner currently exists, the message bus
             * will be requested to launch a name owner for the name.
             *
             * This is a failable asynchronous constructor - when the proxy is
             * ready, `callback `will be invoked and you can use
             * g_dbus_proxy_new_finish() to get the result.
             *
             * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
             *
             * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
             */
            static new(
                connection: DBusConnection,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string | null,
                object_path: string,
                interface_name: string,
                cancellable?: Cancellable | null
            ): Promise<DBusProxy>;
            /**
             * Creates a proxy for accessing `interface_name `on the remote object
             * at `object_path `owned by `name `at `connection `and asynchronously
             * loads D-Bus properties unless the
             * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
             * the #GDBusProxy::g-properties-changed signal to get notified about
             * property changes.
             *
             * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
             * match rules for signals. Connect to the #GDBusProxy::g-signal signal
             * to handle signals from the remote object.
             *
             * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
             * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
             * guaranteed to complete immediately without blocking.
             *
             * If `name `is a well-known name and the
             * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
             * flags aren't set and no name owner currently exists, the message bus
             * will be requested to launch a name owner for the name.
             *
             * This is a failable asynchronous constructor - when the proxy is
             * ready, `callback `will be invoked and you can use
             * g_dbus_proxy_new_finish() to get the result.
             *
             * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
             *
             * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
             */
            static new(
                connection: DBusConnection,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string | null,
                object_path: string,
                interface_name: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<DBusProxy> | null
            ): void;
            /**
             * Creates a proxy for accessing `interface_name `on the remote object
             * at `object_path `owned by `name `at `connection `and asynchronously
             * loads D-Bus properties unless the
             * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
             * the #GDBusProxy::g-properties-changed signal to get notified about
             * property changes.
             *
             * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
             * match rules for signals. Connect to the #GDBusProxy::g-signal signal
             * to handle signals from the remote object.
             *
             * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
             * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
             * guaranteed to complete immediately without blocking.
             *
             * If `name `is a well-known name and the
             * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
             * flags aren't set and no name owner currently exists, the message bus
             * will be requested to launch a name owner for the name.
             *
             * This is a failable asynchronous constructor - when the proxy is
             * ready, `callback `will be invoked and you can use
             * g_dbus_proxy_new_finish() to get the result.
             *
             * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
             *
             * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
             */
            static new(
                connection: DBusConnection,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string | null,
                object_path: string,
                interface_name: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<DBusProxy> | null
            ): Promise<DBusProxy> | void;
            /**
             * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
             *
             * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
             */
            static new_for_bus(
                bus_type: BusType,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string,
                object_path: string,
                interface_name: string,
                cancellable?: Cancellable | null
            ): Promise<DBusProxy>;
            /**
             * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
             *
             * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
             */
            static new_for_bus(
                bus_type: BusType,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string,
                object_path: string,
                interface_name: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<DBusProxy> | null
            ): void;
            /**
             * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
             *
             * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
             */
            static new_for_bus(
                bus_type: BusType,
                flags: DBusProxyFlags,
                info: DBusInterfaceInfo | null,
                name: string,
                object_path: string,
                interface_name: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<DBusProxy> | null
            ): Promise<DBusProxy> | void;
            static makeProxyWrapper(...args: any[]): any;
            connectSignal(...args: any[]): any;
            disconnectSignal(...args: any[]): any;

            // Implemented Members

            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            init_finish(res: AsyncResult): boolean;
            /**
             * Finishes the async construction for the various g_async_initable_new
             * calls, returning the created object or %NULL on error.
             */
            new_finish(res: AsyncResult): DBusProxy;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            vfunc_init_finish(res: AsyncResult): boolean;
            /**
             * Gets the #GDBusObject that `interface_ `belongs to, if any.
             */
            get_object(): DBusObject | null;
            /**
             * Gets D-Bus introspection information for the D-Bus interface
             * implemented by `interface_.`
             */
            get_info(): DBusInterfaceInfo;
            /**
             * Sets the #GDBusObject for `interface_ `to `object.`
             *
             * Note that `interface_ `will hold a weak reference to `object.`
             */
            set_object(object?: DBusObject | null): void;
            /**
             * Gets the #GDBusObject that `interface_ `belongs to, if any.
             */
            vfunc_dup_object(): DBusObject | null;
            /**
             * Gets D-Bus introspection information for the D-Bus interface
             * implemented by `interface_.`
             */
            vfunc_get_info(): DBusInterfaceInfo;
            /**
             * Sets the #GDBusObject for `interface_ `to `object.`
             *
             * Note that `interface_ `will hold a weak reference to `object.`
             */
            vfunc_set_object(object?: DBusObject | null): void;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module DBusServer {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                active: boolean;
                address: string;
                authentication_observer: DBusAuthObserver;
                authenticationObserver: DBusAuthObserver;
                client_address: string;
                clientAddress: string;
                flags: DBusServerFlags;
                guid: string;
            }
        }
        export class DBusServer extends GObject.Object implements Initable {
            static $gtype: GObject.GType<DBusServer>;

            constructor(properties?: Partial<DBusServer.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusServer.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get active(): boolean;
            get address(): string;
            get authentication_observer(): DBusAuthObserver;
            get authenticationObserver(): DBusAuthObserver;
            get client_address(): string;
            get clientAddress(): string;
            get flags(): DBusServerFlags;
            get guid(): string;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "new-connection", callback: (_source: this, connection: DBusConnection) => boolean): number;
            connect_after(
                signal: "new-connection",
                callback: (_source: this, connection: DBusConnection) => boolean
            ): number;
            emit(signal: "new-connection", connection: DBusConnection): void;

            // Constructors

            static new_sync(
                address: string,
                flags: DBusServerFlags,
                guid: string,
                observer?: DBusAuthObserver | null,
                cancellable?: Cancellable | null
            ): DBusServer;

            // Members

            /**
             * Gets a
             * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
             * string that can be used by clients to connect to `server.`
             *
             * This is valid and non-empty if initializing the #GDBusServer succeeded.
             */
            get_client_address(): string;
            /**
             * Gets the flags for `server.`
             */
            get_flags(): DBusServerFlags;
            /**
             * Gets the GUID for server, as provided to g_dbus_server_new_sync().
             */
            get_guid(): string;
            /**
             * Gets whether `server `is active.
             */
            is_active(): boolean;
            /**
             * Starts `server.`
             */
            start(): void;
            /**
             * Stops `server.`
             */
            stop(): void;

            // Implemented Members

            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module DataInputStream {
            export interface ConstructorProperties extends BufferedInputStream.ConstructorProperties {
                [key: string]: any;
                byte_order: DataStreamByteOrder;
                byteOrder: DataStreamByteOrder;
                newline_type: DataStreamNewlineType;
                newlineType: DataStreamNewlineType;
            }
        }
        export class DataInputStream extends BufferedInputStream implements Seekable {
            static $gtype: GObject.GType<DataInputStream>;

            constructor(properties?: Partial<DataInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DataInputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get byte_order(): DataStreamByteOrder;
            set byte_order(val: DataStreamByteOrder);
            get byteOrder(): DataStreamByteOrder;
            set byteOrder(val: DataStreamByteOrder);
            get newline_type(): DataStreamNewlineType;
            set newline_type(val: DataStreamNewlineType);
            get newlineType(): DataStreamNewlineType;
            set newlineType(val: DataStreamNewlineType);

            // Constructors

            static ["new"](base_stream: InputStream): DataInputStream;

            // Members

            /**
             * Gets the byte order for the data input stream.
             */
            get_byte_order(): DataStreamByteOrder;
            /**
             * Gets the current newline type for the `stream.`
             */
            get_newline_type(): DataStreamNewlineType;
            /**
             * Reads an unsigned 8-bit/1-byte value from `stream.`
             */
            read_byte(cancellable?: Cancellable | null): number;
            /**
             * Reads a 16-bit/2-byte value from `stream.`
             *
             * In order to get the correct byte order for this read operation,
             * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
             */
            read_int16(cancellable?: Cancellable | null): number;
            /**
             * Reads a signed 32-bit/4-byte value from `stream.`
             *
             * In order to get the correct byte order for this read operation,
             * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            read_int32(cancellable?: Cancellable | null): number;
            /**
             * Reads a 64-bit/8-byte value from `stream.`
             *
             * In order to get the correct byte order for this read operation,
             * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            read_int64(cancellable?: Cancellable | null): number;
            /**
             * Reads a line from the data input stream.  Note that no encoding
             * checks or conversion is performed; the input is not guaranteed to
             * be UTF-8, and may in fact have embedded NUL characters.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            read_line(cancellable?: Cancellable | null): [Uint8Array | null, number];
            /**
             * The asynchronous version of g_data_input_stream_read_line().  It is
             * an error to have two outstanding calls to this function.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_line_finish() to get
             * the result of the operation.
             */
            read_line_async(
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[Uint8Array | null, number]>;
            /**
             * The asynchronous version of g_data_input_stream_read_line().  It is
             * an error to have two outstanding calls to this function.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_line_finish() to get
             * the result of the operation.
             */
            read_line_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * The asynchronous version of g_data_input_stream_read_line().  It is
             * an error to have two outstanding calls to this function.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_line_finish() to get
             * the result of the operation.
             */
            read_line_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[Uint8Array | null, number]> | void;
            /**
             * Finish an asynchronous call started by
             * g_data_input_stream_read_line_async().  Note the warning about
             * string encoding in g_data_input_stream_read_line() applies here as
             * well.
             */
            read_line_finish(result: AsyncResult): [Uint8Array | null, number];
            /**
             * Finish an asynchronous call started by
             * g_data_input_stream_read_line_async().
             */
            read_line_finish_utf8(result: AsyncResult): [string | null, number];
            /**
             * Reads a UTF-8 encoded line from the data input stream.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            read_line_utf8(cancellable?: Cancellable | null): [string | null, number];
            /**
             * Reads an unsigned 16-bit/2-byte value from `stream.`
             *
             * In order to get the correct byte order for this read operation,
             * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
             */
            read_uint16(cancellable?: Cancellable | null): number;
            /**
             * Reads an unsigned 32-bit/4-byte value from `stream.`
             *
             * In order to get the correct byte order for this read operation,
             * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            read_uint32(cancellable?: Cancellable | null): number;
            /**
             * Reads an unsigned 64-bit/8-byte value from `stream.`
             *
             * In order to get the correct byte order for this read operation,
             * see g_data_input_stream_get_byte_order().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            read_uint64(cancellable?: Cancellable | null): number;
            /**
             * Reads a string from the data input stream, up to the first
             * occurrence of any of the stop characters.
             *
             * Note that, in contrast to g_data_input_stream_read_until_async(),
             * this function consumes the stop character that it finds.
             *
             * Don't use this function in new code.  Its functionality is
             * inconsistent with g_data_input_stream_read_until_async().  Both
             * functions will be marked as deprecated in a future release.  Use
             * g_data_input_stream_read_upto() instead, but note that that function
             * does not consume the stop character.
             */
            read_until(stop_chars: string, cancellable?: Cancellable | null): [string, number];
            /**
             * The asynchronous version of g_data_input_stream_read_until().
             * It is an error to have two outstanding calls to this function.
             *
             * Note that, in contrast to g_data_input_stream_read_until(),
             * this function does not consume the stop character that it finds.  You
             * must read it for yourself.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_until_finish() to get
             * the result of the operation.
             *
             * Don't use this function in new code.  Its functionality is
             * inconsistent with g_data_input_stream_read_until().  Both functions
             * will be marked as deprecated in a future release.  Use
             * g_data_input_stream_read_upto_async() instead.
             */
            read_until_async(
                stop_chars: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[string, number]>;
            /**
             * The asynchronous version of g_data_input_stream_read_until().
             * It is an error to have two outstanding calls to this function.
             *
             * Note that, in contrast to g_data_input_stream_read_until(),
             * this function does not consume the stop character that it finds.  You
             * must read it for yourself.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_until_finish() to get
             * the result of the operation.
             *
             * Don't use this function in new code.  Its functionality is
             * inconsistent with g_data_input_stream_read_until().  Both functions
             * will be marked as deprecated in a future release.  Use
             * g_data_input_stream_read_upto_async() instead.
             */
            read_until_async(
                stop_chars: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * The asynchronous version of g_data_input_stream_read_until().
             * It is an error to have two outstanding calls to this function.
             *
             * Note that, in contrast to g_data_input_stream_read_until(),
             * this function does not consume the stop character that it finds.  You
             * must read it for yourself.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_until_finish() to get
             * the result of the operation.
             *
             * Don't use this function in new code.  Its functionality is
             * inconsistent with g_data_input_stream_read_until().  Both functions
             * will be marked as deprecated in a future release.  Use
             * g_data_input_stream_read_upto_async() instead.
             */
            read_until_async(
                stop_chars: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[string, number]> | void;
            /**
             * Finish an asynchronous call started by
             * g_data_input_stream_read_until_async().
             */
            read_until_finish(result: AsyncResult): [string, number];
            /**
             * Reads a string from the data input stream, up to the first
             * occurrence of any of the stop characters.
             *
             * In contrast to g_data_input_stream_read_until(), this function
             * does not consume the stop character. You have to use
             * g_data_input_stream_read_byte() to get it before calling
             * g_data_input_stream_read_upto() again.
             *
             * Note that `stop_chars `may contain '\0' if `stop_chars_len `is
             * specified.
             *
             * The returned string will always be nul-terminated on success.
             */
            read_upto(stop_chars: string, stop_chars_len: number, cancellable?: Cancellable | null): [string, number];
            /**
             * The asynchronous version of g_data_input_stream_read_upto().
             * It is an error to have two outstanding calls to this function.
             *
             * In contrast to g_data_input_stream_read_until(), this function
             * does not consume the stop character. You have to use
             * g_data_input_stream_read_byte() to get it before calling
             * g_data_input_stream_read_upto() again.
             *
             * Note that `stop_chars `may contain '\0' if `stop_chars_len `is
             * specified.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_upto_finish() to get
             * the result of the operation.
             */
            read_upto_async(
                stop_chars: string,
                stop_chars_len: number,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[string, number]>;
            /**
             * The asynchronous version of g_data_input_stream_read_upto().
             * It is an error to have two outstanding calls to this function.
             *
             * In contrast to g_data_input_stream_read_until(), this function
             * does not consume the stop character. You have to use
             * g_data_input_stream_read_byte() to get it before calling
             * g_data_input_stream_read_upto() again.
             *
             * Note that `stop_chars `may contain '\0' if `stop_chars_len `is
             * specified.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_upto_finish() to get
             * the result of the operation.
             */
            read_upto_async(
                stop_chars: string,
                stop_chars_len: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * The asynchronous version of g_data_input_stream_read_upto().
             * It is an error to have two outstanding calls to this function.
             *
             * In contrast to g_data_input_stream_read_until(), this function
             * does not consume the stop character. You have to use
             * g_data_input_stream_read_byte() to get it before calling
             * g_data_input_stream_read_upto() again.
             *
             * Note that `stop_chars `may contain '\0' if `stop_chars_len `is
             * specified.
             *
             * When the operation is finished, `callback `will be called. You
             * can then call g_data_input_stream_read_upto_finish() to get
             * the result of the operation.
             */
            read_upto_async(
                stop_chars: string,
                stop_chars_len: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[string, number]> | void;
            /**
             * Finish an asynchronous call started by
             * g_data_input_stream_read_upto_async().
             *
             * Note that this function does not consume the stop character. You
             * have to use g_data_input_stream_read_byte() to get it before calling
             * g_data_input_stream_read_upto_async() again.
             *
             * The returned string will always be nul-terminated on success.
             */
            read_upto_finish(result: AsyncResult): [string, number];
            /**
             * This function sets the byte order for the given `stream.` All subsequent
             * reads from the `stream `will be read in the given `order.`
             */
            set_byte_order(order: DataStreamByteOrder): void;
            /**
             * Sets the newline type for the `stream.`
             *
             * Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
             * chunk ends in "CR" we must read an additional byte to know if this is "CR" or
             * "CR LF", and this might block if there is no more data available.
             */
            set_newline_type(type: DataStreamNewlineType): void;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module DataOutputStream {
            export interface ConstructorProperties extends FilterOutputStream.ConstructorProperties {
                [key: string]: any;
                byte_order: DataStreamByteOrder;
                byteOrder: DataStreamByteOrder;
            }
        }
        export class DataOutputStream extends FilterOutputStream implements Seekable {
            static $gtype: GObject.GType<DataOutputStream>;

            constructor(properties?: Partial<DataOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DataOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get byte_order(): DataStreamByteOrder;
            set byte_order(val: DataStreamByteOrder);
            get byteOrder(): DataStreamByteOrder;
            set byteOrder(val: DataStreamByteOrder);

            // Constructors

            static ["new"](base_stream: OutputStream): DataOutputStream;

            // Members

            /**
             * Gets the byte order for the stream.
             */
            get_byte_order(): DataStreamByteOrder;
            /**
             * Puts a byte into the output stream.
             */
            put_byte(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Puts a signed 16-bit integer into the output stream.
             */
            put_int16(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Puts a signed 32-bit integer into the output stream.
             */
            put_int32(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Puts a signed 64-bit integer into the stream.
             */
            put_int64(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Puts a string into the output stream.
             */
            put_string(str: string, cancellable?: Cancellable | null): boolean;
            /**
             * Puts an unsigned 16-bit integer into the output stream.
             */
            put_uint16(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Puts an unsigned 32-bit integer into the stream.
             */
            put_uint32(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Puts an unsigned 64-bit integer into the stream.
             */
            put_uint64(data: number, cancellable?: Cancellable | null): boolean;
            /**
             * Sets the byte order of the data output stream to `order.`
             */
            set_byte_order(order: DataStreamByteOrder): void;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module DebugControllerDBus {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                connection: DBusConnection;
            }
        }
        export class DebugControllerDBus extends GObject.Object implements DebugController, Initable {
            static $gtype: GObject.GType<DebugControllerDBus>;

            constructor(properties?: Partial<DebugControllerDBus.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DebugControllerDBus.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get connection(): DBusConnection;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "authorize",
                callback: (_source: this, invocation: DBusMethodInvocation) => boolean
            ): number;
            connect_after(
                signal: "authorize",
                callback: (_source: this, invocation: DBusMethodInvocation) => boolean
            ): number;
            emit(signal: "authorize", invocation: DBusMethodInvocation): void;

            // Implemented Properties

            get debug_enabled(): boolean;
            set debug_enabled(val: boolean);
            get debugEnabled(): boolean;
            set debugEnabled(val: boolean);

            // Constructors

            static ["new"](connection: DBusConnection, cancellable?: Cancellable | null): DebugControllerDBus;

            // Members

            /**
             * Stop the debug controller, unregistering its object from the bus.
             *
             * Any pending method calls to the object will complete successfully, but new
             * ones will return an error. This method will block until all pending
             * #GDebugControllerDBus::authorize signals have been handled. This is expected
             * to not take long, as it will just be waiting for threads to join. If any
             * #GDebugControllerDBus::authorize signal handlers are still executing in other
             * threads, this will block until after they have returned.
             *
             * This method will be called automatically when the final reference to the
             * #GDebugControllerDBus is dropped. You may want to call it explicitly to know
             * when the controller has been fully removed from the bus, or to break
             * reference count cycles.
             *
             * Calling this method from within a #GDebugControllerDBus::authorize signal
             * handler will cause a deadlock and must not be done.
             */
            stop(): void;
            vfunc_authorize(invocation: DBusMethodInvocation): boolean;

            // Implemented Members

            /**
             * Get the value of #GDebugController:debug-enabled.
             */
            get_debug_enabled(): boolean;
            /**
             * Set the value of #GDebugController:debug-enabled.
             */
            set_debug_enabled(debug_enabled: boolean): void;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module DesktopAppInfo {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                filename: string;
            }
        }
        export class DesktopAppInfo extends GObject.Object implements AppInfo {
            static $gtype: GObject.GType<DesktopAppInfo>;

            constructor(properties?: Partial<DesktopAppInfo.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DesktopAppInfo.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get filename(): string;

            // Constructors

            static ["new"](desktop_id: string): DesktopAppInfo;
            static new_from_filename(filename: string): DesktopAppInfo;
            static new_from_keyfile(key_file: GLib.KeyFile): DesktopAppInfo;

            // Members

            /**
             * Gets the user-visible display name of the "additional application
             * action" specified by `action_name.`
             *
             * This corresponds to the "Name" key within the keyfile group for the
             * action.
             */
            get_action_name(action_name: string): string;
            /**
             * Looks up a boolean value in the keyfile backing `info.`
             *
             * The `key `is looked up in the "Desktop Entry" group.
             */
            get_boolean(key: string): boolean;
            /**
             * Gets the categories from the desktop file.
             */
            get_categories(): string | null;
            /**
             * When `info `was created from a known filename, return it.  In some
             * situations such as the #GDesktopAppInfo returned from
             * g_desktop_app_info_new_from_keyfile(), this function will return %NULL.
             */
            get_filename(): string | null;
            /**
             * Gets the generic name from the desktop file.
             */
            get_generic_name(): string | null;
            /**
             * A desktop file is hidden if the Hidden key in it is
             * set to True.
             */
            get_is_hidden(): boolean;
            /**
             * Gets the keywords from the desktop file.
             */
            get_keywords(): string[];
            /**
             * Looks up a localized string value in the keyfile backing info
             * translated to the current locale.
             *
             * The `key `is looked up in the "Desktop Entry" group.
             */
            get_locale_string(key: string): string | null;
            /**
             * Gets the value of the NoDisplay key, which helps determine if the
             * application info should be shown in menus. See
             * %G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
             */
            get_nodisplay(): boolean;
            /**
             * Checks if the application info should be shown in menus that list available
             * applications for a specific name of the desktop, based on the
             * `OnlyShowIn` and `NotShowIn` keys.
             *
             * `desktop_env `should typically be given as %NULL, in which case the
             * `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
             * to override the default mechanism then you may specify desktop_env,
             * but this is not recommended.
             *
             * Note that g_app_info_should_show() for `info `will include this check (with
             * %NULL for desktop_env) as well as additional checks.
             */
            get_show_in(desktop_env?: string | null): boolean;
            /**
             * Retrieves the StartupWMClass field from `info.` This represents the
             * WM_CLASS property of the main window of the application, if launched
             * through `info.`
             */
            get_startup_wm_class(): string | null;
            /**
             * Looks up a string value in the keyfile backing `info.`
             *
             * The `key `is looked up in the "Desktop Entry" group.
             */
            get_string(key: string): string | null;
            /**
             * Looks up a string list value in the keyfile backing `info.`
             *
             * The `key `is looked up in the "Desktop Entry" group.
             */
            get_string_list(key: string): string[];
            /**
             * Returns whether `key `exists in the "Desktop Entry" group
             * of the keyfile backing `info.`
             */
            has_key(key: string): boolean;
            /**
             * Activates the named application action.
             *
             * You may only call this function on action names that were
             * returned from g_desktop_app_info_list_actions().
             *
             * Note that if the main entry of the desktop file indicates that the
             * application supports startup notification, and `launch_context `is
             * non-%NULL, then startup notification will be used when activating the
             * action (and as such, invocation of the action on the receiving side
             * must signal the end of startup notification when it is completed).
             * This is the expected behaviour of applications declaring additional
             * actions, as per the desktop file specification.
             *
             * As with g_app_info_launch() there is no way to detect failures that
             * occur while using this function.
             */
            launch_action(action_name: string, launch_context?: AppLaunchContext | null): void;
            /**
             * This function performs the equivalent of g_app_info_launch_uris(),
             * but is intended primarily for operating system components that
             * launch applications.  Ordinary applications should use
             * g_app_info_launch_uris().
             *
             * If the application is launched via GSpawn, then spawn_flags, user_setup
             * and `user_setup_data `are used for the call to g_spawn_async().
             * Additionally, `pid_callback `(with pid_callback_data) will be called to
             * inform about the PID of the created process. See g_spawn_async_with_pipes()
             * for information on certain parameter conditions that can enable an
             * optimized posix_spawn() codepath to be used.
             *
             * If application launching occurs via some other mechanism (eg: D-Bus
             * activation) then spawn_flags, user_setup, user_setup_data,
             * `pid_callback `and `pid_callback_data `are ignored.
             */
            launch_uris_as_manager(
                uris: string[],
                launch_context: AppLaunchContext | null,
                spawn_flags: GLib.SpawnFlags
            ): boolean;
            /**
             * Equivalent to g_desktop_app_info_launch_uris_as_manager() but allows
             * you to pass in file descriptors for the stdin, stdout and stderr streams
             * of the launched process.
             *
             * If application launching occurs via some non-spawn mechanism (e.g. D-Bus
             * activation) then stdin_fd, `stdout_fd `and `stderr_fd `are ignored.
             */
            launch_uris_as_manager_with_fds(
                uris: string[],
                launch_context: AppLaunchContext | null,
                spawn_flags: GLib.SpawnFlags,
                user_setup: GLib.SpawnChildSetupFunc | null,
                pid_callback: DesktopAppLaunchCallback | null,
                stdin_fd: number,
                stdout_fd: number,
                stderr_fd: number
            ): boolean;
            /**
             * Returns the list of "additional application actions" supported on the
             * desktop file, as per the desktop file specification.
             *
             * As per the specification, this is the list of actions that are
             * explicitly listed in the "Actions" key of the [Desktop Entry] group.
             */
            list_actions(): string[];
            /**
             * Gets all applications that implement `interface.`
             *
             * An application implements an interface if that interface is listed in
             * the Implements= line of the desktop file of the application.
             */
            static get_implementations(_interface: string): DesktopAppInfo[];
            /**
             * Searches desktop files for ones that match `search_string.`
             *
             * The return value is an array of strvs.  Each strv contains a list of
             * applications that matched `search_string `with an equal score.  The
             * outer list is sorted by score so that the first strv contains the
             * best-matching applications, and so on.
             * The algorithm for determining matches is undefined and may change at
             * any time.
             *
             * None of the search results are subjected to the normal validation
             * checks performed by g_desktop_app_info_new() (for example, checking that
             * the executable referenced by a result exists), and so it is possible for
             * g_desktop_app_info_new() to return %NULL when passed an app ID returned by
             * this function. It is expected that calling code will do this when
             * subsequently creating a #GDesktopAppInfo for each result.
             */
            static search(search_string: string): string[][];
            /**
             * Sets the name of the desktop that the application is running in.
             * This is used by g_app_info_should_show() and
             * g_desktop_app_info_get_show_in() to evaluate the
             * `OnlyShowIn` and `NotShowIn`
             * desktop entry fields.
             *
             * Should be called only once; subsequent calls are ignored.
             */
            static set_desktop_env(desktop_env: string): void;

            // Implemented Members

            /**
             * Adds a content type to the application information to indicate the
             * application is capable of opening files with the given content type.
             */
            add_supports_type(content_type: string): boolean;
            /**
             * Obtains the information whether the #GAppInfo can be deleted.
             * See g_app_info_delete().
             */
            can_delete(): boolean;
            /**
             * Checks if a supported content type can be removed from an application.
             */
            can_remove_supports_type(): boolean;
            /**
             * Tries to delete a #GAppInfo.
             *
             * On some platforms, there may be a difference between user-defined
             * #GAppInfos which can be deleted, and system-wide ones which cannot.
             * See g_app_info_can_delete().
             */
            ["delete"](): boolean;
            /**
             * Creates a duplicate of a #GAppInfo.
             */
            dup(): AppInfo;
            /**
             * Checks if two #GAppInfos are equal.
             *
             * Note that the check *may not* compare each individual
             * field, and only does an identity check. In case detecting changes in the
             * contents is needed, program code must additionally compare relevant fields.
             */
            equal(appinfo2: AppInfo): boolean;
            /**
             * Gets the commandline with which the application will be
             * started.
             */
            get_commandline(): string | null;
            /**
             * Gets a human-readable description of an installed application.
             */
            get_description(): string | null;
            /**
             * Gets the display name of the application. The display name is often more
             * descriptive to the user than the name itself.
             */
            get_display_name(): string;
            /**
             * Gets the executable's name for the installed application.
             *
             * This is intended to be used for debugging or labelling what program is going
             * to be run. To launch the executable, use g_app_info_launch() and related
             * functions, rather than spawning the return value from this function.
             */
            get_executable(): string;
            /**
             * Gets the icon for the application.
             */
            get_icon(): Icon | null;
            /**
             * Gets the ID of an application. An id is a string that
             * identifies the application. The exact format of the id is
             * platform dependent. For instance, on Unix this is the
             * desktop file id from the xdg menu specification.
             *
             * Note that the returned ID may be %NULL, depending on how
             * the `appinfo `has been constructed.
             */
            get_id(): string | null;
            /**
             * Gets the installed name of the application.
             */
            get_name(): string;
            /**
             * Retrieves the list of content types that `app_info `claims to support.
             * If this information is not provided by the environment, this function
             * will return %NULL.
             * This function does not take in consideration associations added with
             * g_app_info_add_supports_type(), but only those exported directly by
             * the application.
             */
            get_supported_types(): string[];
            /**
             * Launches the application. Passes `files `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly.
             *
             * To launch the application without arguments pass a %NULL `files `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             *
             * Some URIs can be changed when passed through a GFile (for instance
             * unsupported URIs with strange formats like mailto:), so if you have
             * a textual URI you want to pass in as argument, consider using
             * g_app_info_launch_uris() instead.
             *
             * The launched application inherits the environment of the launching
             * process, but it can be modified with g_app_launch_context_setenv()
             * and g_app_launch_context_unsetenv().
             *
             * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
             * environment variable with the path of the launched desktop file and
             * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
             * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
             * should it be inherited by further processes. The `DISPLAY`,
             * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
             * variables are also set, based on information provided in `context.`
             */
            launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Launches the application. This passes the `uris `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly. If the application only supports
             * one URI per invocation as part of their command-line, multiple instances
             * of the application will be spawned.
             *
             * To launch the application without arguments pass a %NULL `uris `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             */
            launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            launch_uris_async(
                uris: string[] | null,
                context: AppLaunchContext | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a g_app_info_launch_uris_async() operation.
             */
            launch_uris_finish(result: AsyncResult): boolean;
            /**
             * Removes a supported type from an application, if possible.
             */
            remove_supports_type(content_type: string): boolean;
            /**
             * Sets the application as the default handler for the given file extension.
             */
            set_as_default_for_extension(extension: string): boolean;
            /**
             * Sets the application as the default handler for a given type.
             */
            set_as_default_for_type(content_type: string): boolean;
            /**
             * Sets the application as the last used application for a given type.
             * This will make the application appear as first in the list returned
             * by g_app_info_get_recommended_for_type(), regardless of the default
             * application for that content type.
             */
            set_as_last_used_for_type(content_type: string): boolean;
            /**
             * Checks if the application info should be shown in menus that
             * list available applications.
             */
            should_show(): boolean;
            /**
             * Checks if the application accepts files as arguments.
             */
            supports_files(): boolean;
            /**
             * Checks if the application supports reading files and directories from URIs.
             */
            supports_uris(): boolean;
            /**
             * Adds a content type to the application information to indicate the
             * application is capable of opening files with the given content type.
             */
            vfunc_add_supports_type(content_type: string): boolean;
            /**
             * Obtains the information whether the #GAppInfo can be deleted.
             * See g_app_info_delete().
             */
            vfunc_can_delete(): boolean;
            /**
             * Checks if a supported content type can be removed from an application.
             */
            vfunc_can_remove_supports_type(): boolean;
            /**
             * Tries to delete a #GAppInfo.
             *
             * On some platforms, there may be a difference between user-defined
             * #GAppInfos which can be deleted, and system-wide ones which cannot.
             * See g_app_info_can_delete().
             */
            vfunc_do_delete(): boolean;
            /**
             * Creates a duplicate of a #GAppInfo.
             */
            vfunc_dup(): AppInfo;
            /**
             * Checks if two #GAppInfos are equal.
             *
             * Note that the check *may not* compare each individual
             * field, and only does an identity check. In case detecting changes in the
             * contents is needed, program code must additionally compare relevant fields.
             */
            vfunc_equal(appinfo2: AppInfo): boolean;
            /**
             * Gets the commandline with which the application will be
             * started.
             */
            vfunc_get_commandline(): string | null;
            /**
             * Gets a human-readable description of an installed application.
             */
            vfunc_get_description(): string | null;
            /**
             * Gets the display name of the application. The display name is often more
             * descriptive to the user than the name itself.
             */
            vfunc_get_display_name(): string;
            /**
             * Gets the executable's name for the installed application.
             *
             * This is intended to be used for debugging or labelling what program is going
             * to be run. To launch the executable, use g_app_info_launch() and related
             * functions, rather than spawning the return value from this function.
             */
            vfunc_get_executable(): string;
            /**
             * Gets the icon for the application.
             */
            vfunc_get_icon(): Icon | null;
            /**
             * Gets the ID of an application. An id is a string that
             * identifies the application. The exact format of the id is
             * platform dependent. For instance, on Unix this is the
             * desktop file id from the xdg menu specification.
             *
             * Note that the returned ID may be %NULL, depending on how
             * the `appinfo `has been constructed.
             */
            vfunc_get_id(): string | null;
            /**
             * Gets the installed name of the application.
             */
            vfunc_get_name(): string;
            /**
             * Retrieves the list of content types that `app_info `claims to support.
             * If this information is not provided by the environment, this function
             * will return %NULL.
             * This function does not take in consideration associations added with
             * g_app_info_add_supports_type(), but only those exported directly by
             * the application.
             */
            vfunc_get_supported_types(): string[];
            /**
             * Launches the application. Passes `files `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly.
             *
             * To launch the application without arguments pass a %NULL `files `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             *
             * Some URIs can be changed when passed through a GFile (for instance
             * unsupported URIs with strange formats like mailto:), so if you have
             * a textual URI you want to pass in as argument, consider using
             * g_app_info_launch_uris() instead.
             *
             * The launched application inherits the environment of the launching
             * process, but it can be modified with g_app_launch_context_setenv()
             * and g_app_launch_context_unsetenv().
             *
             * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
             * environment variable with the path of the launched desktop file and
             * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
             * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
             * should it be inherited by further processes. The `DISPLAY`,
             * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
             * variables are also set, based on information provided in `context.`
             */
            vfunc_launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Launches the application. This passes the `uris `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly. If the application only supports
             * one URI per invocation as part of their command-line, multiple instances
             * of the application will be spawned.
             *
             * To launch the application without arguments pass a %NULL `uris `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             */
            vfunc_launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            vfunc_launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            vfunc_launch_uris_async(
                uris: string[] | null,
                context: AppLaunchContext | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            vfunc_launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a g_app_info_launch_uris_async() operation.
             */
            vfunc_launch_uris_finish(result: AsyncResult): boolean;
            /**
             * Removes a supported type from an application, if possible.
             */
            vfunc_remove_supports_type(content_type: string): boolean;
            /**
             * Sets the application as the default handler for the given file extension.
             */
            vfunc_set_as_default_for_extension(extension: string): boolean;
            /**
             * Sets the application as the default handler for a given type.
             */
            vfunc_set_as_default_for_type(content_type: string): boolean;
            /**
             * Sets the application as the last used application for a given type.
             * This will make the application appear as first in the list returned
             * by g_app_info_get_recommended_for_type(), regardless of the default
             * application for that content type.
             */
            vfunc_set_as_last_used_for_type(content_type: string): boolean;
            /**
             * Checks if the application info should be shown in menus that
             * list available applications.
             */
            vfunc_should_show(): boolean;
            /**
             * Checks if the application accepts files as arguments.
             */
            vfunc_supports_files(): boolean;
            /**
             * Checks if the application supports reading files and directories from URIs.
             */
            vfunc_supports_uris(): boolean;
        }
        export module Emblem {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                icon: GObject.Object;
                origin: EmblemOrigin;
            }
        }
        export class Emblem extends GObject.Object implements Icon {
            static $gtype: GObject.GType<Emblem>;

            constructor(properties?: Partial<Emblem.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Emblem.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get icon(): GObject.Object;
            get origin(): EmblemOrigin;

            // Constructors

            static ["new"](icon: Icon): Emblem;
            static new_with_origin(icon: Icon, origin: EmblemOrigin): Emblem;

            // Members

            /**
             * Gives back the icon from `emblem.`
             */
            get_icon(): Icon;
            /**
             * Gets the origin of the emblem.
             */
            get_origin(): EmblemOrigin;

            // Implemented Members

            /**
             * Checks if two icons are equal.
             */
            equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            serialize(): GLib.Variant | null;
            /**
             * Generates a textual representation of `icon `that can be used for
             * serialization such as when passing `icon `to a different process or
             * saving it to persistent storage. Use g_icon_new_for_string() to
             * get `icon `back from the returned string.
             *
             * The encoding of the returned string is proprietary to #GIcon except
             * in the following two cases
             *
             * - If `icon `is a #GFileIcon, the returned string is a native path
             * (such as `/path/to/my icon.png`) without escaping
             * if the #GFile for `icon `is a native file.  If the file is not
             * native, the returned string is the result of g_file_get_uri()
             * (such as `sftp://path/to/my%20icon.png`).
             *
             * - If `icon `is a #GThemedIcon with exactly one name and no fallbacks,
             * the encoding is simply the name (such as `network-server`).
             */
            to_string(): string | null;
            /**
             * Checks if two icons are equal.
             */
            vfunc_equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            vfunc_hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            vfunc_serialize(): GLib.Variant | null;
            /**
             * Serializes the `icon `into string tokens.
             * This is can be invoked when g_icon_new_for_string() is called.
             */
            vfunc_to_tokens(): [boolean, string[], number];
        }
        export module EmblemedIcon {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                gicon: Icon;
            }
        }
        export class EmblemedIcon extends GObject.Object implements Icon {
            static $gtype: GObject.GType<EmblemedIcon>;

            constructor(properties?: Partial<EmblemedIcon.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<EmblemedIcon.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get gicon(): Icon;

            // Constructors

            static ["new"](icon: Icon, emblem?: Emblem | null): EmblemedIcon;

            // Members

            /**
             * Adds `emblem `to the #GList of #GEmblems.
             */
            add_emblem(emblem: Emblem): void;
            /**
             * Removes all the emblems from `icon.`
             */
            clear_emblems(): void;
            /**
             * Gets the list of emblems for the `icon.`
             */
            get_emblems(): Emblem[];
            /**
             * Gets the main icon for `emblemed.`
             */
            get_icon(): Icon;

            // Implemented Members

            /**
             * Checks if two icons are equal.
             */
            equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            serialize(): GLib.Variant | null;
            /**
             * Generates a textual representation of `icon `that can be used for
             * serialization such as when passing `icon `to a different process or
             * saving it to persistent storage. Use g_icon_new_for_string() to
             * get `icon `back from the returned string.
             *
             * The encoding of the returned string is proprietary to #GIcon except
             * in the following two cases
             *
             * - If `icon `is a #GFileIcon, the returned string is a native path
             * (such as `/path/to/my icon.png`) without escaping
             * if the #GFile for `icon `is a native file.  If the file is not
             * native, the returned string is the result of g_file_get_uri()
             * (such as `sftp://path/to/my%20icon.png`).
             *
             * - If `icon `is a #GThemedIcon with exactly one name and no fallbacks,
             * the encoding is simply the name (such as `network-server`).
             */
            to_string(): string | null;
            /**
             * Checks if two icons are equal.
             */
            vfunc_equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            vfunc_hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            vfunc_serialize(): GLib.Variant | null;
            /**
             * Serializes the `icon `into string tokens.
             * This is can be invoked when g_icon_new_for_string() is called.
             */
            vfunc_to_tokens(): [boolean, string[], number];
        }
        export module FileEnumerator {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                container: File;
            }
        }
        export class FileEnumerator extends GObject.Object {
            static $gtype: GObject.GType<FileEnumerator>;

            constructor(properties?: Partial<FileEnumerator.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileEnumerator.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set container(val: File);

            // Members

            /**
             * Releases all resources used by this enumerator, making the
             * enumerator return %G_IO_ERROR_CLOSED on all calls.
             *
             * This will be automatically called when the last reference
             * is dropped, but you might want to call this function to make
             * sure resources are released as early as possible.
             */
            close(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously closes the file enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
             * g_file_enumerator_close_finish().
             */
            close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously closes the file enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
             * g_file_enumerator_close_finish().
             */
            close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously closes the file enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
             * g_file_enumerator_close_finish().
             */
            close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
             *
             * If the file enumerator was already closed when g_file_enumerator_close_async()
             * was called, then this function will report %G_IO_ERROR_CLOSED in error, and
             * return %FALSE. If the file enumerator had pending operation when the close
             * operation was started, then this function will report %G_IO_ERROR_PENDING, and
             * return %FALSE.  If `cancellable `was not %NULL, then the operation may have been
             * cancelled by triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
             * returned.
             */
            close_finish(result: AsyncResult): boolean;
            /**
             * Return a new #GFile which refers to the file named by `info `in the source
             * directory of `enumerator.`  This function is primarily intended to be used
             * inside loops with g_file_enumerator_next_file().
             *
             * To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
             * attributes list used when creating the #GFileEnumerator.
             *
             * This is a convenience method that's equivalent to:
             * |[&lt;!-- language="C" --&gt;
             * gchar *name = g_file_info_get_name (info);
             * GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
             * name);
             * ]|
             */
            get_child(info: FileInfo): File;
            /**
             * Get the #GFile container which is being enumerated.
             */
            get_container(): File;
            /**
             * Checks if the file enumerator has pending operations.
             */
            has_pending(): boolean;
            /**
             * Checks if the file enumerator has been closed.
             */
            is_closed(): boolean;
            /**
             * This is a version of g_file_enumerator_next_file() that's easier to
             * use correctly from C programs.  With g_file_enumerator_next_file(),
             * the gboolean return value signifies "end of iteration or error", which
             * requires allocation of a temporary #GError.
             *
             * In contrast, with this function, a %FALSE return from
             * g_file_enumerator_iterate() *always* means
             * "error".  End of iteration is signaled by `out_info `or `out_child `being %NULL.
             *
             * Another crucial difference is that the references for `out_info `and
             * `out_child `are owned by `direnum `(they are cached as hidden
             * properties).  You must not unref them in your own code.  This makes
             * memory management significantly easier for C code in combination
             * with loops.
             *
             * Finally, this function optionally allows retrieving a #GFile as
             * well.
             *
             * You must specify at least one of `out_info `or `out_child.`
             *
             * The code pattern for correctly using g_file_enumerator_iterate() from C
             * is:
             *
             * |[
             * direnum = g_file_enumerate_children (file, ...);
             * while (TRUE)
             * {
             * GFileInfo *info;
             * if (!g_file_enumerator_iterate (direnum, &amp;info, NULL, cancellable, error))
             * goto out;
             * if (!info)
             * break;
             * ... do stuff with "info"; do not unref it! ...
             * }
             *
             * out:
             * g_object_unref (direnum); // Note: frees the last info
             * ]|
             */
            iterate(cancellable?: Cancellable | null): [boolean, FileInfo | null, File | null];
            /**
             * Returns information for the next file in the enumerated object.
             * Will block until the information is available. The #GFileInfo
             * returned from this function will contain attributes that match the
             * attribute string that was passed when the #GFileEnumerator was created.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * On error, returns %NULL and sets `error `to the error. If the
             * enumerator is at the end, %NULL will be returned and `error `will
             * be unset.
             */
            next_file(cancellable?: Cancellable | null): FileInfo | null;
            /**
             * Request information for a number of files from the enumerator asynchronously.
             * When all i/o for the operation is finished the `callback `will be called with
             * the requested information.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * The callback can be called with less than `num_files `files in case of error
             * or at the end of the enumerator. In case of a partial error the callback will
             * be called with any succeeding items and no error, and on the next request the
             * error will be reported. If a request is cancelled the callback will be called
             * with %G_IO_ERROR_CANCELLED.
             *
             * During an async request no other sync and async calls are allowed, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             */
            next_files_async(
                num_files: number,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo[]>;
            /**
             * Request information for a number of files from the enumerator asynchronously.
             * When all i/o for the operation is finished the `callback `will be called with
             * the requested information.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * The callback can be called with less than `num_files `files in case of error
             * or at the end of the enumerator. In case of a partial error the callback will
             * be called with any succeeding items and no error, and on the next request the
             * error will be reported. If a request is cancelled the callback will be called
             * with %G_IO_ERROR_CANCELLED.
             *
             * During an async request no other sync and async calls are allowed, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             */
            next_files_async(
                num_files: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request information for a number of files from the enumerator asynchronously.
             * When all i/o for the operation is finished the `callback `will be called with
             * the requested information.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * The callback can be called with less than `num_files `files in case of error
             * or at the end of the enumerator. In case of a partial error the callback will
             * be called with any succeeding items and no error, and on the next request the
             * error will be reported. If a request is cancelled the callback will be called
             * with %G_IO_ERROR_CANCELLED.
             *
             * During an async request no other sync and async calls are allowed, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             */
            next_files_async(
                num_files: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo[]> | void;
            /**
             * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
             */
            next_files_finish(result: AsyncResult): FileInfo[];
            /**
             * Sets the file enumerator as having pending operations.
             */
            set_pending(pending: boolean): void;
            /**
             * Asynchronously closes the file enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
             * g_file_enumerator_close_finish().
             */
            vfunc_close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously closes the file enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
             * g_file_enumerator_close_finish().
             */
            vfunc_close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously closes the file enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
             * g_file_enumerator_close_finish().
             */
            vfunc_close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
             *
             * If the file enumerator was already closed when g_file_enumerator_close_async()
             * was called, then this function will report %G_IO_ERROR_CLOSED in error, and
             * return %FALSE. If the file enumerator had pending operation when the close
             * operation was started, then this function will report %G_IO_ERROR_PENDING, and
             * return %FALSE.  If `cancellable `was not %NULL, then the operation may have been
             * cancelled by triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
             * returned.
             */
            vfunc_close_finish(result: AsyncResult): boolean;
            vfunc_close_fn(cancellable?: Cancellable | null): boolean;
            /**
             * Returns information for the next file in the enumerated object.
             * Will block until the information is available. The #GFileInfo
             * returned from this function will contain attributes that match the
             * attribute string that was passed when the #GFileEnumerator was created.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * On error, returns %NULL and sets `error `to the error. If the
             * enumerator is at the end, %NULL will be returned and `error `will
             * be unset.
             */
            vfunc_next_file(cancellable?: Cancellable | null): FileInfo | null;
            /**
             * Request information for a number of files from the enumerator asynchronously.
             * When all i/o for the operation is finished the `callback `will be called with
             * the requested information.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * The callback can be called with less than `num_files `files in case of error
             * or at the end of the enumerator. In case of a partial error the callback will
             * be called with any succeeding items and no error, and on the next request the
             * error will be reported. If a request is cancelled the callback will be called
             * with %G_IO_ERROR_CANCELLED.
             *
             * During an async request no other sync and async calls are allowed, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             */
            vfunc_next_files_async(
                num_files: number,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo[]>;
            /**
             * Request information for a number of files from the enumerator asynchronously.
             * When all i/o for the operation is finished the `callback `will be called with
             * the requested information.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * The callback can be called with less than `num_files `files in case of error
             * or at the end of the enumerator. In case of a partial error the callback will
             * be called with any succeeding items and no error, and on the next request the
             * error will be reported. If a request is cancelled the callback will be called
             * with %G_IO_ERROR_CANCELLED.
             *
             * During an async request no other sync and async calls are allowed, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             */
            vfunc_next_files_async(
                num_files: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request information for a number of files from the enumerator asynchronously.
             * When all i/o for the operation is finished the `callback `will be called with
             * the requested information.
             *
             * See the documentation of #GFileEnumerator for information about the
             * order of returned files.
             *
             * The callback can be called with less than `num_files `files in case of error
             * or at the end of the enumerator. In case of a partial error the callback will
             * be called with any succeeding items and no error, and on the next request the
             * error will be reported. If a request is cancelled the callback will be called
             * with %G_IO_ERROR_CANCELLED.
             *
             * During an async request no other sync and async calls are allowed, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             */
            vfunc_next_files_async(
                num_files: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo[]> | void;
            /**
             * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
             */
            vfunc_next_files_finish(result: AsyncResult): FileInfo[];
        }
        export module FileIOStream {
            export interface ConstructorProperties extends IOStream.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class FileIOStream extends IOStream implements Seekable {
            static $gtype: GObject.GType<FileIOStream>;

            constructor(properties?: Partial<FileIOStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileIOStream.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Gets the entity tag for the file when it has been written.
             * This must be called after the stream has been written
             * and closed, as the etag can change while writing.
             */
            get_etag(): string | null;
            /**
             * Queries a file io stream for the given `attributes.`
             * This function blocks while querying the stream. For the asynchronous
             * version of this function, see g_file_io_stream_query_info_async().
             * While the stream is blocked, the stream will set the pending flag
             * internally, and any other operations on the stream will fail with
             * %G_IO_ERROR_PENDING.
             *
             * Can fail if the stream was already closed (with `error `being set to
             * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error `being
             * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
             * the stream's interface (with `error `being set to %G_IO_ERROR_NOT_SUPPORTED). I
             * all cases of failure, %NULL will be returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
             * be returned.
             */
            query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_io_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_io_stream_query_info().
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_io_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_io_stream_query_info().
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_io_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_io_stream_query_info().
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finalizes the asynchronous query started
             * by g_file_io_stream_query_info_async().
             */
            query_info_finish(result: AsyncResult): FileInfo;
            vfunc_can_seek(): boolean;
            vfunc_can_truncate(): boolean;
            /**
             * Gets the entity tag for the file when it has been written.
             * This must be called after the stream has been written
             * and closed, as the etag can change while writing.
             */
            vfunc_get_etag(): string | null;
            /**
             * Queries a file io stream for the given `attributes.`
             * This function blocks while querying the stream. For the asynchronous
             * version of this function, see g_file_io_stream_query_info_async().
             * While the stream is blocked, the stream will set the pending flag
             * internally, and any other operations on the stream will fail with
             * %G_IO_ERROR_PENDING.
             *
             * Can fail if the stream was already closed (with `error `being set to
             * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error `being
             * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
             * the stream's interface (with `error `being set to %G_IO_ERROR_NOT_SUPPORTED). I
             * all cases of failure, %NULL will be returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
             * be returned.
             */
            vfunc_query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_io_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_io_stream_query_info().
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_io_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_io_stream_query_info().
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_io_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_io_stream_query_info().
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finalizes the asynchronous query started
             * by g_file_io_stream_query_info_async().
             */
            vfunc_query_info_finish(result: AsyncResult): FileInfo;
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            vfunc_tell(): number;
            vfunc_truncate_fn(size: number, cancellable?: Cancellable | null): boolean;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module FileIcon {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                file: File;
            }
        }
        export class FileIcon extends GObject.Object implements Icon, LoadableIcon {
            static $gtype: GObject.GType<FileIcon>;

            constructor(properties?: Partial<FileIcon.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileIcon.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get file(): File;

            // Constructors

            static ["new"](file: File): FileIcon;

            // Members

            /**
             * Gets the #GFile associated with the given `icon.`
             */
            get_file(): File;

            // Implemented Members

            /**
             * Checks if two icons are equal.
             */
            equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            serialize(): GLib.Variant | null;
            /**
             * Generates a textual representation of `icon `that can be used for
             * serialization such as when passing `icon `to a different process or
             * saving it to persistent storage. Use g_icon_new_for_string() to
             * get `icon `back from the returned string.
             *
             * The encoding of the returned string is proprietary to #GIcon except
             * in the following two cases
             *
             * - If `icon `is a #GFileIcon, the returned string is a native path
             * (such as `/path/to/my icon.png`) without escaping
             * if the #GFile for `icon `is a native file.  If the file is not
             * native, the returned string is the result of g_file_get_uri()
             * (such as `sftp://path/to/my%20icon.png`).
             *
             * - If `icon `is a #GThemedIcon with exactly one name and no fallbacks,
             * the encoding is simply the name (such as `network-server`).
             */
            to_string(): string | null;
            /**
             * Checks if two icons are equal.
             */
            vfunc_equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            vfunc_hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            vfunc_serialize(): GLib.Variant | null;
            /**
             * Serializes the `icon `into string tokens.
             * This is can be invoked when g_icon_new_for_string() is called.
             */
            vfunc_to_tokens(): [boolean, string[], number];
            /**
             * Loads a loadable icon. For the asynchronous version of this function,
             * see g_loadable_icon_load_async().
             */
            load(size: number, cancellable?: Cancellable | null): [InputStream, string];
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(size: number, cancellable?: Cancellable | null): Promise<[InputStream, string]>;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(size: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(
                size: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[InputStream, string]> | void;
            /**
             * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
             */
            load_finish(res: AsyncResult): [InputStream, string];
            /**
             * Loads a loadable icon. For the asynchronous version of this function,
             * see g_loadable_icon_load_async().
             */
            vfunc_load(size: number, cancellable?: Cancellable | null): [InputStream, string];
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(size: number, cancellable?: Cancellable | null): Promise<[InputStream, string]>;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(
                size: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(
                size: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[InputStream, string]> | void;
            /**
             * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
             */
            vfunc_load_finish(res: AsyncResult): [InputStream, string];
        }
        export module FileInfo {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class FileInfo extends GObject.Object {
            static $gtype: GObject.GType<FileInfo>;

            constructor(properties?: Partial<FileInfo.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileInfo.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](): FileInfo;

            // Members

            /**
             * Clears the status information from `info.`
             */
            clear_status(): void;
            /**
             * First clears all of the [GFileAttribute][gio-GFileAttribute] of dest_info,
             * and then copies all of the file attributes from `src_info `to `dest_info.`
             */
            copy_into(dest_info: FileInfo): void;
            /**
             * Duplicates a file info structure.
             */
            dup(): FileInfo;
            /**
             * Gets the access time of the current `info `and returns it as a
             * #GDateTime.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_TIME_ACCESS. If %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is
             * provided, the resulting #GDateTime will additionally have microsecond
             * precision.
             *
             * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC must
             * be queried separately using g_file_info_get_attribute_uint32().
             */
            get_access_date_time(): GLib.DateTime | null;
            /**
             * Gets the value of an attribute, formatted as a string.
             * This escapes things as needed to make the string valid
             * UTF-8.
             */
            get_attribute_as_string(attribute: string): string | null;
            /**
             * Gets the value of a boolean attribute. If the attribute does not
             * contain a boolean value, %FALSE will be returned.
             */
            get_attribute_boolean(attribute: string): boolean;
            /**
             * Gets the value of a byte string attribute. If the attribute does
             * not contain a byte string, %NULL will be returned.
             */
            get_attribute_byte_string(attribute: string): string | null;
            /**
             * Gets the attribute type, value and status for an attribute key.
             */
            get_attribute_data(attribute: string): [boolean, FileAttributeType | null, any, FileAttributeStatus | null];
            /**
             * Gets a signed 32-bit integer contained within the attribute. If the
             * attribute does not contain a signed 32-bit integer, or is invalid,
             * 0 will be returned.
             */
            get_attribute_int32(attribute: string): number;
            /**
             * Gets a signed 64-bit integer contained within the attribute. If the
             * attribute does not contain a signed 64-bit integer, or is invalid,
             * 0 will be returned.
             */
            get_attribute_int64(attribute: string): number;
            /**
             * Gets the value of a #GObject attribute. If the attribute does
             * not contain a #GObject, %NULL will be returned.
             */
            get_attribute_object<T = GObject.Object>(attribute: string): T;
            /**
             * Gets the attribute status for an attribute key.
             */
            get_attribute_status(attribute: string): FileAttributeStatus;
            /**
             * Gets the value of a string attribute. If the attribute does
             * not contain a string, %NULL will be returned.
             */
            get_attribute_string(attribute: string): string | null;
            /**
             * Gets the value of a stringv attribute. If the attribute does
             * not contain a stringv, %NULL will be returned.
             */
            get_attribute_stringv(attribute: string): string[] | null;
            /**
             * Gets the attribute type for an attribute key.
             */
            get_attribute_type(attribute: string): FileAttributeType;
            /**
             * Gets an unsigned 32-bit integer contained within the attribute. If the
             * attribute does not contain an unsigned 32-bit integer, or is invalid,
             * 0 will be returned.
             */
            get_attribute_uint32(attribute: string): number;
            /**
             * Gets a unsigned 64-bit integer contained within the attribute. If the
             * attribute does not contain an unsigned 64-bit integer, or is invalid,
             * 0 will be returned.
             */
            get_attribute_uint64(attribute: string): number;
            /**
             * Gets the file's content type.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
             */
            get_content_type(): string | null;
            /**
             * Gets the creation time of the current `info `and returns it as a
             * #GDateTime.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_TIME_CREATED. If %G_FILE_ATTRIBUTE_TIME_CREATED_USEC is
             * provided, the resulting #GDateTime will additionally have microsecond
             * precision.
             *
             * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC must
             * be queried separately using g_file_info_get_attribute_uint32().
             */
            get_creation_date_time(): GLib.DateTime | null;
            /**
             * Returns the #GDateTime representing the deletion date of the file, as
             * available in %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
             * %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.
             */
            get_deletion_date(): GLib.DateTime | null;
            /**
             * Gets a display name for a file. This is guaranteed to always be set.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
             */
            get_display_name(): string;
            /**
             * Gets the edit name for a file.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
             */
            get_edit_name(): string;
            /**
             * Gets the [entity tag][gfile-etag] for a given
             * #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_ETAG_VALUE.
             */
            get_etag(): string | null;
            /**
             * Gets a file's type (whether it is a regular file, symlink, etc).
             * This is different from the file's content type, see g_file_info_get_content_type().
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_TYPE.
             */
            get_file_type(): FileType;
            /**
             * Gets the icon for a file.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_ICON.
             */
            get_icon(): Icon | null;
            /**
             * Checks if a file is a backup file.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
             */
            get_is_backup(): boolean;
            /**
             * Checks if a file is hidden.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
             */
            get_is_hidden(): boolean;
            /**
             * Checks if a file is a symlink.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
             */
            get_is_symlink(): boolean;
            /**
             * Gets the modification time of the current `info `and returns it as a
             * #GDateTime.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
             * provided, the resulting #GDateTime will additionally have microsecond
             * precision.
             *
             * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC must
             * be queried separately using g_file_info_get_attribute_uint32().
             */
            get_modification_date_time(): GLib.DateTime | null;
            /**
             * Gets the modification time of the current `info `and sets it
             * in `result.`
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
             * provided it will be used too.
             */
            get_modification_time(): GLib.TimeVal;
            /**
             * Gets the name for a file. This is guaranteed to always be set.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_NAME.
             */
            get_name(): string;
            /**
             * Gets the file's size (in bytes). The size is retrieved through the value of
             * the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
             * from #guint64 to #goffset before returning the result.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_SIZE.
             */
            get_size(): number;
            /**
             * Gets the value of the sort_order attribute from the #GFileInfo.
             * See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
             */
            get_sort_order(): number;
            /**
             * Gets the symbolic icon for a file.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
             */
            get_symbolic_icon(): Icon | null;
            /**
             * Gets the symlink target for a given #GFileInfo.
             *
             * It is an error to call this if the #GFileInfo does not contain
             * %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
             */
            get_symlink_target(): string | null;
            /**
             * Checks if a file info structure has an attribute named `attribute.`
             */
            has_attribute(attribute: string): boolean;
            /**
             * Checks if a file info structure has an attribute in the
             * specified `name_space.`
             */
            has_namespace(name_space: string): boolean;
            /**
             * Lists the file info structure's attributes.
             */
            list_attributes(name_space?: string | null): string[] | null;
            /**
             * Removes all cases of `attribute `from `info `if it exists.
             */
            remove_attribute(attribute: string): void;
            /**
             * Sets the %G_FILE_ATTRIBUTE_TIME_ACCESS and
             * %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the
             * given date/time value.
             *
             * %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC will be cleared.
             */
            set_access_date_time(atime: GLib.DateTime): void;
            /**
             * Sets the `attribute `to contain the given value, if possible. To unset the
             * attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for `type.`
             */
            set_attribute(attribute: string, type: FileAttributeType, value_p: any): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_boolean(attribute: string, attr_value: boolean): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_byte_string(attribute: string, attr_value: string): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_int32(attribute: string, attr_value: number): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_int64(attribute: string, attr_value: number): void;
            /**
             * Sets `mask `on `info `to match specific attribute types.
             */
            set_attribute_mask(mask: FileAttributeMatcher): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_object(attribute: string, attr_value: GObject.Object): void;
            /**
             * Sets the attribute status for an attribute key. This is only
             * needed by external code that implement g_file_set_attributes_from_info()
             * or similar functions.
             *
             * The attribute must exist in `info `for this to work. Otherwise %FALSE
             * is returned and `info `is unchanged.
             */
            set_attribute_status(attribute: string, status: FileAttributeStatus): boolean;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_string(attribute: string, attr_value: string): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             *
             * Sinze: 2.22
             */
            set_attribute_stringv(attribute: string, attr_value: string[]): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_uint32(attribute: string, attr_value: number): void;
            /**
             * Sets the `attribute `to contain the given attr_value,
             * if possible.
             */
            set_attribute_uint64(attribute: string, attr_value: number): void;
            /**
             * Sets the content type attribute for a given #GFileInfo.
             * See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
             */
            set_content_type(content_type: string): void;
            /**
             * Sets the %G_FILE_ATTRIBUTE_TIME_CREATED and
             * %G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the
             * given date/time value.
             *
             * %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC will be cleared.
             */
            set_creation_date_time(creation_time: GLib.DateTime): void;
            /**
             * Sets the display name for the current #GFileInfo.
             * See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
             */
            set_display_name(display_name: string): void;
            /**
             * Sets the edit name for the current file.
             * See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
             */
            set_edit_name(edit_name: string): void;
            /**
             * Sets the file type in a #GFileInfo to `type.`
             * See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
             */
            set_file_type(type: FileType): void;
            /**
             * Sets the icon for a given #GFileInfo.
             * See %G_FILE_ATTRIBUTE_STANDARD_ICON.
             */
            set_icon(icon: Icon): void;
            /**
             * Sets the "is_hidden" attribute in a #GFileInfo according to `is_hidden.`
             * See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
             */
            set_is_hidden(is_hidden: boolean): void;
            /**
             * Sets the "is_symlink" attribute in a #GFileInfo according to `is_symlink.`
             * See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
             */
            set_is_symlink(is_symlink: boolean): void;
            /**
             * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
             * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
             * given date/time value.
             *
             * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
             */
            set_modification_date_time(mtime: GLib.DateTime): void;
            /**
             * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
             * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
             * given time value.
             *
             * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
             */
            set_modification_time(mtime: GLib.TimeVal): void;
            /**
             * Sets the name attribute for the current #GFileInfo.
             * See %G_FILE_ATTRIBUTE_STANDARD_NAME.
             */
            set_name(name: string): void;
            /**
             * Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
             * to the given size.
             */
            set_size(size: number): void;
            /**
             * Sets the sort order attribute in the file info structure. See
             * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
             */
            set_sort_order(sort_order: number): void;
            /**
             * Sets the symbolic icon for a given #GFileInfo.
             * See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
             */
            set_symbolic_icon(icon: Icon): void;
            /**
             * Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
             * to the given symlink target.
             */
            set_symlink_target(symlink_target: string): void;
            /**
             * Unsets a mask set by g_file_info_set_attribute_mask(), if one
             * is set.
             */
            unset_attribute_mask(): void;
        }
        export module FileInputStream {
            export interface ConstructorProperties extends InputStream.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class FileInputStream extends InputStream implements Seekable {
            static $gtype: GObject.GType<FileInputStream>;

            constructor(properties?: Partial<FileInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileInputStream.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Queries a file input stream the given `attributes.` This function blocks
             * while querying the stream. For the asynchronous (non-blocking) version
             * of this function, see g_file_input_stream_query_info_async(). While the
             * stream is blocked, the stream will set the pending flag internally, and
             * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
             */
            query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Queries the stream information asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_file_input_stream_query_info_finish()
             * to get the result of the operation.
             *
             * For the synchronous version of this function,
             * see g_file_input_stream_query_info().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Queries the stream information asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_file_input_stream_query_info_finish()
             * to get the result of the operation.
             *
             * For the synchronous version of this function,
             * see g_file_input_stream_query_info().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Queries the stream information asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_file_input_stream_query_info_finish()
             * to get the result of the operation.
             *
             * For the synchronous version of this function,
             * see g_file_input_stream_query_info().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finishes an asynchronous info query operation.
             */
            query_info_finish(result: AsyncResult): FileInfo;
            vfunc_can_seek(): boolean;
            /**
             * Queries a file input stream the given `attributes.` This function blocks
             * while querying the stream. For the asynchronous (non-blocking) version
             * of this function, see g_file_input_stream_query_info_async(). While the
             * stream is blocked, the stream will set the pending flag internally, and
             * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
             */
            vfunc_query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Queries the stream information asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_file_input_stream_query_info_finish()
             * to get the result of the operation.
             *
             * For the synchronous version of this function,
             * see g_file_input_stream_query_info().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Queries the stream information asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_file_input_stream_query_info_finish()
             * to get the result of the operation.
             *
             * For the synchronous version of this function,
             * see g_file_input_stream_query_info().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Queries the stream information asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_file_input_stream_query_info_finish()
             * to get the result of the operation.
             *
             * For the synchronous version of this function,
             * see g_file_input_stream_query_info().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finishes an asynchronous info query operation.
             */
            vfunc_query_info_finish(result: AsyncResult): FileInfo;
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            vfunc_tell(): number;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module FileMonitor {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                cancelled: boolean;
                rate_limit: number;
                rateLimit: number;
            }
        }
        export abstract class FileMonitor extends GObject.Object {
            static $gtype: GObject.GType<FileMonitor>;

            constructor(properties?: Partial<FileMonitor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileMonitor.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get cancelled(): boolean;
            get rate_limit(): number;
            set rate_limit(val: number);
            get rateLimit(): number;
            set rateLimit(val: number);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "changed",
                callback: (_source: this, file: File, other_file: File | null, event_type: FileMonitorEvent) => void
            ): number;
            connect_after(
                signal: "changed",
                callback: (_source: this, file: File, other_file: File | null, event_type: FileMonitorEvent) => void
            ): number;
            emit(signal: "changed", file: File, other_file: File | null, event_type: FileMonitorEvent): void;

            // Members

            /**
             * Cancels a file monitor.
             */
            cancel(): boolean;
            /**
             * Emits the #GFileMonitor::changed signal if a change
             * has taken place. Should be called from file monitor
             * implementations only.
             *
             * Implementations are responsible to call this method from the
             * [thread-default main context][g-main-context-push-thread-default] of the
             * thread that the monitor was created in.
             */
            emit_event(child: File, other_file: File, event_type: FileMonitorEvent): void;
            /**
             * Returns whether the monitor is canceled.
             */
            is_cancelled(): boolean;
            /**
             * Sets the rate limit to which the `monitor `will report
             * consecutive change events to the same file.
             */
            set_rate_limit(limit_msecs: number): void;
            /**
             * Cancels a file monitor.
             */
            vfunc_cancel(): boolean;
            vfunc_changed(file: File, other_file: File, event_type: FileMonitorEvent): void;
        }
        export module FileOutputStream {
            export interface ConstructorProperties extends OutputStream.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class FileOutputStream extends OutputStream implements Seekable {
            static $gtype: GObject.GType<FileOutputStream>;

            constructor(properties?: Partial<FileOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FileOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Gets the entity tag for the file when it has been written.
             * This must be called after the stream has been written
             * and closed, as the etag can change while writing.
             */
            get_etag(): string | null;
            /**
             * Queries a file output stream for the given `attributes.`
             * This function blocks while querying the stream. For the asynchronous
             * version of this function, see g_file_output_stream_query_info_async().
             * While the stream is blocked, the stream will set the pending flag
             * internally, and any other operations on the stream will fail with
             * %G_IO_ERROR_PENDING.
             *
             * Can fail if the stream was already closed (with `error `being set to
             * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error `being
             * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
             * the stream's interface (with `error `being set to %G_IO_ERROR_NOT_SUPPORTED). In
             * all cases of failure, %NULL will be returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
             * be returned.
             */
            query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_output_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_output_stream_query_info().
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_output_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_output_stream_query_info().
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_output_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_output_stream_query_info().
             */
            query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finalizes the asynchronous query started
             * by g_file_output_stream_query_info_async().
             */
            query_info_finish(result: AsyncResult): FileInfo;
            vfunc_can_seek(): boolean;
            vfunc_can_truncate(): boolean;
            /**
             * Gets the entity tag for the file when it has been written.
             * This must be called after the stream has been written
             * and closed, as the etag can change while writing.
             */
            vfunc_get_etag(): string | null;
            /**
             * Queries a file output stream for the given `attributes.`
             * This function blocks while querying the stream. For the asynchronous
             * version of this function, see g_file_output_stream_query_info_async().
             * While the stream is blocked, the stream will set the pending flag
             * internally, and any other operations on the stream will fail with
             * %G_IO_ERROR_PENDING.
             *
             * Can fail if the stream was already closed (with `error `being set to
             * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error `being
             * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
             * the stream's interface (with `error `being set to %G_IO_ERROR_NOT_SUPPORTED). In
             * all cases of failure, %NULL will be returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
             * be returned.
             */
            vfunc_query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_output_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_output_stream_query_info().
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_output_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_output_stream_query_info().
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously queries the `stream `for a #GFileInfo. When completed,
             * `callback `will be called with a #GAsyncResult which can be used to
             * finish the operation with g_file_output_stream_query_info_finish().
             *
             * For the synchronous version of this function, see
             * g_file_output_stream_query_info().
             */
            vfunc_query_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finalizes the asynchronous query started
             * by g_file_output_stream_query_info_async().
             */
            vfunc_query_info_finish(result: AsyncResult): FileInfo;
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            vfunc_tell(): number;
            vfunc_truncate_fn(size: number, cancellable?: Cancellable | null): boolean;

            // Implemented Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module FilenameCompleter {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class FilenameCompleter extends GObject.Object {
            static $gtype: GObject.GType<FilenameCompleter>;

            constructor(properties?: Partial<FilenameCompleter.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FilenameCompleter.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "got-completion-data", callback: (_source: this) => void): number;
            connect_after(signal: "got-completion-data", callback: (_source: this) => void): number;
            emit(signal: "got-completion-data"): void;

            // Constructors

            static ["new"](): FilenameCompleter;

            // Members

            /**
             * Obtains a completion for `initial_text `from `completer.`
             */
            get_completion_suffix(initial_text: string): string | null;
            /**
             * Gets an array of completion strings for a given initial text.
             */
            get_completions(initial_text: string): string[];
            /**
             * If `dirs_only `is %TRUE, `completer `will only
             * complete directory names, and not file names.
             */
            set_dirs_only(dirs_only: boolean): void;
            vfunc_got_completion_data(): void;
        }
        export module FilterInputStream {
            export interface ConstructorProperties extends InputStream.ConstructorProperties {
                [key: string]: any;
                base_stream: InputStream;
                baseStream: InputStream;
                close_base_stream: boolean;
                closeBaseStream: boolean;
            }
        }
        export abstract class FilterInputStream extends InputStream {
            static $gtype: GObject.GType<FilterInputStream>;

            constructor(properties?: Partial<FilterInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FilterInputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get base_stream(): InputStream;
            get baseStream(): InputStream;
            get close_base_stream(): boolean;
            set close_base_stream(val: boolean);
            get closeBaseStream(): boolean;
            set closeBaseStream(val: boolean);

            // Members

            /**
             * Gets the base stream for the filter stream.
             */
            get_base_stream(): InputStream;
            /**
             * Returns whether the base stream will be closed when `stream `is
             * closed.
             */
            get_close_base_stream(): boolean;
            /**
             * Sets whether the base stream will be closed when `stream `is closed.
             */
            set_close_base_stream(close_base: boolean): void;
        }
        export module FilterOutputStream {
            export interface ConstructorProperties extends OutputStream.ConstructorProperties {
                [key: string]: any;
                base_stream: OutputStream;
                baseStream: OutputStream;
                close_base_stream: boolean;
                closeBaseStream: boolean;
            }
        }
        export abstract class FilterOutputStream extends OutputStream {
            static $gtype: GObject.GType<FilterOutputStream>;

            constructor(properties?: Partial<FilterOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<FilterOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get base_stream(): OutputStream;
            get baseStream(): OutputStream;
            get close_base_stream(): boolean;
            get closeBaseStream(): boolean;

            // Members

            /**
             * Gets the base stream for the filter stream.
             */
            get_base_stream(): OutputStream;
            /**
             * Returns whether the base stream will be closed when `stream `is
             * closed.
             */
            get_close_base_stream(): boolean;
            /**
             * Sets whether the base stream will be closed when `stream `is closed.
             */
            set_close_base_stream(close_base: boolean): void;
        }
        export module IOModule {
            export interface ConstructorProperties extends GObject.TypeModule.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class IOModule extends GObject.TypeModule implements GObject.TypePlugin {
            static $gtype: GObject.GType<IOModule>;

            constructor(properties?: Partial<IOModule.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<IOModule.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](filename: string): IOModule;

            // Members

            /**
             * Optional API for GIO modules to implement.
             *
             * Should return a list of all the extension points that may be
             * implemented in this module.
             *
             * This method will not be called in normal use, however it may be
             * called when probing existing modules and recording which extension
             * points that this model is used for. This means we won't have to
             * load and initialize this module unless its needed.
             *
             * If this function is not implemented by the module the module will
             * always be loaded, initialized and then unloaded on application
             * startup so that it can register its extension points during init.
             *
             * Note that a module need not actually implement all the extension
             * points that g_io_module_query() returns, since the exact list of
             * extension may depend on runtime issues. However all extension
             * points actually implemented must be returned by g_io_module_query()
             * (if defined).
             *
             * When installing a module that implements g_io_module_query() you must
             * run gio-querymodules in order to build the cache files required for
             * lazy loading.
             *
             * Since 2.56, this function should be named `g_io_&lt;modulename&gt;_query`, where
             * `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
             * everything after the first dot removed, and with `-` replaced with `_`
             * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
             * Using the new symbol names avoids name clashes when building modules
             * statically. The old symbol names continue to be supported, but cannot be used
             * for static builds.
             */
            static query(): string[];

            // Implemented Members

            /**
             * Calls the `complete_interface_info `function from the
             * #GTypePluginClass of `plugin.` There should be no need to use this
             * function outside of the GObject type system itself.
             */
            complete_interface_info(
                instance_type: GObject.GType,
                interface_type: GObject.GType,
                info: GObject.InterfaceInfo
            ): void;
            /**
             * Calls the `complete_type_info `function from the #GTypePluginClass of `plugin.`
             * There should be no need to use this function outside of the GObject
             * type system itself.
             */
            complete_type_info(
                g_type: GObject.GType,
                info: GObject.TypeInfo,
                value_table: GObject.TypeValueTable
            ): void;
            /**
             * Calls the `unuse_plugin `function from the #GTypePluginClass of
             * `plugin.`  There should be no need to use this function outside of
             * the GObject type system itself.
             */
            unuse(): void;
            /**
             * Calls the `use_plugin `function from the #GTypePluginClass of
             * `plugin.`  There should be no need to use this function outside of
             * the GObject type system itself.
             */
            use(): void;
            // Conflicted with GObject.TypeModule.use
            use(...args: never[]): any;
        }
        export module IOStream {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                closed: boolean;
                input_stream: InputStream;
                inputStream: InputStream;
                output_stream: OutputStream;
                outputStream: OutputStream;
            }
        }
        export abstract class IOStream extends GObject.Object {
            static $gtype: GObject.GType<IOStream>;

            constructor(properties?: Partial<IOStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<IOStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get closed(): boolean;
            get input_stream(): InputStream;
            get inputStream(): InputStream;
            get output_stream(): OutputStream;
            get outputStream(): OutputStream;

            // Members

            /**
             * Clears the pending flag on `stream.`
             */
            clear_pending(): void;
            /**
             * Closes the stream, releasing resources related to it. This will also
             * close the individual input and output streams, if they are not already
             * closed.
             *
             * Once the stream is closed, all other operations will return
             * %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
             * return an error.
             *
             * Closing a stream will automatically flush any outstanding buffers
             * in the stream.
             *
             * Streams will be automatically closed when the last reference
             * is dropped, but you might want to call this function to make sure
             * resources are released as early as possible.
             *
             * Some streams might keep the backing store of the stream (e.g. a file
             * descriptor) open after the stream is closed. See the documentation for
             * the individual stream for details.
             *
             * On failure the first error that happened will be reported, but the
             * close operation will finish as much as possible. A stream that failed
             * to close will still return %G_IO_ERROR_CLOSED for all operations.
             * Still, it is important to check and report the error to the user,
             * otherwise there might be a loss of data as all data might not be written.
             *
             * If `cancellable `is not NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             * Cancelling a close will still leave the stream closed, but some streams
             * can use a faster close that doesn't block to e.g. check errors.
             *
             * The default implementation of this method just calls close on the
             * individual input/output streams.
             */
            close(cancellable?: Cancellable | null): boolean;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_io_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_io_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_io_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_io_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_io_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_io_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Closes a stream.
             */
            close_finish(result: AsyncResult): boolean;
            /**
             * Gets the input stream for this object. This is used
             * for reading.
             */
            get_input_stream(): InputStream;
            /**
             * Gets the output stream for this object. This is used for
             * writing.
             */
            get_output_stream(): OutputStream;
            /**
             * Checks if a stream has pending actions.
             */
            has_pending(): boolean;
            /**
             * Checks if a stream is closed.
             */
            is_closed(): boolean;
            /**
             * Sets `stream `to have actions pending. If the pending flag is
             * already set or `stream `is closed, it will return %FALSE and set
             * `error.`
             */
            set_pending(): boolean;
            /**
             * Asynchronously splice the output stream of stream1 to the input stream of
             * stream2, and splice the output stream of stream2 to the input stream of
             * stream1.
             *
             * When the operation is finished `callback `will be called.
             * You can then call g_io_stream_splice_finish() to get the
             * result of the operation.
             */
            splice_async(
                stream2: IOStream,
                flags: IOStreamSpliceFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_io_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_io_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            vfunc_close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_io_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_io_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            vfunc_close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_io_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_io_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            vfunc_close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Closes a stream.
             */
            vfunc_close_finish(result: AsyncResult): boolean;
            vfunc_close_fn(cancellable?: Cancellable | null): boolean;
            /**
             * Gets the input stream for this object. This is used
             * for reading.
             */
            vfunc_get_input_stream(): InputStream;
            /**
             * Gets the output stream for this object. This is used for
             * writing.
             */
            vfunc_get_output_stream(): OutputStream;
            /**
             * Finishes an asynchronous io stream splice operation.
             */
            static splice_finish(result: AsyncResult): boolean;
        }
        export module InetAddress {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                bytes: any;
                family: SocketFamily;
                is_any: boolean;
                isAny: boolean;
                is_link_local: boolean;
                isLinkLocal: boolean;
                is_loopback: boolean;
                isLoopback: boolean;
                is_mc_global: boolean;
                isMcGlobal: boolean;
                is_mc_link_local: boolean;
                isMcLinkLocal: boolean;
                is_mc_node_local: boolean;
                isMcNodeLocal: boolean;
                is_mc_org_local: boolean;
                isMcOrgLocal: boolean;
                is_mc_site_local: boolean;
                isMcSiteLocal: boolean;
                is_multicast: boolean;
                isMulticast: boolean;
                is_site_local: boolean;
                isSiteLocal: boolean;
            }
        }
        export class InetAddress extends GObject.Object {
            static $gtype: GObject.GType<InetAddress>;

            constructor(properties?: Partial<InetAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<InetAddress.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get bytes(): any;
            get family(): SocketFamily;
            get is_any(): boolean;
            get isAny(): boolean;
            get is_link_local(): boolean;
            get isLinkLocal(): boolean;
            get is_loopback(): boolean;
            get isLoopback(): boolean;
            get is_mc_global(): boolean;
            get isMcGlobal(): boolean;
            get is_mc_link_local(): boolean;
            get isMcLinkLocal(): boolean;
            get is_mc_node_local(): boolean;
            get isMcNodeLocal(): boolean;
            get is_mc_org_local(): boolean;
            get isMcOrgLocal(): boolean;
            get is_mc_site_local(): boolean;
            get isMcSiteLocal(): boolean;
            get is_multicast(): boolean;
            get isMulticast(): boolean;
            get is_site_local(): boolean;
            get isSiteLocal(): boolean;

            // Constructors

            static new_any(family: SocketFamily): InetAddress;
            static new_from_bytes(bytes: Uint8Array | string, family: SocketFamily): InetAddress;
            static new_from_string(string: string): InetAddress;
            static new_loopback(family: SocketFamily): InetAddress;

            // Members

            /**
             * Checks if two #GInetAddress instances are equal, e.g. the same address.
             */
            equal(other_address: InetAddress): boolean;
            /**
             * Gets address's family
             */
            get_family(): SocketFamily;
            /**
             * Tests whether `address `is the "any" address for its family.
             */
            get_is_any(): boolean;
            /**
             * Tests whether `address `is a link-local address (that is, if it
             * identifies a host on a local network that is not connected to the
             * Internet).
             */
            get_is_link_local(): boolean;
            /**
             * Tests whether `address `is the loopback address for its family.
             */
            get_is_loopback(): boolean;
            /**
             * Tests whether `address `is a global multicast address.
             */
            get_is_mc_global(): boolean;
            /**
             * Tests whether `address `is a link-local multicast address.
             */
            get_is_mc_link_local(): boolean;
            /**
             * Tests whether `address `is a node-local multicast address.
             */
            get_is_mc_node_local(): boolean;
            /**
             * Tests whether `address `is an organization-local multicast address.
             */
            get_is_mc_org_local(): boolean;
            /**
             * Tests whether `address `is a site-local multicast address.
             */
            get_is_mc_site_local(): boolean;
            /**
             * Tests whether `address `is a multicast address.
             */
            get_is_multicast(): boolean;
            /**
             * Tests whether `address `is a site-local address such as 10.0.0.1
             * (that is, the address identifies a host on a local network that can
             * not be reached directly from the Internet, but which may have
             * outgoing Internet connectivity via a NAT or firewall).
             */
            get_is_site_local(): boolean;
            /**
             * Gets the size of the native raw binary address for `address.` This
             * is the size of the data that you get from g_inet_address_to_bytes().
             */
            get_native_size(): number;
            /**
             * Converts `address `to string form.
             */
            to_string(): string;
            /**
             * Converts `address `to string form.
             */
            vfunc_to_string(): string;
        }
        export module InetAddressMask {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                address: InetAddress;
                family: SocketFamily;
                length: number;
            }
        }
        export class InetAddressMask extends GObject.Object implements Initable {
            static $gtype: GObject.GType<InetAddressMask>;

            constructor(properties?: Partial<InetAddressMask.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<InetAddressMask.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get address(): InetAddress;
            set address(val: InetAddress);
            get family(): SocketFamily;
            get length(): number;
            set length(val: number);

            // Constructors

            static ["new"](addr: InetAddress, length: number): InetAddressMask;
            static new_from_string(mask_string: string): InetAddressMask;

            // Members

            /**
             * Tests if `mask `and mask2 are the same mask.
             */
            equal(mask2: InetAddressMask): boolean;
            /**
             * Gets mask's base address
             */
            get_address(): InetAddress;
            /**
             * Gets the #GSocketFamily of mask's address
             */
            get_family(): SocketFamily;
            /**
             * Gets mask's length
             */
            get_length(): number;
            /**
             * Tests if `address `falls within the range described by `mask.`
             */
            matches(address: InetAddress): boolean;
            /**
             * Converts `mask `back to its corresponding string form.
             */
            to_string(): string;

            // Implemented Members

            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module InetSocketAddress {
            export interface ConstructorProperties extends SocketAddress.ConstructorProperties {
                [key: string]: any;
                address: InetAddress;
                flowinfo: number;
                port: number;
                scope_id: number;
                scopeId: number;
            }
        }
        export class InetSocketAddress extends SocketAddress implements SocketConnectable {
            static $gtype: GObject.GType<InetSocketAddress>;

            constructor(properties?: Partial<InetSocketAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<InetSocketAddress.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get address(): InetAddress;
            get flowinfo(): number;
            get port(): number;
            get scope_id(): number;
            get scopeId(): number;

            // Constructors

            static ["new"](address: InetAddress, port: number): InetSocketAddress;
            static new_from_string(address: string, port: number): InetSocketAddress;

            // Members

            /**
             * Gets address's #GInetAddress.
             */
            get_address(): InetAddress;
            /**
             * Gets the `sin6_flowinfo` field from address,
             * which must be an IPv6 address.
             */
            get_flowinfo(): number;
            /**
             * Gets address's port.
             */
            get_port(): number;
            /**
             * Gets the `sin6_scope_id` field from address,
             * which must be an IPv6 address.
             */
            get_scope_id(): number;

            // Implemented Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }
        export module InputStream {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class InputStream extends GObject.Object {
            static $gtype: GObject.GType<InputStream>;

            constructor(properties?: Partial<InputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<InputStream.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Clears the pending flag on `stream.`
             */
            clear_pending(): void;
            /**
             * Closes the stream, releasing resources related to it.
             *
             * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
             * Closing a stream multiple times will not return an error.
             *
             * Streams will be automatically closed when the last reference
             * is dropped, but you might want to call this function to make sure
             * resources are released as early as possible.
             *
             * Some streams might keep the backing store of the stream (e.g. a file descriptor)
             * open after the stream is closed. See the documentation for the individual
             * stream for details.
             *
             * On failure the first error that happened will be reported, but the close
             * operation will finish as much as possible. A stream that failed to
             * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
             * is important to check and report the error to the user.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             * Cancelling a close will still leave the stream closed, but some streams
             * can use a faster close that doesn't block to e.g. check errors.
             */
            close(cancellable?: Cancellable | null): boolean;
            /**
             * Requests an asynchronous closes of the stream, releasing resources related to it.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_close_finish() to get the result of the
             * operation.
             *
             * For behaviour details see g_input_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Requests an asynchronous closes of the stream, releasing resources related to it.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_close_finish() to get the result of the
             * operation.
             *
             * For behaviour details see g_input_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous closes of the stream, releasing resources related to it.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_close_finish() to get the result of the
             * operation.
             *
             * For behaviour details see g_input_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
             */
            close_finish(result: AsyncResult): boolean;
            /**
             * Checks if an input stream has pending actions.
             */
            has_pending(): boolean;
            /**
             * Checks if an input stream is closed.
             */
            is_closed(): boolean;
            /**
             * Tries to read `count `bytes from the stream into the buffer starting at
             * `buffer.` Will block during this read.
             *
             * If count is zero returns zero and does nothing. A value of count
             * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * The returned `buffer `is not a nul-terminated string, it can contain nul bytes
             * at any position, and this function doesn't nul-terminate the `buffer.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            read(cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Tries to read `count `bytes from the stream into the buffer starting at
             * `buffer.` Will block during this read.
             *
             * This function is similar to g_input_stream_read(), except it tries to
             * read as many bytes as requested, only stopping on an error or end of stream.
             *
             * On a successful read of `count `bytes, or if we reached the end of the
             * stream,  %TRUE is returned, and `bytes_read `is set to the number of bytes
             * read into `buffer.`
             *
             * If there is an error during the operation %FALSE is returned and error
             * is set to indicate the error status.
             *
             * As a special exception to the normal conventions for functions that
             * use #GError, if this function returns %FALSE (and sets error) then
             * `bytes_read `will be set to the number of bytes that were successfully
             * read before the error was encountered.  This functionality is only
             * available from C.  If you need it from another language then you must
             * write your own loop around g_input_stream_read().
             */
            read_all(cancellable?: Cancellable | null): [boolean, Uint8Array, number];
            /**
             * Request an asynchronous read of `count `bytes from the stream into the
             * buffer starting at `buffer.`
             *
             * This is the asynchronous equivalent of g_input_stream_read_all().
             *
             * Call g_input_stream_read_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             */
            read_all_async(io_priority: number, cancellable?: Cancellable | null): [Promise<[number]>, Uint8Array];
            /**
             * Request an asynchronous read of `count `bytes from the stream into the
             * buffer starting at `buffer.`
             *
             * This is the asynchronous equivalent of g_input_stream_read_all().
             *
             * Call g_input_stream_read_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             */
            read_all_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): Uint8Array;
            /**
             * Request an asynchronous read of `count `bytes from the stream into the
             * buffer starting at `buffer.`
             *
             * This is the asynchronous equivalent of g_input_stream_read_all().
             *
             * Call g_input_stream_read_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             */
            read_all_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): [Promise<[number]> | void, Uint8Array];
            /**
             * Finishes an asynchronous stream read operation started with
             * g_input_stream_read_all_async().
             *
             * As a special exception to the normal conventions for functions that
             * use #GError, if this function returns %FALSE (and sets error) then
             * `bytes_read `will be set to the number of bytes that were successfully
             * read before the error was encountered.  This functionality is only
             * available from C.  If you need it from another language then you must
             * write your own loop around g_input_stream_read_async().
             */
            read_all_finish(result: AsyncResult): [boolean, number];
            /**
             * Request an asynchronous read of `count `bytes from the stream into the buffer
             * starting at `buffer.` When the operation is finished `callback `will be called.
             * You can then call g_input_stream_read_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed on stream, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer will be passed to the
             * callback. It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to read
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            read_async(io_priority: number, cancellable?: Cancellable | null): [Promise<number>, Uint8Array];
            /**
             * Request an asynchronous read of `count `bytes from the stream into the buffer
             * starting at `buffer.` When the operation is finished `callback `will be called.
             * You can then call g_input_stream_read_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed on stream, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer will be passed to the
             * callback. It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to read
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            read_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): Uint8Array;
            /**
             * Request an asynchronous read of `count `bytes from the stream into the buffer
             * starting at `buffer.` When the operation is finished `callback `will be called.
             * You can then call g_input_stream_read_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed on stream, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer will be passed to the
             * callback. It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to read
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            read_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): [Promise<number> | void, Uint8Array];
            /**
             * Like g_input_stream_read(), this tries to read `count `bytes from
             * the stream in a blocking fashion. However, rather than reading into
             * a user-supplied buffer, this will create a new #GBytes containing
             * the data that was read. This may be easier to use from language
             * bindings.
             *
             * If count is zero, returns a zero-length #GBytes and does nothing. A
             * value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, a new #GBytes is returned. It is not an error if the
             * size of this object is not the same as the requested size, as it
             * can happen e.g. near the end of a file. A zero-length #GBytes is
             * returned on end of file (or if `count `is zero), but never
             * otherwise.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error %NULL is returned and `error `is set accordingly.
             */
            read_bytes(count: number, cancellable?: Cancellable | null): GLib.Bytes;
            /**
             * Request an asynchronous read of `count `bytes from the stream into a
             * new #GBytes. When the operation is finished `callback `will be
             * called. You can then call g_input_stream_read_bytes_finish() to get the
             * result of the operation.
             *
             * During an async request no other sync and async calls are allowed
             * on stream, and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the new #GBytes will be passed to the callback. It is
             * not an error if this is smaller than the requested size, as it can
             * happen e.g. near the end of a file, but generally we try to read as
             * many bytes as requested. Zero is returned on end of file (or if
             * `count `is zero), but never otherwise.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             */
            read_bytes_async(count: number, io_priority: number, cancellable?: Cancellable | null): Promise<GLib.Bytes>;
            /**
             * Request an asynchronous read of `count `bytes from the stream into a
             * new #GBytes. When the operation is finished `callback `will be
             * called. You can then call g_input_stream_read_bytes_finish() to get the
             * result of the operation.
             *
             * During an async request no other sync and async calls are allowed
             * on stream, and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the new #GBytes will be passed to the callback. It is
             * not an error if this is smaller than the requested size, as it can
             * happen e.g. near the end of a file, but generally we try to read as
             * many bytes as requested. Zero is returned on end of file (or if
             * `count `is zero), but never otherwise.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             */
            read_bytes_async(
                count: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous read of `count `bytes from the stream into a
             * new #GBytes. When the operation is finished `callback `will be
             * called. You can then call g_input_stream_read_bytes_finish() to get the
             * result of the operation.
             *
             * During an async request no other sync and async calls are allowed
             * on stream, and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the new #GBytes will be passed to the callback. It is
             * not an error if this is smaller than the requested size, as it can
             * happen e.g. near the end of a file, but generally we try to read as
             * many bytes as requested. Zero is returned on end of file (or if
             * `count `is zero), but never otherwise.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             */
            read_bytes_async(
                count: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<GLib.Bytes> | void;
            /**
             * Finishes an asynchronous stream read-into-#GBytes operation.
             */
            read_bytes_finish(result: AsyncResult): GLib.Bytes;
            /**
             * Finishes an asynchronous stream read operation.
             */
            read_finish(result: AsyncResult): number;
            /**
             * Sets `stream `to have actions pending. If the pending flag is
             * already set or `stream `is closed, it will return %FALSE and set
             * `error.`
             */
            set_pending(): boolean;
            /**
             * Tries to skip `count `bytes from the stream. Will block during the operation.
             *
             * This is identical to g_input_stream_read(), from a behaviour standpoint,
             * but the bytes that are skipped are not returned to the user. Some
             * streams have an implementation that is more efficient than reading the data.
             *
             * This function is optional for inherited classes, as the default implementation
             * emulates it using read.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            skip(count: number, cancellable?: Cancellable | null): number;
            /**
             * Request an asynchronous skip of `count `bytes from the stream.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_skip_finish() to get the result
             * of the operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes skipped will be passed to the callback.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to skip
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero), but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value)
             * will be executed before an outstanding request with lower priority.
             * Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to
             * implement asynchronicity, so they are optional for inheriting classes.
             * However, if you override one, you must override all.
             */
            skip_async(count: number, io_priority: number, cancellable?: Cancellable | null): Promise<number>;
            /**
             * Request an asynchronous skip of `count `bytes from the stream.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_skip_finish() to get the result
             * of the operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes skipped will be passed to the callback.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to skip
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero), but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value)
             * will be executed before an outstanding request with lower priority.
             * Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to
             * implement asynchronicity, so they are optional for inheriting classes.
             * However, if you override one, you must override all.
             */
            skip_async(
                count: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous skip of `count `bytes from the stream.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_skip_finish() to get the result
             * of the operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes skipped will be passed to the callback.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to skip
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero), but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value)
             * will be executed before an outstanding request with lower priority.
             * Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to
             * implement asynchronicity, so they are optional for inheriting classes.
             * However, if you override one, you must override all.
             */
            skip_async(
                count: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes a stream skip operation.
             */
            skip_finish(result: AsyncResult): number;
            /**
             * Requests an asynchronous closes of the stream, releasing resources related to it.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_close_finish() to get the result of the
             * operation.
             *
             * For behaviour details see g_input_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            vfunc_close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Requests an asynchronous closes of the stream, releasing resources related to it.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_close_finish() to get the result of the
             * operation.
             *
             * For behaviour details see g_input_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            vfunc_close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous closes of the stream, releasing resources related to it.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_close_finish() to get the result of the
             * operation.
             *
             * For behaviour details see g_input_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            vfunc_close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
             */
            vfunc_close_finish(result: AsyncResult): boolean;
            vfunc_close_fn(cancellable?: Cancellable | null): boolean;
            /**
             * Request an asynchronous read of `count `bytes from the stream into the buffer
             * starting at `buffer.` When the operation is finished `callback `will be called.
             * You can then call g_input_stream_read_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed on stream, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer will be passed to the
             * callback. It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to read
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            vfunc_read_async(
                io_priority: number,
                cancellable?: Cancellable | null
            ): [Promise<number>, Uint8Array | null];
            /**
             * Request an asynchronous read of `count `bytes from the stream into the buffer
             * starting at `buffer.` When the operation is finished `callback `will be called.
             * You can then call g_input_stream_read_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed on stream, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer will be passed to the
             * callback. It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to read
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            vfunc_read_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): Uint8Array | null;
            /**
             * Request an asynchronous read of `count `bytes from the stream into the buffer
             * starting at `buffer.` When the operation is finished `callback `will be called.
             * You can then call g_input_stream_read_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed on stream, and will
             * result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes read into the buffer will be passed to the
             * callback. It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to read
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero),  but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value) will
             * be executed before an outstanding request with lower priority. Default
             * priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to implement
             * asynchronicity, so they are optional for inheriting classes. However, if you
             * override one you must override all.
             */
            vfunc_read_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): [Promise<number> | void, Uint8Array | null];
            /**
             * Finishes an asynchronous stream read operation.
             */
            vfunc_read_finish(result: AsyncResult): number;
            vfunc_read_fn(buffer: any | null, count: number, cancellable?: Cancellable | null): number;
            /**
             * Tries to skip `count `bytes from the stream. Will block during the operation.
             *
             * This is identical to g_input_stream_read(), from a behaviour standpoint,
             * but the bytes that are skipped are not returned to the user. Some
             * streams have an implementation that is more efficient than reading the data.
             *
             * This function is optional for inherited classes, as the default implementation
             * emulates it using read.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_skip(count: number, cancellable?: Cancellable | null): number;
            /**
             * Request an asynchronous skip of `count `bytes from the stream.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_skip_finish() to get the result
             * of the operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes skipped will be passed to the callback.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to skip
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero), but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value)
             * will be executed before an outstanding request with lower priority.
             * Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to
             * implement asynchronicity, so they are optional for inheriting classes.
             * However, if you override one, you must override all.
             */
            vfunc_skip_async(count: number, io_priority: number, cancellable?: Cancellable | null): Promise<number>;
            /**
             * Request an asynchronous skip of `count `bytes from the stream.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_skip_finish() to get the result
             * of the operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes skipped will be passed to the callback.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to skip
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero), but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value)
             * will be executed before an outstanding request with lower priority.
             * Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to
             * implement asynchronicity, so they are optional for inheriting classes.
             * However, if you override one, you must override all.
             */
            vfunc_skip_async(
                count: number,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous skip of `count `bytes from the stream.
             * When the operation is finished `callback `will be called.
             * You can then call g_input_stream_skip_finish() to get the result
             * of the operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes skipped will be passed to the callback.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. near the end of a file, but generally we try to skip
             * as many bytes as requested. Zero is returned on end of file
             * (or if `count `is zero), but never otherwise.
             *
             * Any outstanding i/o request with higher priority (lower numerical value)
             * will be executed before an outstanding request with lower priority.
             * Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads to
             * implement asynchronicity, so they are optional for inheriting classes.
             * However, if you override one, you must override all.
             */
            vfunc_skip_async(
                count: number,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes a stream skip operation.
             */
            vfunc_skip_finish(result: AsyncResult): number;
        }
        export module ListStore {
            export interface ConstructorProperties<A extends GObject.Object = GObject.Object>
                extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                item_type: GObject.GType;
                itemType: GObject.GType;
                n_items: number;
                nItems: number;
            }
        }
        export class ListStore<A extends GObject.Object = GObject.Object>
            extends GObject.Object
            implements ListModel<A>
        {
            static $gtype: GObject.GType<ListStore>;

            constructor(properties?: Partial<ListStore.ConstructorProperties<A>>, ...args: any[]);
            _init(properties?: Partial<ListStore.ConstructorProperties<A>>, ...args: any[]): void;

            // Properties
            get item_type(): GObject.GType;
            get itemType(): GObject.GType;
            get n_items(): number;
            get nItems(): number;

            // Fields
            [Symbol.iterator]: () => IterableIterator<A>;

            // Constructors

            static ["new"](item_type: GObject.GType): ListStore;

            // Members

            /**
             * Appends `item `to `store.` `item `must be of type #GListStore:item-type.
             *
             * This function takes a ref on `item.`
             *
             * Use g_list_store_splice() to append multiple items at the same time
             * efficiently.
             */
            append(item: A): void;
            /**
             * Looks up the given `item `in the list store by looping over the items until
             * the first occurrence of `item.` If `item `was not found, then `position `will
             * not be set, and this method will return %FALSE.
             *
             * If you need to compare the two items with a custom comparison function, use
             * g_list_store_find_with_equal_func() with a custom #GEqualFunc instead.
             */
            find(item: A): [boolean, number];
            /**
             * Looks up the given `item `in the list store by looping over the items and
             * comparing them with `equal_func `until the first occurrence of `item `which
             * matches. If `item `was not found, then `position `will not be set, and this
             * method will return %FALSE.
             *
             * `item `is always passed as second parameter to `equal_func.`
             *
             * Since GLib 2.76 it is possible to pass `NULL` for `item.`
             */
            find_with_equal_func(item: A | null, equal_func: GLib.EqualFunc): [boolean, number];
            /**
             * Like g_list_store_find_with_equal_func() but with an additional user_data
             * that is passed to `equal_func.`
             *
             * `item `is always passed as second parameter to `equal_func.`
             *
             * Since GLib 2.76 it is possible to pass `NULL` for `item.`
             */
            find_with_equal_func_full(item: A | null, equal_func: GLib.EqualFuncFull): [boolean, number];
            /**
             * Inserts `item `into `store `at `position.` `item `must be of type
             * #GListStore:item-type or derived from it. `position `must be smaller
             * than the length of the list, or equal to it to append.
             *
             * This function takes a ref on `item.`
             *
             * Use g_list_store_splice() to insert multiple items at the same time
             * efficiently.
             */
            insert(position: number, item: A): void;
            /**
             * Inserts `item `into `store `at a position to be determined by the
             * `compare_func.`
             *
             * The list must already be sorted before calling this function or the
             * result is undefined.  Usually you would approach this by only ever
             * inserting items by way of this function.
             *
             * This function takes a ref on `item.`
             */
            insert_sorted(item: A, compare_func: GLib.CompareDataFunc): number;
            /**
             * Removes the item from `store `that is at `position.` `position `must be
             * smaller than the current length of the list.
             *
             * Use g_list_store_splice() to remove multiple items at the same time
             * efficiently.
             */
            remove(position: number): void;
            /**
             * Removes all items from `store.`
             */
            remove_all(): void;
            /**
             * Sort the items in `store `according to `compare_func.`
             */
            sort(compare_func: GLib.CompareDataFunc): void;
            /**
             * Changes `store `by removing `n_removals `items and adding n_additions
             * items to it. `additions `must contain `n_additions `items of type
             * #GListStore:item-type.  %NULL is not permitted.
             *
             * This function is more efficient than g_list_store_insert() and
             * g_list_store_remove(), because it only emits
             * #GListModel::items-changed once for the change.
             *
             * This function takes a ref on each item in `additions.`
             *
             * The parameters `position `and `n_removals `must be correct (ie:
             * `position `+ `n_removals `must be less than or equal to the length of
             * the list at the time this function is called).
             */
            splice(position: number, n_removals: number, additions: A[]): void;

            // Implemented Members

            /**
             * Gets the type of the items in `list.`
             *
             * All items returned from g_list_model_get_item() are of the type
             * returned by this function, or a subtype, or if the type is an
             * interface, they are an implementation of that interface.
             *
             * The item type of a #GListModel can not change during the life of the
             * model.
             */
            get_item_type(): GObject.GType;
            /**
             * Gets the number of items in `list.`
             *
             * Depending on the model implementation, calling this function may be
             * less efficient than iterating the list with increasing values for
             * `position `until g_list_model_get_item() returns %NULL.
             */
            get_n_items(): number;
            /**
             * Get the item at `position.`
             *
             * If `position `is greater than the number of items in list, %NULL is
             * returned.
             *
             * %NULL is never returned for an index that is smaller than the length
             * of the list.
             *
             * This function is meant to be used by language bindings in place
             * of g_list_model_get_item().
             *
             * See also: g_list_model_get_n_items()
             */
            get_item(position: number): A | null;
            /**
             * Emits the #GListModel::items-changed signal on `list.`
             *
             * This function should only be called by classes implementing
             * #GListModel. It has to be called after the internal representation
             * of `list `has been updated, because handlers connected to this signal
             * might query the new state of the list.
             *
             * Implementations must only make changes to the model (as visible to
             * its consumer) in places that will not cause problems for that
             * consumer.  For models that are driven directly by a write API (such
             * as #GListStore), changes can be reported in response to uses of that
             * API.  For models that represent remote data, changes should only be
             * made from a fresh mainloop dispatch.  It is particularly not
             * permitted to make changes in response to a call to the #GListModel
             * consumer API.
             *
             * Stated another way: in general, it is assumed that code making a
             * series of accesses to the model via the API, without returning to the
             * mainloop, and without calling other code, will continue to view the
             * same contents of the model.
             */
            items_changed(position: number, removed: number, added: number): void;
            /**
             * Get the item at `position.` If `position `is greater than the number of
             * items in list, %NULL is returned.
             *
             * %NULL is never returned for an index that is smaller than the length
             * of the list.  See g_list_model_get_n_items().
             */
            vfunc_get_item(position: number): A | null;
            /**
             * Gets the type of the items in `list.`
             *
             * All items returned from g_list_model_get_item() are of the type
             * returned by this function, or a subtype, or if the type is an
             * interface, they are an implementation of that interface.
             *
             * The item type of a #GListModel can not change during the life of the
             * model.
             */
            vfunc_get_item_type(): GObject.GType;
            /**
             * Gets the number of items in `list.`
             *
             * Depending on the model implementation, calling this function may be
             * less efficient than iterating the list with increasing values for
             * `position `until g_list_model_get_item() returns %NULL.
             */
            vfunc_get_n_items(): number;
        }
        export module MemoryInputStream {
            export interface ConstructorProperties extends InputStream.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class MemoryInputStream extends InputStream implements PollableInputStream, Seekable {
            static $gtype: GObject.GType<MemoryInputStream>;

            constructor(properties?: Partial<MemoryInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MemoryInputStream.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](): MemoryInputStream;
            static new_from_bytes(bytes: GLib.Bytes | Uint8Array): MemoryInputStream;
            static new_from_data(data: Uint8Array | string, destroy?: GLib.DestroyNotify | null): MemoryInputStream;

            // Members

            /**
             * Appends `bytes `to data that can be read from the input stream.
             */
            add_bytes(bytes: GLib.Bytes | Uint8Array): void;
            /**
             * Appends `data `to data that can be read from the input stream
             */
            add_data(data: Uint8Array | string, destroy?: GLib.DestroyNotify | null): void;

            // Implemented Members

            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            vfunc_read_nonblocking(): [number, Uint8Array | null];
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module MemoryOutputStream {
            export interface ConstructorProperties extends OutputStream.ConstructorProperties {
                [key: string]: any;
                data: any;
                data_size: number;
                dataSize: number;
                size: number;
            }
        }
        export class MemoryOutputStream extends OutputStream implements PollableOutputStream, Seekable {
            static $gtype: GObject.GType<MemoryOutputStream>;

            constructor(properties?: Partial<MemoryOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MemoryOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get data(): any;
            get data_size(): number;
            get dataSize(): number;
            get size(): number;

            // Constructors

            static new_resizable(): MemoryOutputStream;

            // Members

            /**
             * Gets any loaded data from the `ostream.`
             *
             * Note that the returned pointer may become invalid on the next
             * write or truncate operation on the stream.
             */
            get_data(): any | null;
            /**
             * Returns the number of bytes from the start up to including the last
             * byte written in the stream that has not been truncated away.
             */
            get_data_size(): number;
            /**
             * Gets the size of the currently allocated data area (available from
             * g_memory_output_stream_get_data()).
             *
             * You probably don't want to use this function on resizable streams.
             * See g_memory_output_stream_get_data_size() instead.  For resizable
             * streams the size returned by this function is an implementation
             * detail and may be change at any time in response to operations on the
             * stream.
             *
             * If the stream is fixed-sized (ie: no realloc was passed to
             * g_memory_output_stream_new()) then this is the maximum size of the
             * stream and further writes will return %G_IO_ERROR_NO_SPACE.
             *
             * In any case, if you want the number of bytes currently written to the
             * stream, use g_memory_output_stream_get_data_size().
             */
            get_size(): number;
            /**
             * Returns data from the `ostream `as a #GBytes. `ostream `must be
             * closed before calling this function.
             */
            steal_as_bytes(): GLib.Bytes;
            /**
             * Gets any loaded data from the `ostream.` Ownership of the data
             * is transferred to the caller; when no longer needed it must be
             * freed using the free function set in ostream's
             * #GMemoryOutputStream:destroy-function property.
             *
             * `ostream `must be closed before calling this function.
             */
            steal_data(): any | null;

            // Implemented Members

            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }
        export module Menu {
            export interface ConstructorProperties extends MenuModel.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class Menu extends MenuModel {
            static $gtype: GObject.GType<Menu>;

            constructor(properties?: Partial<Menu.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Menu.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](): Menu;

            // Members

            /**
             * Convenience function for appending a normal menu item to the end of
             * `menu.`  Combine g_menu_item_new() and g_menu_insert_item() for a more
             * flexible alternative.
             */
            append(label?: string | null, detailed_action?: string | null): void;
            /**
             * Appends `item `to the end of `menu.`
             *
             * See g_menu_insert_item() for more information.
             */
            append_item(item: MenuItem): void;
            /**
             * Convenience function for appending a section menu item to the end of
             * `menu.`  Combine g_menu_item_new_section() and g_menu_insert_item() for a
             * more flexible alternative.
             */
            append_section(label: string | null, section: MenuModel): void;
            /**
             * Convenience function for appending a submenu menu item to the end of
             * `menu.`  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
             * more flexible alternative.
             */
            append_submenu(label: string | null, submenu: MenuModel): void;
            /**
             * Marks `menu `as frozen.
             *
             * After the menu is frozen, it is an error to attempt to make any
             * changes to it.  In effect this means that the #GMenu API must no
             * longer be used.
             *
             * This function causes g_menu_model_is_mutable() to begin returning
             * %FALSE, which has some positive performance implications.
             */
            freeze(): void;
            /**
             * Convenience function for inserting a normal menu item into `menu.`
             * Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
             * alternative.
             */
            insert(position: number, label?: string | null, detailed_action?: string | null): void;
            /**
             * Inserts `item `into `menu.`
             *
             * The "insertion" is actually done by copying all of the attribute and
             * link values of `item `and using them to form a new item within `menu.`
             * As such, `item `itself is not really inserted, but rather, a menu item
             * that is exactly the same as the one presently described by `item.`
             *
             * This means that `item `is essentially useless after the insertion
             * occurs.  Any changes you make to it are ignored unless it is inserted
             * again (at which point its updated values will be copied).
             *
             * You should probably just free `item `once you're done.
             *
             * There are many convenience functions to take care of common cases.
             * See g_menu_insert(), g_menu_insert_section() and
             * g_menu_insert_submenu() as well as "prepend" and "append" variants of
             * each of these functions.
             */
            insert_item(position: number, item: MenuItem): void;
            /**
             * Convenience function for inserting a section menu item into `menu.`
             * Combine g_menu_item_new_section() and g_menu_insert_item() for a more
             * flexible alternative.
             */
            insert_section(position: number, label: string | null, section: MenuModel): void;
            /**
             * Convenience function for inserting a submenu menu item into `menu.`
             * Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
             * flexible alternative.
             */
            insert_submenu(position: number, label: string | null, submenu: MenuModel): void;
            /**
             * Convenience function for prepending a normal menu item to the start
             * of `menu.`  Combine g_menu_item_new() and g_menu_insert_item() for a more
             * flexible alternative.
             */
            prepend(label?: string | null, detailed_action?: string | null): void;
            /**
             * Prepends `item `to the start of `menu.`
             *
             * See g_menu_insert_item() for more information.
             */
            prepend_item(item: MenuItem): void;
            /**
             * Convenience function for prepending a section menu item to the start
             * of `menu.`  Combine g_menu_item_new_section() and g_menu_insert_item() for
             * a more flexible alternative.
             */
            prepend_section(label: string | null, section: MenuModel): void;
            /**
             * Convenience function for prepending a submenu menu item to the start
             * of `menu.`  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
             * a more flexible alternative.
             */
            prepend_submenu(label: string | null, submenu: MenuModel): void;
            /**
             * Removes an item from the menu.
             *
             * `position `gives the index of the item to remove.
             *
             * It is an error if position is not in range the range from 0 to one
             * less than the number of items in the menu.
             *
             * It is not possible to remove items by identity since items are added
             * to the menu simply by copying their links and attributes (ie:
             * identity of the item itself is not preserved).
             */
            remove(position: number): void;
            /**
             * Removes all items in the menu.
             */
            remove_all(): void;
        }
        export module MenuAttributeIter {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class MenuAttributeIter extends GObject.Object {
            static $gtype: GObject.GType<MenuAttributeIter>;

            constructor(properties?: Partial<MenuAttributeIter.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MenuAttributeIter.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Gets the name of the attribute at the current iterator position, as
             * a string.
             *
             * The iterator is not advanced.
             */
            get_name(): string;
            /**
             * This function combines g_menu_attribute_iter_next() with
             * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
             *
             * First the iterator is advanced to the next (possibly first) attribute.
             * If that fails, then %FALSE is returned and there are no other
             * effects.
             *
             * If successful, `name `and `value `are set to the name and value of the
             * attribute that has just been advanced to.  At this point,
             * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
             * return the same values again.
             *
             * The value returned in `name `remains valid for as long as the iterator
             * remains at the current position.  The value returned in `value `must
             * be unreffed using g_variant_unref() when it is no longer in use.
             */
            get_next(): [boolean, string, GLib.Variant | null];
            /**
             * Gets the value of the attribute at the current iterator position.
             *
             * The iterator is not advanced.
             */
            get_value(): GLib.Variant;
            /**
             * Attempts to advance the iterator to the next (possibly first)
             * attribute.
             *
             * %TRUE is returned on success, or %FALSE if there are no more
             * attributes.
             *
             * You must call this function when you first acquire the iterator
             * to advance it to the first attribute (and determine if the first
             * attribute exists at all).
             */
            next(): boolean;
            /**
             * This function combines g_menu_attribute_iter_next() with
             * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
             *
             * First the iterator is advanced to the next (possibly first) attribute.
             * If that fails, then %FALSE is returned and there are no other
             * effects.
             *
             * If successful, `name `and `value `are set to the name and value of the
             * attribute that has just been advanced to.  At this point,
             * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
             * return the same values again.
             *
             * The value returned in `name `remains valid for as long as the iterator
             * remains at the current position.  The value returned in `value `must
             * be unreffed using g_variant_unref() when it is no longer in use.
             */
            vfunc_get_next(): [boolean, string, GLib.Variant | null];
        }
        export module MenuItem {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class MenuItem extends GObject.Object {
            static $gtype: GObject.GType<MenuItem>;

            constructor(properties?: Partial<MenuItem.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MenuItem.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](label?: string | null, detailed_action?: string | null): MenuItem;
            static new_from_model(model: MenuModel, item_index: number): MenuItem;
            static new_section(label: string | null, section: MenuModel): MenuItem;
            static new_submenu(label: string | null, submenu: MenuModel): MenuItem;

            // Members

            /**
             * Queries the named `attribute `on `menu_item.`
             *
             * If `expected_type `is specified and the attribute does not have this
             * type, %NULL is returned.  %NULL is also returned if the attribute
             * simply does not exist.
             */
            get_attribute_value(attribute: string, expected_type?: GLib.VariantType | null): GLib.Variant | null;
            /**
             * Queries the named `link `on `menu_item.`
             */
            get_link(link: string): MenuModel | null;
            /**
             * Sets or unsets the "action" and "target" attributes of `menu_item.`
             *
             * If `action `is %NULL then both the "action" and "target" attributes
             * are unset (and `target_value `is ignored).
             *
             * If `action `is non-%NULL then the "action" attribute is set.  The
             * "target" attribute is then set to the value of `target_value `if it is
             * non-%NULL or unset otherwise.
             *
             * Normal menu items (ie: not submenu, section or other custom item
             * types) are expected to have the "action" attribute set to identify
             * the action that they are associated with.  The state type of the
             * action help to determine the disposition of the menu item.  See
             * #GAction and #GActionGroup for an overview of actions.
             *
             * In general, clicking on the menu item will result in activation of
             * the named action with the "target" attribute given as the parameter
             * to the action invocation.  If the "target" attribute is not set then
             * the action is invoked with no parameter.
             *
             * If the action has no state then the menu item is usually drawn as a
             * plain menu item (ie: with no additional decoration).
             *
             * If the action has a boolean state then the menu item is usually drawn
             * as a toggle menu item (ie: with a checkmark or equivalent
             * indication).  The item should be marked as 'toggled' or 'checked'
             * when the boolean state is %TRUE.
             *
             * If the action has a string state then the menu item is usually drawn
             * as a radio menu item (ie: with a radio bullet or equivalent
             * indication).  The item should be marked as 'selected' when the string
             * state is equal to the value of the `target `property.
             *
             * See g_menu_item_set_action_and_target() or
             * g_menu_item_set_detailed_action() for two equivalent calls that are
             * probably more convenient for most uses.
             */
            set_action_and_target_value(action?: string | null, target_value?: GLib.Variant | null): void;
            /**
             * Sets or unsets an attribute on `menu_item.`
             *
             * The attribute to set or unset is specified by `attribute.` This
             * can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
             * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
             * attribute name.
             * Attribute names are restricted to lowercase characters, numbers
             * and '-'. Furthermore, the names must begin with a lowercase character,
             * must not end with a '-', and must not contain consecutive dashes.
             *
             * must consist only of lowercase
             * ASCII characters, digits and '-'.
             *
             * If `value `is non-%NULL then it is used as the new value for the
             * attribute.  If `value `is %NULL then the attribute is unset. If
             * the `value `#GVariant is floating, it is consumed.
             *
             * See also g_menu_item_set_attribute() for a more convenient way to do
             * the same.
             */
            set_attribute_value(attribute: string, value?: GLib.Variant | null): void;
            /**
             * Sets the "action" and possibly the "target" attribute of `menu_item.`
             *
             * The format of `detailed_action `is the same format parsed by
             * g_action_parse_detailed_name().
             *
             * See g_menu_item_set_action_and_target() or
             * g_menu_item_set_action_and_target_value() for more flexible (but
             * slightly less convenient) alternatives.
             *
             * See also g_menu_item_set_action_and_target_value() for a description of
             * the semantics of the action and target attributes.
             */
            set_detailed_action(detailed_action: string): void;
            /**
             * Sets (or unsets) the icon on `menu_item.`
             *
             * This call is the same as calling g_icon_serialize() and using the
             * result as the value to g_menu_item_set_attribute_value() for
             * %G_MENU_ATTRIBUTE_ICON.
             *
             * This API is only intended for use with "noun" menu items; things like
             * bookmarks or applications in an "Open With" menu.  Don't use it on
             * menu items corresponding to verbs (eg: stock icons for 'Save' or
             * 'Quit').
             *
             * If `icon `is %NULL then the icon is unset.
             */
            set_icon(icon: Icon): void;
            /**
             * Sets or unsets the "label" attribute of `menu_item.`
             *
             * If `label `is non-%NULL it is used as the label for the menu item.  If
             * it is %NULL then the label attribute is unset.
             */
            set_label(label?: string | null): void;
            /**
             * Creates a link from `menu_item `to `model `if non-%NULL, or unsets it.
             *
             * Links are used to establish a relationship between a particular menu
             * item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
             * associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
             * is used to create a section. Other types of link can be used, but there
             * is no guarantee that clients will be able to make sense of them.
             * Link types are restricted to lowercase characters, numbers
             * and '-'. Furthermore, the names must begin with a lowercase character,
             * must not end with a '-', and must not contain consecutive dashes.
             */
            set_link(link: string, model?: MenuModel | null): void;
            /**
             * Sets or unsets the "section" link of `menu_item `to `section.`
             *
             * The effect of having one menu appear as a section of another is
             * exactly as it sounds: the items from `section `become a direct part of
             * the menu that `menu_item `is added to.  See g_menu_item_new_section()
             * for more information about what it means for a menu item to be a
             * section.
             */
            set_section(section?: MenuModel | null): void;
            /**
             * Sets or unsets the "submenu" link of `menu_item `to `submenu.`
             *
             * If `submenu `is non-%NULL, it is linked to.  If it is %NULL then the
             * link is unset.
             *
             * The effect of having one menu appear as a submenu of another is
             * exactly as it sounds.
             */
            set_submenu(submenu?: MenuModel | null): void;
        }
        export module MenuLinkIter {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class MenuLinkIter extends GObject.Object {
            static $gtype: GObject.GType<MenuLinkIter>;

            constructor(properties?: Partial<MenuLinkIter.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MenuLinkIter.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Gets the name of the link at the current iterator position.
             *
             * The iterator is not advanced.
             */
            get_name(): string;
            /**
             * This function combines g_menu_link_iter_next() with
             * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
             *
             * First the iterator is advanced to the next (possibly first) link.
             * If that fails, then %FALSE is returned and there are no other effects.
             *
             * If successful, `out_link `and `value `are set to the name and #GMenuModel
             * of the link that has just been advanced to.  At this point,
             * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
             * same values again.
             *
             * The value returned in `out_link `remains valid for as long as the iterator
             * remains at the current position.  The value returned in `value `must
             * be unreffed using g_object_unref() when it is no longer in use.
             */
            get_next(): [boolean, string, MenuModel | null];
            /**
             * Gets the linked #GMenuModel at the current iterator position.
             *
             * The iterator is not advanced.
             */
            get_value(): MenuModel;
            /**
             * Attempts to advance the iterator to the next (possibly first)
             * link.
             *
             * %TRUE is returned on success, or %FALSE if there are no more links.
             *
             * You must call this function when you first acquire the iterator to
             * advance it to the first link (and determine if the first link exists
             * at all).
             */
            next(): boolean;
            /**
             * This function combines g_menu_link_iter_next() with
             * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
             *
             * First the iterator is advanced to the next (possibly first) link.
             * If that fails, then %FALSE is returned and there are no other effects.
             *
             * If successful, `out_link `and `value `are set to the name and #GMenuModel
             * of the link that has just been advanced to.  At this point,
             * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
             * same values again.
             *
             * The value returned in `out_link `remains valid for as long as the iterator
             * remains at the current position.  The value returned in `value `must
             * be unreffed using g_object_unref() when it is no longer in use.
             */
            vfunc_get_next(): [boolean, string, MenuModel | null];
        }
        export module MenuModel {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class MenuModel extends GObject.Object {
            static $gtype: GObject.GType<MenuModel>;

            constructor(properties?: Partial<MenuModel.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MenuModel.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "items-changed",
                callback: (_source: this, position: number, removed: number, added: number) => void
            ): number;
            connect_after(
                signal: "items-changed",
                callback: (_source: this, position: number, removed: number, added: number) => void
            ): number;
            emit(signal: "items-changed", position: number, removed: number, added: number): void;

            // Members

            /**
             * Queries the item at position `item_index `in `model `for the attribute
             * specified by `attribute.`
             *
             * If `expected_type `is non-%NULL then it specifies the expected type of
             * the attribute.  If it is %NULL then any type will be accepted.
             *
             * If the attribute exists and matches `expected_type `(or if the
             * expected type is unspecified) then the value is returned.
             *
             * If the attribute does not exist, or does not match the expected type
             * then %NULL is returned.
             */
            get_item_attribute_value(
                item_index: number,
                attribute: string,
                expected_type?: GLib.VariantType | null
            ): GLib.Variant | null;
            /**
             * Queries the item at position `item_index `in `model `for the link
             * specified by `link.`
             *
             * If the link exists, the linked #GMenuModel is returned.  If the link
             * does not exist, %NULL is returned.
             */
            get_item_link(item_index: number, link: string): MenuModel | null;
            /**
             * Query the number of items in `model.`
             */
            get_n_items(): number;
            /**
             * Queries if `model `is mutable.
             *
             * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
             * signal. Consumers of the model may make optimisations accordingly.
             */
            is_mutable(): boolean;
            /**
             * Requests emission of the #GMenuModel::items-changed signal on `model.`
             *
             * This function should never be called except by #GMenuModel
             * subclasses.  Any other calls to this function will very likely lead
             * to a violation of the interface of the model.
             *
             * The implementation should update its internal representation of the
             * menu before emitting the signal.  The implementation should further
             * expect to receive queries about the new state of the menu (and
             * particularly added menu items) while signal handlers are running.
             *
             * The implementation must dispatch this call directly from a mainloop
             * entry and not in response to calls -- particularly those from the
             * #GMenuModel API.  Said another way: the menu must not change while
             * user code is running without returning to the mainloop.
             */
            items_changed(position: number, removed: number, added: number): void;
            /**
             * Creates a #GMenuAttributeIter to iterate over the attributes of
             * the item at position `item_index `in `model.`
             *
             * You must free the iterator with g_object_unref() when you are done.
             */
            iterate_item_attributes(item_index: number): MenuAttributeIter;
            /**
             * Creates a #GMenuLinkIter to iterate over the links of the item at
             * position `item_index `in `model.`
             *
             * You must free the iterator with g_object_unref() when you are done.
             */
            iterate_item_links(item_index: number): MenuLinkIter;
            /**
             * Queries the item at position `item_index `in `model `for the attribute
             * specified by `attribute.`
             *
             * If `expected_type `is non-%NULL then it specifies the expected type of
             * the attribute.  If it is %NULL then any type will be accepted.
             *
             * If the attribute exists and matches `expected_type `(or if the
             * expected type is unspecified) then the value is returned.
             *
             * If the attribute does not exist, or does not match the expected type
             * then %NULL is returned.
             */
            vfunc_get_item_attribute_value(
                item_index: number,
                attribute: string,
                expected_type?: GLib.VariantType | null
            ): GLib.Variant | null;
            /**
             * Gets all the attributes associated with the item in the menu model.
             */
            vfunc_get_item_attributes(item_index: number): GLib.HashTable<string, GLib.Variant>;
            /**
             * Queries the item at position `item_index `in `model `for the link
             * specified by `link.`
             *
             * If the link exists, the linked #GMenuModel is returned.  If the link
             * does not exist, %NULL is returned.
             */
            vfunc_get_item_link(item_index: number, link: string): MenuModel | null;
            /**
             * Gets all the links associated with the item in the menu model.
             */
            vfunc_get_item_links(item_index: number): GLib.HashTable<string, MenuModel>;
            /**
             * Query the number of items in `model.`
             */
            vfunc_get_n_items(): number;
            /**
             * Queries if `model `is mutable.
             *
             * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
             * signal. Consumers of the model may make optimisations accordingly.
             */
            vfunc_is_mutable(): boolean;
            /**
             * Creates a #GMenuAttributeIter to iterate over the attributes of
             * the item at position `item_index `in `model.`
             *
             * You must free the iterator with g_object_unref() when you are done.
             */
            vfunc_iterate_item_attributes(item_index: number): MenuAttributeIter;
            /**
             * Creates a #GMenuLinkIter to iterate over the links of the item at
             * position `item_index `in `model.`
             *
             * You must free the iterator with g_object_unref() when you are done.
             */
            vfunc_iterate_item_links(item_index: number): MenuLinkIter;
        }
        export module MountOperation {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                anonymous: boolean;
                choice: number;
                domain: string;
                is_tcrypt_hidden_volume: boolean;
                isTcryptHiddenVolume: boolean;
                is_tcrypt_system_volume: boolean;
                isTcryptSystemVolume: boolean;
                password: string;
                password_save: PasswordSave;
                passwordSave: PasswordSave;
                pim: number;
                username: string;
            }
        }
        export class MountOperation extends GObject.Object {
            static $gtype: GObject.GType<MountOperation>;

            constructor(properties?: Partial<MountOperation.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<MountOperation.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get anonymous(): boolean;
            set anonymous(val: boolean);
            get choice(): number;
            set choice(val: number);
            get domain(): string;
            set domain(val: string);
            get is_tcrypt_hidden_volume(): boolean;
            set is_tcrypt_hidden_volume(val: boolean);
            get isTcryptHiddenVolume(): boolean;
            set isTcryptHiddenVolume(val: boolean);
            get is_tcrypt_system_volume(): boolean;
            set is_tcrypt_system_volume(val: boolean);
            get isTcryptSystemVolume(): boolean;
            set isTcryptSystemVolume(val: boolean);
            get password(): string;
            set password(val: string);
            get password_save(): PasswordSave;
            set password_save(val: PasswordSave);
            get passwordSave(): PasswordSave;
            set passwordSave(val: PasswordSave);
            get pim(): number;
            set pim(val: number);
            get username(): string;
            set username(val: string);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "aborted", callback: (_source: this) => void): number;
            connect_after(signal: "aborted", callback: (_source: this) => void): number;
            emit(signal: "aborted"): void;
            connect(
                signal: "ask-password",
                callback: (
                    _source: this,
                    message: string,
                    default_user: string,
                    default_domain: string,
                    flags: AskPasswordFlags
                ) => void
            ): number;
            connect_after(
                signal: "ask-password",
                callback: (
                    _source: this,
                    message: string,
                    default_user: string,
                    default_domain: string,
                    flags: AskPasswordFlags
                ) => void
            ): number;
            emit(
                signal: "ask-password",
                message: string,
                default_user: string,
                default_domain: string,
                flags: AskPasswordFlags
            ): void;
            connect(
                signal: "ask-question",
                callback: (_source: this, message: string, choices: string[]) => void
            ): number;
            connect_after(
                signal: "ask-question",
                callback: (_source: this, message: string, choices: string[]) => void
            ): number;
            emit(signal: "ask-question", message: string, choices: string[]): void;
            connect(signal: "reply", callback: (_source: this, result: MountOperationResult) => void): number;
            connect_after(signal: "reply", callback: (_source: this, result: MountOperationResult) => void): number;
            emit(signal: "reply", result: MountOperationResult): void;
            connect(
                signal: "show-processes",
                callback: (_source: this, message: string, processes: GLib.Pid[], choices: string[]) => void
            ): number;
            connect_after(
                signal: "show-processes",
                callback: (_source: this, message: string, processes: GLib.Pid[], choices: string[]) => void
            ): number;
            emit(signal: "show-processes", message: string, processes: GLib.Pid[], choices: string[]): void;
            connect(
                signal: "show-unmount-progress",
                callback: (_source: this, message: string, time_left: number, bytes_left: number) => void
            ): number;
            connect_after(
                signal: "show-unmount-progress",
                callback: (_source: this, message: string, time_left: number, bytes_left: number) => void
            ): number;
            emit(signal: "show-unmount-progress", message: string, time_left: number, bytes_left: number): void;

            // Constructors

            static ["new"](): MountOperation;

            // Members

            /**
             * Check to see whether the mount operation is being used
             * for an anonymous user.
             */
            get_anonymous(): boolean;
            /**
             * Gets a choice from the mount operation.
             */
            get_choice(): number;
            /**
             * Gets the domain of the mount operation.
             */
            get_domain(): string | null;
            /**
             * Check to see whether the mount operation is being used
             * for a TCRYPT hidden volume.
             */
            get_is_tcrypt_hidden_volume(): boolean;
            /**
             * Check to see whether the mount operation is being used
             * for a TCRYPT system volume.
             */
            get_is_tcrypt_system_volume(): boolean;
            /**
             * Gets a password from the mount operation.
             */
            get_password(): string | null;
            /**
             * Gets the state of saving passwords for the mount operation.
             */
            get_password_save(): PasswordSave;
            /**
             * Gets a PIM from the mount operation.
             */
            get_pim(): number;
            /**
             * Get the user name from the mount operation.
             */
            get_username(): string | null;
            /**
             * Emits the #GMountOperation::reply signal.
             */
            reply(result: MountOperationResult): void;
            /**
             * Sets the mount operation to use an anonymous user if `anonymous `is %TRUE.
             */
            set_anonymous(anonymous: boolean): void;
            /**
             * Sets a default choice for the mount operation.
             */
            set_choice(choice: number): void;
            /**
             * Sets the mount operation's domain.
             */
            set_domain(domain?: string | null): void;
            /**
             * Sets the mount operation to use a hidden volume if `hidden_volume `is %TRUE.
             */
            set_is_tcrypt_hidden_volume(hidden_volume: boolean): void;
            /**
             * Sets the mount operation to use a system volume if `system_volume `is %TRUE.
             */
            set_is_tcrypt_system_volume(system_volume: boolean): void;
            /**
             * Sets the mount operation's password to `password.`
             */
            set_password(password?: string | null): void;
            /**
             * Sets the state of saving passwords for the mount operation.
             */
            set_password_save(save: PasswordSave): void;
            /**
             * Sets the mount operation's PIM to `pim.`
             */
            set_pim(pim: number): void;
            /**
             * Sets the user name within `op `to `username.`
             */
            set_username(username?: string | null): void;
            vfunc_aborted(): void;
            vfunc_ask_password(
                message: string,
                default_user: string,
                default_domain: string,
                flags: AskPasswordFlags
            ): void;
            /**
             * Virtual implementation of #GMountOperation::ask-question.
             */
            vfunc_ask_question(message: string, choices: string[]): void;
            /**
             * Emits the #GMountOperation::reply signal.
             */
            vfunc_reply(result: MountOperationResult): void;
            /**
             * Virtual implementation of #GMountOperation::show-processes.
             */
            vfunc_show_processes(message: string, processes: GLib.Pid[], choices: string[]): void;
            vfunc_show_unmount_progress(message: string, time_left: number, bytes_left: number): void;
        }
        export module NativeSocketAddress {
            export interface ConstructorProperties extends SocketAddress.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class NativeSocketAddress extends SocketAddress implements SocketConnectable {
            static $gtype: GObject.GType<NativeSocketAddress>;

            constructor(properties?: Partial<NativeSocketAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<NativeSocketAddress.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](_native: any | null, len: number): NativeSocketAddress;

            // Implemented Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }
        export module NativeVolumeMonitor {
            export interface ConstructorProperties extends VolumeMonitor.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class NativeVolumeMonitor extends VolumeMonitor {
            static $gtype: GObject.GType<NativeVolumeMonitor>;

            constructor(properties?: Partial<NativeVolumeMonitor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<NativeVolumeMonitor.ConstructorProperties>, ...args: any[]): void;
        }
        export module NetworkAddress {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                hostname: string;
                port: number;
                scheme: string;
            }
        }
        export class NetworkAddress extends GObject.Object implements SocketConnectable {
            static $gtype: GObject.GType<NetworkAddress>;

            constructor(properties?: Partial<NetworkAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<NetworkAddress.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get hostname(): string;
            get port(): number;
            get scheme(): string;

            // Constructors

            static ["new"](hostname: string, port: number): NetworkAddress;
            static new_loopback(port: number): NetworkAddress;

            // Members

            /**
             * Gets addr's hostname. This might be either UTF-8 or ASCII-encoded,
             * depending on what `addr `was created with.
             */
            get_hostname(): string;
            /**
             * Gets addr's port number
             */
            get_port(): number;
            /**
             * Gets addr's scheme
             */
            get_scheme(): string | null;
            /**
             * Creates a new #GSocketConnectable for connecting to the given
             * `hostname `and `port.` May fail and return %NULL in case
             * parsing `host_and_port `fails.
             *
             * `host_and_port `may be in any of a number of recognised formats; an IPv6
             * address, an IPv4 address, or a domain name (in which case a DNS
             * lookup is performed). Quoting with [] is supported for all address
             * types. A port override may be specified in the usual way with a
             * colon.
             *
             * If no port is specified in `host_and_port `then `default_port `will be
             * used as the port number to connect to.
             *
             * In general, `host_and_port `is expected to be provided by the user
             * (allowing them to give the hostname, and a port override if necessary)
             * and `default_port `is expected to be provided by the application.
             *
             * (The port component of `host_and_port `can also be specified as a
             * service name rather than as a numeric port, but this functionality
             * is deprecated, because it depends on the contents of /etc/services,
             * which is generally quite sparse on platforms other than Linux.)
             */
            static parse(host_and_port: string, default_port: number): NetworkAddress;
            /**
             * Creates a new #GSocketConnectable for connecting to the given
             * `uri.` May fail and return %NULL in case parsing `uri `fails.
             *
             * Using this rather than g_network_address_new() or
             * g_network_address_parse() allows #GSocketClient to determine
             * when to use application-specific proxy protocols.
             */
            static parse_uri(uri: string, default_port: number): NetworkAddress;

            // Implemented Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }
        export module NetworkService {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                domain: string;
                protocol: string;
                scheme: string;
                service: string;
            }
        }
        export class NetworkService extends GObject.Object implements SocketConnectable {
            static $gtype: GObject.GType<NetworkService>;

            constructor(properties?: Partial<NetworkService.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<NetworkService.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get domain(): string;
            get protocol(): string;
            get scheme(): string;
            set scheme(val: string);
            get service(): string;

            // Constructors

            static ["new"](service: string, protocol: string, domain: string): NetworkService;

            // Members

            /**
             * Gets the domain that `srv `serves. This might be either UTF-8 or
             * ASCII-encoded, depending on what `srv `was created with.
             */
            get_domain(): string;
            /**
             * Gets srv's protocol name (eg, "tcp").
             */
            get_protocol(): string;
            /**
             * Gets the URI scheme used to resolve proxies. By default, the service name
             * is used as scheme.
             */
            get_scheme(): string;
            /**
             * Gets srv's service name (eg, "ldap").
             */
            get_service(): string;
            /**
             * Set's the URI scheme used to resolve proxies. By default, the service name
             * is used as scheme.
             */
            set_scheme(scheme: string): void;

            // Implemented Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }
        export module Notification {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class Notification extends GObject.Object {
            static $gtype: GObject.GType<Notification>;

            constructor(properties?: Partial<Notification.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Notification.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](title: string): Notification;

            // Members

            /**
             * Adds a button to `notification `that activates the action in
             * `detailed_action `when clicked. That action must be an
             * application-wide action (starting with "app."). If detailed_action
             * contains a target, the action will be activated with that target as
             * its parameter.
             *
             * See g_action_parse_detailed_name() for a description of the format
             * for `detailed_action.`
             */
            add_button(label: string, detailed_action: string): void;
            /**
             * Adds a button to `notification `that activates `action `when clicked.
             * `action `must be an application-wide action (it must start with "app.").
             *
             * If `target `is non-%NULL, `action `will be activated with `target `as
             * its parameter.
             */
            add_button_with_target(label: string, action: string, target?: GLib.Variant | null): void;
            /**
             * Sets the body of `notification `to `body.`
             */
            set_body(body?: string | null): void;
            /**
             * Sets the type of `notification `to `category.` Categories have a main
             * type like `email`, `im` or `device` and can have a detail separated
             * by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
             * helps the notification server to select proper feedback to the user.
             *
             * Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
             */
            set_category(category?: string | null): void;
            /**
             * Sets the default action of `notification `to `detailed_action.` This
             * action is activated when the notification is clicked on.
             *
             * The action in `detailed_action `must be an application-wide action (it
             * must start with "app."). If `detailed_action `contains a target, the
             * given action will be activated with that target as its parameter.
             * See g_action_parse_detailed_name() for a description of the format
             * for `detailed_action.`
             *
             * When no default action is set, the application that the notification
             * was sent on is activated.
             */
            set_default_action(detailed_action: string): void;
            /**
             * Sets the default action of `notification `to `action.` This action is
             * activated when the notification is clicked on. It must be an
             * application-wide action (start with "app.").
             *
             * If `target `is non-%NULL, `action `will be activated with `target `as
             * its parameter. If `target `is floating, it will be consumed.
             *
             * When no default action is set, the application that the notification
             * was sent on is activated.
             */
            set_default_action_and_target(action: string, target?: GLib.Variant | null): void;
            /**
             * Sets the icon of `notification `to `icon.`
             */
            set_icon(icon: Icon): void;
            /**
             * Sets the priority of `notification `to `priority.` See
             * #GNotificationPriority for possible values.
             */
            set_priority(priority: NotificationPriority): void;
            /**
             * Sets the title of `notification `to `title.`
             */
            set_title(title: string): void;
            /**
             * Deprecated in favor of g_notification_set_priority().
             */
            set_urgent(urgent: boolean): void;
        }
        export module OutputStream {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class OutputStream extends GObject.Object {
            static $gtype: GObject.GType<OutputStream>;

            constructor(properties?: Partial<OutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<OutputStream.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Clears the pending flag on `stream.`
             */
            clear_pending(): void;
            /**
             * Closes the stream, releasing resources related to it.
             *
             * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
             * Closing a stream multiple times will not return an error.
             *
             * Closing a stream will automatically flush any outstanding buffers in the
             * stream.
             *
             * Streams will be automatically closed when the last reference
             * is dropped, but you might want to call this function to make sure
             * resources are released as early as possible.
             *
             * Some streams might keep the backing store of the stream (e.g. a file descriptor)
             * open after the stream is closed. See the documentation for the individual
             * stream for details.
             *
             * On failure the first error that happened will be reported, but the close
             * operation will finish as much as possible. A stream that failed to
             * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
             * is important to check and report the error to the user, otherwise
             * there might be a loss of data as all data might not be written.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             * Cancelling a close will still leave the stream closed, but there some streams
             * can use a faster close that doesn't block to e.g. check errors. On
             * cancellation (as with any error) there is no guarantee that all written
             * data will reach the target.
             */
            close(cancellable?: Cancellable | null): boolean;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_output_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_output_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_output_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_output_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_output_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_output_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Closes an output stream.
             */
            close_finish(result: AsyncResult): boolean;
            /**
             * Forces a write of all user-space buffered data for the given
             * `stream.` Will block during the operation. Closing the stream will
             * implicitly cause a flush.
             *
             * This function is optional for inherited classes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            flush(cancellable?: Cancellable | null): boolean;
            /**
             * Forces an asynchronous write of all user-space buffered data for
             * the given `stream.`
             * For behaviour details see g_output_stream_flush().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_output_stream_flush_finish() to get the
             * result of the operation.
             */
            flush_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Forces an asynchronous write of all user-space buffered data for
             * the given `stream.`
             * For behaviour details see g_output_stream_flush().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_output_stream_flush_finish() to get the
             * result of the operation.
             */
            flush_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Forces an asynchronous write of all user-space buffered data for
             * the given `stream.`
             * For behaviour details see g_output_stream_flush().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_output_stream_flush_finish() to get the
             * result of the operation.
             */
            flush_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes flushing an output stream.
             */
            flush_finish(result: AsyncResult): boolean;
            /**
             * Checks if an output stream has pending actions.
             */
            has_pending(): boolean;
            /**
             * Checks if an output stream has already been closed.
             */
            is_closed(): boolean;
            /**
             * Checks if an output stream is being closed. This can be
             * used inside e.g. a flush implementation to see if the
             * flush (or other i/o operation) is called from within
             * the closing operation.
             */
            is_closing(): boolean;
            /**
             * Sets `stream `to have actions pending. If the pending flag is
             * already set or `stream `is closed, it will return %FALSE and set
             * `error.`
             */
            set_pending(): boolean;
            /**
             * Splices an input stream into an output stream.
             */
            splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
            /**
             * Splices a stream asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_output_stream_splice_finish() to get the
             * result of the operation.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_splice().
             */
            splice_async(
                source: InputStream,
                flags: OutputStreamSpliceFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<number>;
            /**
             * Splices a stream asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_output_stream_splice_finish() to get the
             * result of the operation.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_splice().
             */
            splice_async(
                source: InputStream,
                flags: OutputStreamSpliceFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Splices a stream asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_output_stream_splice_finish() to get the
             * result of the operation.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_splice().
             */
            splice_async(
                source: InputStream,
                flags: OutputStreamSpliceFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes an asynchronous stream splice operation.
             */
            splice_finish(result: AsyncResult): number;
            /**
             * Tries to write `count `bytes from `buffer `into the stream. Will block
             * during the operation.
             *
             * If count is 0, returns 0 and does nothing. A value of count
             * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written to the stream is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. on a partial I/O error, or if there is not enough
             * storage in the stream. All writes block until at least one byte
             * is written or an error occurs; 0 is never returned (unless
             * `count `is 0).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            write(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
            /**
             * Tries to write `count `bytes from `buffer `into the stream. Will block
             * during the operation.
             *
             * This function is similar to g_output_stream_write(), except it tries to
             * write as many bytes as requested, only stopping on an error.
             *
             * On a successful write of `count `bytes, %TRUE is returned, and bytes_written
             * is set to `count.`
             *
             * If there is an error during the operation %FALSE is returned and error
             * is set to indicate the error status.
             *
             * As a special exception to the normal conventions for functions that
             * use #GError, if this function returns %FALSE (and sets error) then
             * `bytes_written `will be set to the number of bytes that were
             * successfully written before the error was encountered.  This
             * functionality is only available from C.  If you need it from another
             * language then you must write your own loop around
             * g_output_stream_write().
             */
            write_all(buffer: Uint8Array | string, cancellable?: Cancellable | null): [boolean, number];
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_all_finish() to get the result of the
             * operation.
             *
             * This is the asynchronous version of g_output_stream_write_all().
             *
             * Call g_output_stream_write_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called.
             */
            write_all_async(
                buffer: Uint8Array | string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[number]>;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_all_finish() to get the result of the
             * operation.
             *
             * This is the asynchronous version of g_output_stream_write_all().
             *
             * Call g_output_stream_write_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called.
             */
            write_all_async(
                buffer: Uint8Array | string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_all_finish() to get the result of the
             * operation.
             *
             * This is the asynchronous version of g_output_stream_write_all().
             *
             * Call g_output_stream_write_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called.
             */
            write_all_async(
                buffer: Uint8Array | string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[number]> | void;
            /**
             * Finishes an asynchronous stream write operation started with
             * g_output_stream_write_all_async().
             *
             * As a special exception to the normal conventions for functions that
             * use #GError, if this function returns %FALSE (and sets error) then
             * `bytes_written `will be set to the number of bytes that were
             * successfully written before the error was encountered.  This
             * functionality is only available from C.  If you need it from another
             * language then you must write your own loop around
             * g_output_stream_write_async().
             */
            write_all_finish(result: AsyncResult): [boolean, number];
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK - if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write().
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called. See g_output_stream_write_bytes_async()
             * for a #GBytes version that will automatically hold a reference to
             * the contents (without copying) for the duration of the call.
             */
            write_async(
                buffer: Uint8Array | string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<number>;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK - if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write().
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called. See g_output_stream_write_bytes_async()
             * for a #GBytes version that will automatically hold a reference to
             * the contents (without copying) for the duration of the call.
             */
            write_async(
                buffer: Uint8Array | string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK - if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write().
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called. See g_output_stream_write_bytes_async()
             * for a #GBytes version that will automatically hold a reference to
             * the contents (without copying) for the duration of the call.
             */
            write_async(
                buffer: Uint8Array | string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * A wrapper function for g_output_stream_write() which takes a
             * #GBytes as input.  This can be more convenient for use by language
             * bindings or in other cases where the refcounted nature of #GBytes
             * is helpful over a bare pointer interface.
             *
             * However, note that this function may still perform partial writes,
             * just like g_output_stream_write().  If that occurs, to continue
             * writing, you will need to create a new #GBytes containing just the
             * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
             * #GBytes instance multiple times potentially can result in duplicated
             * data in the output stream.
             */
            write_bytes(bytes: GLib.Bytes | Uint8Array, cancellable?: Cancellable | null): number;
            /**
             * This function is similar to g_output_stream_write_async(), but
             * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
             * this allows the stream to avoid taking a copy of the data.
             *
             * However, note that this function may still perform partial writes,
             * just like g_output_stream_write_async(). If that occurs, to continue
             * writing, you will need to create a new #GBytes containing just the
             * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
             * #GBytes instance multiple times potentially can result in duplicated
             * data in the output stream.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write_bytes().
             */
            write_bytes_async(
                bytes: GLib.Bytes | Uint8Array,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<number>;
            /**
             * This function is similar to g_output_stream_write_async(), but
             * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
             * this allows the stream to avoid taking a copy of the data.
             *
             * However, note that this function may still perform partial writes,
             * just like g_output_stream_write_async(). If that occurs, to continue
             * writing, you will need to create a new #GBytes containing just the
             * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
             * #GBytes instance multiple times potentially can result in duplicated
             * data in the output stream.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write_bytes().
             */
            write_bytes_async(
                bytes: GLib.Bytes | Uint8Array,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * This function is similar to g_output_stream_write_async(), but
             * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
             * this allows the stream to avoid taking a copy of the data.
             *
             * However, note that this function may still perform partial writes,
             * just like g_output_stream_write_async(). If that occurs, to continue
             * writing, you will need to create a new #GBytes containing just the
             * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
             * #GBytes instance multiple times potentially can result in duplicated
             * data in the output stream.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write_bytes().
             */
            write_bytes_async(
                bytes: GLib.Bytes | Uint8Array,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes a stream write-from-#GBytes operation.
             */
            write_bytes_finish(result: AsyncResult): number;
            /**
             * Finishes a stream write operation.
             */
            write_finish(result: AsyncResult): number;
            /**
             * Tries to write the bytes contained in the `n_vectors ``vectors `into the
             * stream. Will block during the operation.
             *
             * If `n_vectors `is 0 or the sum of all bytes in `vectors `is 0, returns 0 and
             * does nothing.
             *
             * On success, the number of bytes written to the stream is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. on a partial I/O error, or if there is not enough
             * storage in the stream. All writes block until at least one byte
             * is written or an error occurs; 0 is never returned (unless
             * `n_vectors `is 0 or the sum of all bytes in `vectors `is 0).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * Some implementations of g_output_stream_writev() may have limitations on the
             * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
             * are exceeded. For example, when writing to a local file on UNIX platforms,
             * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
             */
            writev(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
            /**
             * Tries to write the bytes contained in the `n_vectors ``vectors `into the
             * stream. Will block during the operation.
             *
             * This function is similar to g_output_stream_writev(), except it tries to
             * write as many bytes as requested, only stopping on an error.
             *
             * On a successful write of all `n_vectors `vectors, %TRUE is returned, and
             * `bytes_written `is set to the sum of all the sizes of `vectors.`
             *
             * If there is an error during the operation %FALSE is returned and error
             * is set to indicate the error status.
             *
             * As a special exception to the normal conventions for functions that
             * use #GError, if this function returns %FALSE (and sets error) then
             * `bytes_written `will be set to the number of bytes that were
             * successfully written before the error was encountered.  This
             * functionality is only available from C. If you need it from another
             * language then you must write your own loop around
             * g_output_stream_write().
             *
             * The content of the individual elements of `vectors `might be changed by this
             * function.
             */
            writev_all(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
            /**
             * Request an asynchronous write of the bytes contained in the `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_all_finish() to get the result of the
             * operation.
             *
             * This is the asynchronous version of g_output_stream_writev_all().
             *
             * Call g_output_stream_writev_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called. The content of the individual elements
             * of `vectors `might be changed by this function.
             */
            writev_all_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[number]>;
            /**
             * Request an asynchronous write of the bytes contained in the `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_all_finish() to get the result of the
             * operation.
             *
             * This is the asynchronous version of g_output_stream_writev_all().
             *
             * Call g_output_stream_writev_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called. The content of the individual elements
             * of `vectors `might be changed by this function.
             */
            writev_all_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous write of the bytes contained in the `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_all_finish() to get the result of the
             * operation.
             *
             * This is the asynchronous version of g_output_stream_writev_all().
             *
             * Call g_output_stream_writev_all_finish() to collect the result.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called. The content of the individual elements
             * of `vectors `might be changed by this function.
             */
            writev_all_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[number]> | void;
            /**
             * Finishes an asynchronous stream write operation started with
             * g_output_stream_writev_all_async().
             *
             * As a special exception to the normal conventions for functions that
             * use #GError, if this function returns %FALSE (and sets error) then
             * `bytes_written `will be set to the number of bytes that were
             * successfully written before the error was encountered.  This
             * functionality is only available from C.  If you need it from another
             * language then you must write your own loop around
             * g_output_stream_writev_async().
             */
            writev_all_finish(result: AsyncResult): [boolean, number];
            /**
             * Request an asynchronous write of the bytes contained in `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK — if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_writev().
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called.
             */
            writev_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[number]>;
            /**
             * Request an asynchronous write of the bytes contained in `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK — if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_writev().
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called.
             */
            writev_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous write of the bytes contained in `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK — if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_writev().
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called.
             */
            writev_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[number]> | void;
            /**
             * Finishes a stream writev operation.
             */
            writev_finish(result: AsyncResult): [boolean, number];
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_output_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_output_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            vfunc_close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_output_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_output_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            vfunc_close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Requests an asynchronous close of the stream, releasing resources
             * related to it. When the operation is finished `callback `will be
             * called. You can then call g_output_stream_close_finish() to get
             * the result of the operation.
             *
             * For behaviour details see g_output_stream_close().
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             */
            vfunc_close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Closes an output stream.
             */
            vfunc_close_finish(result: AsyncResult): boolean;
            vfunc_close_fn(cancellable?: Cancellable | null): boolean;
            /**
             * Forces a write of all user-space buffered data for the given
             * `stream.` Will block during the operation. Closing the stream will
             * implicitly cause a flush.
             *
             * This function is optional for inherited classes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_flush(cancellable?: Cancellable | null): boolean;
            /**
             * Forces an asynchronous write of all user-space buffered data for
             * the given `stream.`
             * For behaviour details see g_output_stream_flush().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_output_stream_flush_finish() to get the
             * result of the operation.
             */
            vfunc_flush_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Forces an asynchronous write of all user-space buffered data for
             * the given `stream.`
             * For behaviour details see g_output_stream_flush().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_output_stream_flush_finish() to get the
             * result of the operation.
             */
            vfunc_flush_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Forces an asynchronous write of all user-space buffered data for
             * the given `stream.`
             * For behaviour details see g_output_stream_flush().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_output_stream_flush_finish() to get the
             * result of the operation.
             */
            vfunc_flush_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes flushing an output stream.
             */
            vfunc_flush_finish(result: AsyncResult): boolean;
            /**
             * Splices an input stream into an output stream.
             */
            vfunc_splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
            /**
             * Splices a stream asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_output_stream_splice_finish() to get the
             * result of the operation.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_splice().
             */
            vfunc_splice_async(
                source: InputStream,
                flags: OutputStreamSpliceFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<number>;
            /**
             * Splices a stream asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_output_stream_splice_finish() to get the
             * result of the operation.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_splice().
             */
            vfunc_splice_async(
                source: InputStream,
                flags: OutputStreamSpliceFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Splices a stream asynchronously.
             * When the operation is finished `callback `will be called.
             * You can then call g_output_stream_splice_finish() to get the
             * result of the operation.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_splice().
             */
            vfunc_splice_async(
                source: InputStream,
                flags: OutputStreamSpliceFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes an asynchronous stream splice operation.
             */
            vfunc_splice_finish(result: AsyncResult): number;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK - if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write().
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called. See g_output_stream_write_bytes_async()
             * for a #GBytes version that will automatically hold a reference to
             * the contents (without copying) for the duration of the call.
             */
            vfunc_write_async(
                buffer: Uint8Array | null,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<number>;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK - if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write().
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called. See g_output_stream_write_bytes_async()
             * for a #GBytes version that will automatically hold a reference to
             * the contents (without copying) for the duration of the call.
             */
            vfunc_write_async(
                buffer: Uint8Array | null,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous write of `count `bytes from `buffer `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_write_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * A value of `count `larger than %G_MAXSSIZE will cause a
             * %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK - if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_write().
             *
             * Note that no copy of `buffer `will be made, so it must stay valid
             * until `callback `is called. See g_output_stream_write_bytes_async()
             * for a #GBytes version that will automatically hold a reference to
             * the contents (without copying) for the duration of the call.
             */
            vfunc_write_async(
                buffer: Uint8Array | null,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<number> | void;
            /**
             * Finishes a stream write operation.
             */
            vfunc_write_finish(result: AsyncResult): number;
            /**
             * Tries to write `count `bytes from `buffer `into the stream. Will block
             * during the operation.
             *
             * If count is 0, returns 0 and does nothing. A value of count
             * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
             *
             * On success, the number of bytes written to the stream is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. on a partial I/O error, or if there is not enough
             * storage in the stream. All writes block until at least one byte
             * is written or an error occurs; 0 is never returned (unless
             * `count `is 0).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            vfunc_write_fn(buffer?: Uint8Array | null, cancellable?: Cancellable | null): number;
            /**
             * Request an asynchronous write of the bytes contained in `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK — if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_writev().
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called.
             */
            vfunc_writev_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[number]>;
            /**
             * Request an asynchronous write of the bytes contained in `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK — if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_writev().
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called.
             */
            vfunc_writev_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Request an asynchronous write of the bytes contained in `n_vectors ``vectors `into
             * the stream. When the operation is finished `callback `will be called.
             * You can then call g_output_stream_writev_finish() to get the result of the
             * operation.
             *
             * During an async request no other sync and async calls are allowed,
             * and will result in %G_IO_ERROR_PENDING errors.
             *
             * On success, the number of bytes written will be passed to the
             * `callback.` It is not an error if this is not the same as the
             * requested size, as it can happen e.g. on a partial I/O error,
             * but generally we try to write as many bytes as requested.
             *
             * You are guaranteed that this method will never fail with
             * %G_IO_ERROR_WOULD_BLOCK — if `stream `can't accept more data, the
             * method will just wait until this changes.
             *
             * Any outstanding I/O request with higher priority (lower numerical
             * value) will be executed before an outstanding request with lower
             * priority. Default priority is %G_PRIORITY_DEFAULT.
             *
             * The asynchronous methods have a default fallback that uses threads
             * to implement asynchronicity, so they are optional for inheriting
             * classes. However, if you override one you must override all.
             *
             * For the synchronous, blocking version of this function, see
             * g_output_stream_writev().
             *
             * Note that no copy of `vectors `will be made, so it must stay valid
             * until `callback `is called.
             */
            vfunc_writev_async(
                vectors: OutputVector[],
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[number]> | void;
            /**
             * Finishes a stream writev operation.
             */
            vfunc_writev_finish(result: AsyncResult): [boolean, number];
            /**
             * Tries to write the bytes contained in the `n_vectors ``vectors `into the
             * stream. Will block during the operation.
             *
             * If `n_vectors `is 0 or the sum of all bytes in `vectors `is 0, returns 0 and
             * does nothing.
             *
             * On success, the number of bytes written to the stream is returned.
             * It is not an error if this is not the same as the requested size, as it
             * can happen e.g. on a partial I/O error, or if there is not enough
             * storage in the stream. All writes block until at least one byte
             * is written or an error occurs; 0 is never returned (unless
             * `n_vectors `is 0 or the sum of all bytes in `vectors `is 0).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             *
             * Some implementations of g_output_stream_writev() may have limitations on the
             * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
             * are exceeded. For example, when writing to a local file on UNIX platforms,
             * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
             */
            vfunc_writev_fn(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        }
        export module Permission {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                allowed: boolean;
                can_acquire: boolean;
                canAcquire: boolean;
                can_release: boolean;
                canRelease: boolean;
            }
        }
        export abstract class Permission extends GObject.Object {
            static $gtype: GObject.GType<Permission>;

            constructor(properties?: Partial<Permission.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Permission.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get allowed(): boolean;
            get can_acquire(): boolean;
            get canAcquire(): boolean;
            get can_release(): boolean;
            get canRelease(): boolean;

            // Members

            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * The precise method by which this happens depends on the permission
             * and the underlying authentication mechanism.  A simple example is
             * that a dialog may appear asking the user to enter their password.
             *
             * You should check with g_permission_get_can_acquire() before calling
             * this function.
             *
             * If the permission is acquired then %TRUE is returned.  Otherwise,
             * %FALSE is returned and `error `is set appropriately.
             *
             * This call is blocking, likely for a very long time (in the case that
             * user interaction is required).  See g_permission_acquire_async() for
             * the non-blocking version.
             */
            acquire(cancellable?: Cancellable | null): boolean;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_acquire().
             */
            acquire_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_acquire().
             */
            acquire_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_acquire().
             */
            acquire_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Collects the result of attempting to acquire the permission
             * represented by `permission.`
             *
             * This is the second half of the asynchronous version of
             * g_permission_acquire().
             */
            acquire_finish(result: AsyncResult): boolean;
            /**
             * Gets the value of the 'allowed' property.  This property is %TRUE if
             * the caller currently has permission to perform the action that
             * `permission `represents the permission to perform.
             */
            get_allowed(): boolean;
            /**
             * Gets the value of the 'can-acquire' property.  This property is %TRUE
             * if it is generally possible to acquire the permission by calling
             * g_permission_acquire().
             */
            get_can_acquire(): boolean;
            /**
             * Gets the value of the 'can-release' property.  This property is %TRUE
             * if it is generally possible to release the permission by calling
             * g_permission_release().
             */
            get_can_release(): boolean;
            /**
             * This function is called by the #GPermission implementation to update
             * the properties of the permission.  You should never call this
             * function except from a #GPermission implementation.
             *
             * GObject notify signals are generated, as appropriate.
             */
            impl_update(allowed: boolean, can_acquire: boolean, can_release: boolean): void;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * The precise method by which this happens depends on the permission
             * and the underlying authentication mechanism.  In most cases the
             * permission will be dropped immediately without further action.
             *
             * You should check with g_permission_get_can_release() before calling
             * this function.
             *
             * If the permission is released then %TRUE is returned.  Otherwise,
             * %FALSE is returned and `error `is set appropriately.
             *
             * This call is blocking, likely for a very long time (in the case that
             * user interaction is required).  See g_permission_release_async() for
             * the non-blocking version.
             */
            release(cancellable?: Cancellable | null): boolean;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_release().
             */
            release_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_release().
             */
            release_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_release().
             */
            release_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Collects the result of attempting to release the permission
             * represented by `permission.`
             *
             * This is the second half of the asynchronous version of
             * g_permission_release().
             */
            release_finish(result: AsyncResult): boolean;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * The precise method by which this happens depends on the permission
             * and the underlying authentication mechanism.  A simple example is
             * that a dialog may appear asking the user to enter their password.
             *
             * You should check with g_permission_get_can_acquire() before calling
             * this function.
             *
             * If the permission is acquired then %TRUE is returned.  Otherwise,
             * %FALSE is returned and `error `is set appropriately.
             *
             * This call is blocking, likely for a very long time (in the case that
             * user interaction is required).  See g_permission_acquire_async() for
             * the non-blocking version.
             */
            vfunc_acquire(cancellable?: Cancellable | null): boolean;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_acquire().
             */
            vfunc_acquire_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_acquire().
             */
            vfunc_acquire_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Attempts to acquire the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_acquire().
             */
            vfunc_acquire_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Collects the result of attempting to acquire the permission
             * represented by `permission.`
             *
             * This is the second half of the asynchronous version of
             * g_permission_acquire().
             */
            vfunc_acquire_finish(result: AsyncResult): boolean;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * The precise method by which this happens depends on the permission
             * and the underlying authentication mechanism.  In most cases the
             * permission will be dropped immediately without further action.
             *
             * You should check with g_permission_get_can_release() before calling
             * this function.
             *
             * If the permission is released then %TRUE is returned.  Otherwise,
             * %FALSE is returned and `error `is set appropriately.
             *
             * This call is blocking, likely for a very long time (in the case that
             * user interaction is required).  See g_permission_release_async() for
             * the non-blocking version.
             */
            vfunc_release(cancellable?: Cancellable | null): boolean;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_release().
             */
            vfunc_release_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_release().
             */
            vfunc_release_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Attempts to release the permission represented by `permission.`
             *
             * This is the first half of the asynchronous version of
             * g_permission_release().
             */
            vfunc_release_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Collects the result of attempting to release the permission
             * represented by `permission.`
             *
             * This is the second half of the asynchronous version of
             * g_permission_release().
             */
            vfunc_release_finish(result: AsyncResult): boolean;
        }
        export module PropertyAction {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                enabled: boolean;
                invert_boolean: boolean;
                invertBoolean: boolean;
                name: string;
                object: GObject.Object;
                parameter_type: GLib.VariantType;
                parameterType: GLib.VariantType;
                property_name: string;
                propertyName: string;
                state: GLib.Variant;
                state_type: GLib.VariantType;
                stateType: GLib.VariantType;
            }
        }
        export class PropertyAction extends GObject.Object implements Action {
            static $gtype: GObject.GType<PropertyAction>;

            constructor(properties?: Partial<PropertyAction.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<PropertyAction.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get enabled(): boolean;
            get invert_boolean(): boolean;
            get invertBoolean(): boolean;
            get name(): string;
            set object(val: GObject.Object);
            get parameter_type(): GLib.VariantType;
            get parameterType(): GLib.VariantType;
            set property_name(val: string);
            set propertyName(val: string);
            get state(): GLib.Variant;
            get state_type(): GLib.VariantType;
            get stateType(): GLib.VariantType;

            // Constructors

            static ["new"](name: string, object: GObject.Object, property_name: string): PropertyAction;

            // Implemented Members

            /**
             * Activates the action.
             *
             * `parameter `must be the correct type of parameter for the action (ie:
             * the parameter type given at construction time).  If the parameter
             * type was %NULL then `parameter `must also be %NULL.
             *
             * If the `parameter `GVariant is floating, it is consumed.
             */
            activate(parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of `action `to be changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_get_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_get_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_state(value: GLib.Variant): void;
            /**
             * Checks if `action `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_enabled(): boolean;
            /**
             * Queries the name of `action.`
             */
            get_name(): string;
            /**
             * Queries the type of the parameter that must be given when activating
             * `action.`
             *
             * When activating the action using g_action_activate(), the #GVariant
             * given to that function must be of the type returned by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             */
            get_parameter_type(): GLib.VariantType | null;
            /**
             * Queries the current state of `action.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_get_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_state(): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of
             * `action.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_state_hint(): GLib.Variant | null;
            /**
             * Queries the type of the state of `action.`
             *
             * If the action is stateful (e.g. created with
             * g_simple_action_new_stateful()) then this function returns the
             * #GVariantType of the state.  This is the type of the initial value
             * given as the state. All calls to g_action_change_state() must give a
             * #GVariant of this type and g_action_get_state() will return a
             * #GVariant of the same type.
             *
             * If the action is not stateful (e.g. created with g_simple_action_new())
             * then this function will return %NULL. In that case, g_action_get_state()
             * will return %NULL and you must not call g_action_change_state().
             */
            get_state_type(): GLib.VariantType | null;
            /**
             * Activates the action.
             *
             * `parameter `must be the correct type of parameter for the action (ie:
             * the parameter type given at construction time).  If the parameter
             * type was %NULL then `parameter `must also be %NULL.
             *
             * If the `parameter `GVariant is floating, it is consumed.
             */
            vfunc_activate(parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of `action `to be changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_get_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_get_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_state(value: GLib.Variant): void;
            /**
             * Checks if `action `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_enabled(): boolean;
            /**
             * Queries the name of `action.`
             */
            vfunc_get_name(): string;
            /**
             * Queries the type of the parameter that must be given when activating
             * `action.`
             *
             * When activating the action using g_action_activate(), the #GVariant
             * given to that function must be of the type returned by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             */
            vfunc_get_parameter_type(): GLib.VariantType | null;
            /**
             * Queries the current state of `action.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_get_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_state(): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of
             * `action.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_state_hint(): GLib.Variant | null;
            /**
             * Queries the type of the state of `action.`
             *
             * If the action is stateful (e.g. created with
             * g_simple_action_new_stateful()) then this function returns the
             * #GVariantType of the state.  This is the type of the initial value
             * given as the state. All calls to g_action_change_state() must give a
             * #GVariant of this type and g_action_get_state() will return a
             * #GVariant of the same type.
             *
             * If the action is not stateful (e.g. created with g_simple_action_new())
             * then this function will return %NULL. In that case, g_action_get_state()
             * will return %NULL and you must not call g_action_change_state().
             */
            vfunc_get_state_type(): GLib.VariantType | null;
        }
        export module ProxyAddress {
            export interface ConstructorProperties extends InetSocketAddress.ConstructorProperties {
                [key: string]: any;
                destination_hostname: string;
                destinationHostname: string;
                destination_port: number;
                destinationPort: number;
                destination_protocol: string;
                destinationProtocol: string;
                password: string;
                protocol: string;
                uri: string;
                username: string;
            }
        }
        export class ProxyAddress extends InetSocketAddress implements SocketConnectable {
            static $gtype: GObject.GType<ProxyAddress>;

            constructor(properties?: Partial<ProxyAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ProxyAddress.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get destination_hostname(): string;
            get destinationHostname(): string;
            get destination_port(): number;
            get destinationPort(): number;
            get destination_protocol(): string;
            get destinationProtocol(): string;
            get password(): string;
            get protocol(): string;
            get uri(): string;
            get username(): string;

            // Constructors

            static ["new"](
                inetaddr: InetAddress,
                port: number,
                protocol: string,
                dest_hostname: string,
                dest_port: number,
                username?: string | null,
                password?: string | null
            ): ProxyAddress;
            // Conflicted with Gio.InetSocketAddress.new
            static ["new"](...args: never[]): any;

            // Members

            /**
             * Gets proxy's destination hostname; that is, the name of the host
             * that will be connected to via the proxy, not the name of the proxy
             * itself.
             */
            get_destination_hostname(): string;
            /**
             * Gets proxy's destination port; that is, the port on the
             * destination host that will be connected to via the proxy, not the
             * port number of the proxy itself.
             */
            get_destination_port(): number;
            /**
             * Gets the protocol that is being spoken to the destination
             * server; eg, "http" or "ftp".
             */
            get_destination_protocol(): string;
            /**
             * Gets proxy's password.
             */
            get_password(): string | null;
            /**
             * Gets proxy's protocol. eg, "socks" or "http"
             */
            get_protocol(): string;
            /**
             * Gets the proxy URI that `proxy `was constructed from.
             */
            get_uri(): string | null;
            /**
             * Gets proxy's username.
             */
            get_username(): string | null;
        }
        export module ProxyAddressEnumerator {
            export interface ConstructorProperties extends SocketAddressEnumerator.ConstructorProperties {
                [key: string]: any;
                connectable: SocketConnectable;
                default_port: number;
                defaultPort: number;
                proxy_resolver: ProxyResolver;
                proxyResolver: ProxyResolver;
                uri: string;
            }
        }
        export class ProxyAddressEnumerator extends SocketAddressEnumerator {
            static $gtype: GObject.GType<ProxyAddressEnumerator>;

            constructor(properties?: Partial<ProxyAddressEnumerator.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ProxyAddressEnumerator.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get connectable(): SocketConnectable;
            get default_port(): number;
            get defaultPort(): number;
            get proxy_resolver(): ProxyResolver;
            set proxy_resolver(val: ProxyResolver);
            get proxyResolver(): ProxyResolver;
            set proxyResolver(val: ProxyResolver);
            get uri(): string;
        }
        export module Resolver {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class Resolver extends GObject.Object {
            static $gtype: GObject.GType<Resolver>;

            constructor(properties?: Partial<Resolver.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Resolver.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "reload", callback: (_source: this) => void): number;
            connect_after(signal: "reload", callback: (_source: this) => void): number;
            emit(signal: "reload"): void;

            // Members

            /**
             * Synchronously reverse-resolves `address `to determine its
             * associated hostname.
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to
             * a value from #GResolverError.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             */
            lookup_by_address(address: InetAddress, cancellable?: Cancellable | null): string;
            /**
             * Begins asynchronously reverse-resolving `address `to determine its
             * associated hostname, and eventually calls callback, which must
             * call g_resolver_lookup_by_address_finish() to get the final result.
             */
            lookup_by_address_async(address: InetAddress, cancellable?: Cancellable | null): Promise<string>;
            /**
             * Begins asynchronously reverse-resolving `address `to determine its
             * associated hostname, and eventually calls callback, which must
             * call g_resolver_lookup_by_address_finish() to get the final result.
             */
            lookup_by_address_async(
                address: InetAddress,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously reverse-resolving `address `to determine its
             * associated hostname, and eventually calls callback, which must
             * call g_resolver_lookup_by_address_finish() to get the final result.
             */
            lookup_by_address_async(
                address: InetAddress,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string> | void;
            /**
             * Retrieves the result of a previous call to
             * g_resolver_lookup_by_address_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            lookup_by_address_finish(result: AsyncResult): string;
            /**
             * Synchronously resolves `hostname `to determine its associated IP
             * address(es). `hostname `may be an ASCII-only or UTF-8 hostname, or
             * the textual form of an IP address (in which case this just becomes
             * a wrapper around g_inet_address_new_from_string()).
             *
             * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
             * #GInetAddress, sorted in order of preference and guaranteed to not
             * contain duplicates. That is, if using the result to connect to
             * hostname, you should attempt to connect to the first address
             * first, then the second if the first fails, etc. If you are using
             * the result to listen on a socket, it is appropriate to add each
             * result using e.g. g_socket_listener_add_address().
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to a
             * value from #GResolverError and %NULL will be returned.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             *
             * If you are planning to connect to a socket on the resolved IP
             * address, it may be easier to create a #GNetworkAddress and use its
             * #GSocketConnectable interface.
             */
            lookup_by_name(hostname: string, cancellable?: Cancellable | null): InetAddress[];
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            lookup_by_name_async(hostname: string, cancellable?: Cancellable | null): Promise<InetAddress[]>;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            lookup_by_name_async(
                hostname: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            lookup_by_name_async(
                hostname: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<InetAddress[]> | void;
            /**
             * Retrieves the result of a call to
             * g_resolver_lookup_by_name_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            lookup_by_name_finish(result: AsyncResult): InetAddress[];
            /**
             * This differs from g_resolver_lookup_by_name() in that you can modify
             * the lookup behavior with `flags.` For example this can be used to limit
             * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
             */
            lookup_by_name_with_flags(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable?: Cancellable | null
            ): InetAddress[];
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            lookup_by_name_with_flags_async(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<InetAddress[]>;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            lookup_by_name_with_flags_async(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            lookup_by_name_with_flags_async(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<InetAddress[]> | void;
            /**
             * Retrieves the result of a call to
             * g_resolver_lookup_by_name_with_flags_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[];
            /**
             * Synchronously performs a DNS record lookup for the given `rrname `and returns
             * a list of records as #GVariant tuples. See #GResolverRecordType for
             * information on what the records contain for each `record_type.`
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to
             * a value from #GResolverError and %NULL will be returned.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             */
            lookup_records(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable?: Cancellable | null
            ): GLib.Variant[];
            /**
             * Begins asynchronously performing a DNS lookup for the given
             * rrname, and eventually calls callback, which must call
             * g_resolver_lookup_records_finish() to get the final result. See
             * g_resolver_lookup_records() for more details.
             */
            lookup_records_async(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable?: Cancellable | null
            ): Promise<GLib.Variant[]>;
            /**
             * Begins asynchronously performing a DNS lookup for the given
             * rrname, and eventually calls callback, which must call
             * g_resolver_lookup_records_finish() to get the final result. See
             * g_resolver_lookup_records() for more details.
             */
            lookup_records_async(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously performing a DNS lookup for the given
             * rrname, and eventually calls callback, which must call
             * g_resolver_lookup_records_finish() to get the final result. See
             * g_resolver_lookup_records() for more details.
             */
            lookup_records_async(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<GLib.Variant[]> | void;
            /**
             * Retrieves the result of a previous call to
             * g_resolver_lookup_records_async(). Returns a non-empty list of records as
             * #GVariant tuples. See #GResolverRecordType for information on what the
             * records contain.
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            lookup_records_finish(result: AsyncResult): GLib.Variant[];
            /**
             * Synchronously performs a DNS SRV lookup for the given `service `and
             * `protocol `in the given `domain `and returns an array of #GSrvTarget.
             * `domain `may be an ASCII-only or UTF-8 hostname. Note also that the
             * `service `and `protocol `arguments do not include the leading underscore
             * that appears in the actual DNS entry.
             *
             * On success, g_resolver_lookup_service() will return a non-empty #GList of
             * #GSrvTarget, sorted in order of preference. (That is, you should
             * attempt to connect to the first target first, then the second if
             * the first fails, etc.)
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to
             * a value from #GResolverError and %NULL will be returned.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             *
             * If you are planning to connect to the service, it is usually easier
             * to create a #GNetworkService and use its #GSocketConnectable
             * interface.
             */
            lookup_service(
                service: string,
                protocol: string,
                domain: string,
                cancellable?: Cancellable | null
            ): SrvTarget[];
            /**
             * Begins asynchronously performing a DNS SRV lookup for the given
             * `service `and `protocol `in the given domain, and eventually calls
             * callback, which must call g_resolver_lookup_service_finish() to
             * get the final result. See g_resolver_lookup_service() for more
             * details.
             */
            lookup_service_async(
                service: string,
                protocol: string,
                domain: string,
                cancellable?: Cancellable | null
            ): Promise<SrvTarget[]>;
            /**
             * Begins asynchronously performing a DNS SRV lookup for the given
             * `service `and `protocol `in the given domain, and eventually calls
             * callback, which must call g_resolver_lookup_service_finish() to
             * get the final result. See g_resolver_lookup_service() for more
             * details.
             */
            lookup_service_async(
                service: string,
                protocol: string,
                domain: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously performing a DNS SRV lookup for the given
             * `service `and `protocol `in the given domain, and eventually calls
             * callback, which must call g_resolver_lookup_service_finish() to
             * get the final result. See g_resolver_lookup_service() for more
             * details.
             */
            lookup_service_async(
                service: string,
                protocol: string,
                domain: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SrvTarget[]> | void;
            /**
             * Retrieves the result of a previous call to
             * g_resolver_lookup_service_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            lookup_service_finish(result: AsyncResult): SrvTarget[];
            /**
             * Sets `resolver `to be the application's default resolver (reffing
             * resolver, and unreffing the previous default resolver, if any).
             * Future calls to g_resolver_get_default() will return this resolver.
             *
             * This can be used if an application wants to perform any sort of DNS
             * caching or "pinning"; it can implement its own #GResolver that
             * calls the original default resolver for DNS operations, and
             * implements its own cache policies on top of that, and then set
             * itself as the default resolver for all later code to use.
             */
            set_default(): void;
            /**
             * Synchronously reverse-resolves `address `to determine its
             * associated hostname.
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to
             * a value from #GResolverError.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_by_address(address: InetAddress, cancellable?: Cancellable | null): string;
            /**
             * Begins asynchronously reverse-resolving `address `to determine its
             * associated hostname, and eventually calls callback, which must
             * call g_resolver_lookup_by_address_finish() to get the final result.
             */
            vfunc_lookup_by_address_async(address: InetAddress, cancellable?: Cancellable | null): Promise<string>;
            /**
             * Begins asynchronously reverse-resolving `address `to determine its
             * associated hostname, and eventually calls callback, which must
             * call g_resolver_lookup_by_address_finish() to get the final result.
             */
            vfunc_lookup_by_address_async(
                address: InetAddress,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously reverse-resolving `address `to determine its
             * associated hostname, and eventually calls callback, which must
             * call g_resolver_lookup_by_address_finish() to get the final result.
             */
            vfunc_lookup_by_address_async(
                address: InetAddress,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string> | void;
            /**
             * Retrieves the result of a previous call to
             * g_resolver_lookup_by_address_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_by_address_finish(result: AsyncResult): string;
            /**
             * Synchronously resolves `hostname `to determine its associated IP
             * address(es). `hostname `may be an ASCII-only or UTF-8 hostname, or
             * the textual form of an IP address (in which case this just becomes
             * a wrapper around g_inet_address_new_from_string()).
             *
             * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
             * #GInetAddress, sorted in order of preference and guaranteed to not
             * contain duplicates. That is, if using the result to connect to
             * hostname, you should attempt to connect to the first address
             * first, then the second if the first fails, etc. If you are using
             * the result to listen on a socket, it is appropriate to add each
             * result using e.g. g_socket_listener_add_address().
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to a
             * value from #GResolverError and %NULL will be returned.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             *
             * If you are planning to connect to a socket on the resolved IP
             * address, it may be easier to create a #GNetworkAddress and use its
             * #GSocketConnectable interface.
             */
            vfunc_lookup_by_name(hostname: string, cancellable?: Cancellable | null): InetAddress[];
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            vfunc_lookup_by_name_async(hostname: string, cancellable?: Cancellable | null): Promise<InetAddress[]>;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            vfunc_lookup_by_name_async(
                hostname: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            vfunc_lookup_by_name_async(
                hostname: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<InetAddress[]> | void;
            /**
             * Retrieves the result of a call to
             * g_resolver_lookup_by_name_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_by_name_finish(result: AsyncResult): InetAddress[];
            /**
             * This differs from g_resolver_lookup_by_name() in that you can modify
             * the lookup behavior with `flags.` For example this can be used to limit
             * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
             */
            vfunc_lookup_by_name_with_flags(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable?: Cancellable | null
            ): InetAddress[];
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            vfunc_lookup_by_name_with_flags_async(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<InetAddress[]>;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            vfunc_lookup_by_name_with_flags_async(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously resolving `hostname `to determine its
             * associated IP address(es), and eventually calls callback, which
             * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
             * See g_resolver_lookup_by_name() for more details.
             */
            vfunc_lookup_by_name_with_flags_async(
                hostname: string,
                flags: ResolverNameLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<InetAddress[]> | void;
            /**
             * Retrieves the result of a call to
             * g_resolver_lookup_by_name_with_flags_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[];
            /**
             * Synchronously performs a DNS record lookup for the given `rrname `and returns
             * a list of records as #GVariant tuples. See #GResolverRecordType for
             * information on what the records contain for each `record_type.`
             *
             * If the DNS resolution fails, `error `(if non-%NULL) will be set to
             * a value from #GResolverError and %NULL will be returned.
             *
             * If `cancellable `is non-%NULL, it can be used to cancel the
             * operation, in which case `error `(if non-%NULL) will be set to
             * %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_records(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable?: Cancellable | null
            ): GLib.Variant[];
            /**
             * Begins asynchronously performing a DNS lookup for the given
             * rrname, and eventually calls callback, which must call
             * g_resolver_lookup_records_finish() to get the final result. See
             * g_resolver_lookup_records() for more details.
             */
            vfunc_lookup_records_async(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable?: Cancellable | null
            ): Promise<GLib.Variant[]>;
            /**
             * Begins asynchronously performing a DNS lookup for the given
             * rrname, and eventually calls callback, which must call
             * g_resolver_lookup_records_finish() to get the final result. See
             * g_resolver_lookup_records() for more details.
             */
            vfunc_lookup_records_async(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Begins asynchronously performing a DNS lookup for the given
             * rrname, and eventually calls callback, which must call
             * g_resolver_lookup_records_finish() to get the final result. See
             * g_resolver_lookup_records() for more details.
             */
            vfunc_lookup_records_async(
                rrname: string,
                record_type: ResolverRecordType,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<GLib.Variant[]> | void;
            /**
             * Retrieves the result of a previous call to
             * g_resolver_lookup_records_async(). Returns a non-empty list of records as
             * #GVariant tuples. See #GResolverRecordType for information on what the
             * records contain.
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_records_finish(result: AsyncResult): GLib.Variant[];
            vfunc_lookup_service_async(rrname: string, cancellable?: Cancellable | null): Promise<SrvTarget[]>;
            vfunc_lookup_service_async(
                rrname: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            vfunc_lookup_service_async(
                rrname: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SrvTarget[]> | void;
            /**
             * Retrieves the result of a previous call to
             * g_resolver_lookup_service_async().
             *
             * If the DNS resolution failed, `error `(if non-%NULL) will be set to
             * a value from #GResolverError. If the operation was cancelled,
             * `error `will be set to %G_IO_ERROR_CANCELLED.
             */
            vfunc_lookup_service_finish(result: AsyncResult): SrvTarget[];
            vfunc_reload(): void;
            /**
             * Gets the default #GResolver. You should unref it when you are done
             * with it. #GResolver may use its reference count as a hint about how
             * many threads it should allocate for concurrent DNS resolutions.
             */
            static get_default(): Resolver;
        }
        export module Settings {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                backend: SettingsBackend;
                delay_apply: boolean;
                delayApply: boolean;
                has_unapplied: boolean;
                hasUnapplied: boolean;
                path: string;
                schema: string;
                schema_id: string;
                schemaId: string;
                settings_schema: SettingsSchema;
                settingsSchema: SettingsSchema;
            }
        }
        export class Settings extends GObject.Object {
            static $gtype: GObject.GType<Settings>;

            constructor(properties?: Partial<Settings.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Settings.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get backend(): SettingsBackend;
            get delay_apply(): boolean;
            get delayApply(): boolean;
            get has_unapplied(): boolean;
            get hasUnapplied(): boolean;
            get path(): string;
            get schema(): string;
            get schema_id(): string;
            get schemaId(): string;
            get settings_schema(): SettingsSchema;
            get settingsSchema(): SettingsSchema;

            // Fields
            _realInit: (...args: any[]) => any;
            _realMethods: typeof Settings.prototype;
            _keys: string[];
            _children: string[];

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "change-event", callback: (_source: this, keys: GLib.Quark[] | null) => boolean): number;
            connect_after(
                signal: "change-event",
                callback: (_source: this, keys: GLib.Quark[] | null) => boolean
            ): number;
            emit(signal: "change-event", keys?: GLib.Quark[] | null): void;
            connect(signal: "changed", callback: (_source: this, key: string) => void): number;
            connect_after(signal: "changed", callback: (_source: this, key: string) => void): number;
            emit(signal: "changed", key: string): void;
            connect(signal: "writable-change-event", callback: (_source: this, key: number) => boolean): number;
            connect_after(signal: "writable-change-event", callback: (_source: this, key: number) => boolean): number;
            emit(signal: "writable-change-event", key: number): void;
            connect(signal: "writable-changed", callback: (_source: this, key: string) => void): number;
            connect_after(signal: "writable-changed", callback: (_source: this, key: string) => void): number;
            emit(signal: "writable-changed", key: string): void;

            // Constructors

            static ["new"](schema_id: string): Settings;
            static new_full(schema: SettingsSchema, backend?: SettingsBackend | null, path?: string | null): Settings;
            static new_with_backend(schema_id: string, backend: SettingsBackend): Settings;
            static new_with_backend_and_path(schema_id: string, backend: SettingsBackend, path: string): Settings;
            static new_with_path(schema_id: string, path: string): Settings;

            // Members

            /**
             * Applies any changes that have been made to the settings.  This
             * function does nothing unless `settings `is in 'delay-apply' mode;
             * see g_settings_delay().  In the normal case settings are always
             * applied immediately.
             */
            apply(): void;
            /**
             * Create a binding between the `key `in the `settings `object
             * and the property `property `of `object.`
             *
             * The binding uses the default GIO mapping functions to map
             * between the settings and property values. These functions
             * handle booleans, numeric types and string types in a
             * straightforward way. Use g_settings_bind_with_mapping() if
             * you need a custom mapping, or map between types that are not
             * supported by the default mapping functions.
             *
             * Unless the `flags `include %G_SETTINGS_BIND_NO_SENSITIVITY, this
             * function also establishes a binding between the writability of
             * `key `and the "sensitive" property of `object `(if `object `has
             * a boolean property by that name). See g_settings_bind_writable()
             * for more details about writable bindings.
             *
             * Note that the lifecycle of the binding is tied to object,
             * and that you can have only one binding per object property.
             * If you bind the same property twice on the same object, the second
             * binding overrides the first one.
             */
            bind(key: string, object: GObject.Object, property: string, flags: SettingsBindFlags): void;
            /**
             * Create a binding between the writability of `key `in the
             * `settings `object and the property `property `of `object.`
             * The property must be boolean; "sensitive" or "visible"
             * properties of widgets are the most likely candidates.
             *
             * Writable bindings are always uni-directional; changes of the
             * writability of the setting will be propagated to the object
             * property, not the other way.
             *
             * When the `inverted `argument is %TRUE, the binding inverts the
             * value as it passes from the setting to the object, i.e. property
             * will be set to %TRUE if the key is not writable.
             *
             * Note that the lifecycle of the binding is tied to object,
             * and that you can have only one binding per object property.
             * If you bind the same property twice on the same object, the second
             * binding overrides the first one.
             */
            bind_writable(key: string, object: GObject.Object, property: string, inverted: boolean): void;
            /**
             * Creates a #GAction corresponding to a given #GSettings key.
             *
             * The action has the same name as the key.
             *
             * The value of the key becomes the state of the action and the action
             * is enabled when the key is writable.  Changing the state of the
             * action results in the key being written to.  Changes to the value or
             * writability of the key cause appropriate change notifications to be
             * emitted for the action.
             *
             * For boolean-valued keys, action activations take no parameter and
             * result in the toggling of the value.  For all other types,
             * activations take the new value for the key (which must have the
             * correct type).
             */
            create_action(key: string): Action;
            /**
             * Changes the #GSettings object into 'delay-apply' mode. In this
             * mode, changes to `settings `are not immediately propagated to the
             * backend, but kept locally until g_settings_apply() is called.
             */
            delay(): void;
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for booleans.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a boolean type in the schema for `settings.`
             */
            get_boolean(key: string): boolean;
            /**
             * Creates a child settings object which has a base path of
             * `base-path/name`, where `base-path` is the base path of
             * `settings.`
             *
             * The schema for the child settings object must have been declared
             * in the schema of `settings `using a `&lt;child&gt;` element.
             *
             * The created child settings object will inherit the #GSettings:delay-apply
             * mode from `settings.`
             */
            get_child(name: string): Settings;
            /**
             * Gets the "default value" of a key.
             *
             * This is the value that would be read if g_settings_reset() were to be
             * called on the key.
             *
             * Note that this may be a different value than returned by
             * g_settings_schema_key_get_default_value() if the system administrator
             * has provided a default value.
             *
             * Comparing the return values of g_settings_get_default_value() and
             * g_settings_get_value() is not sufficient for determining if a value
             * has been set because the user may have explicitly set the value to
             * something that happens to be equal to the default.  The difference
             * here is that if the default changes in the future, the user's key
             * will still be set.
             *
             * This function may be useful for adding an indication to a UI of what
             * the default value was before the user set it.
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings.`
             */
            get_default_value<T extends string = any>(key: string): GLib.Variant<T> | null;
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for doubles.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a 'double' type in the schema for `settings.`
             */
            get_double(key: string): number;
            /**
             * Gets the value that is stored in `settings `for `key `and converts it
             * to the enum value that it represents.
             *
             * In order to use this function the type of the value must be a string
             * and it must be marked in the schema file as an enumerated type.
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings `or is not marked as an enumerated type.
             *
             * If the value stored in the configuration database is not a valid
             * value for the enumerated type then this function will return the
             * default value.
             */
            get_enum(key: string): number;
            /**
             * Gets the value that is stored in `settings `for `key `and converts it
             * to the flags value that it represents.
             *
             * In order to use this function the type of the value must be an array
             * of strings and it must be marked in the schema file as a flags type.
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings `or is not marked as a flags type.
             *
             * If the value stored in the configuration database is not a valid
             * value for the flags type then this function will return the default
             * value.
             */
            get_flags(key: string): number;
            /**
             * Returns whether the #GSettings object has any unapplied
             * changes.  This can only be the case if it is in 'delayed-apply' mode.
             */
            get_has_unapplied(): boolean;
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for 32-bit integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a int32 type in the schema for `settings.`
             */
            get_int(key: string): number;
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for 64-bit integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a int64 type in the schema for `settings.`
             */
            get_int64(key: string): number;
            /**
             * Gets the value that is stored at `key `in settings, subject to
             * application-level validation/mapping.
             *
             * You should use this function when the application needs to perform
             * some processing on the value of the key (for example, parsing).  The
             * `mapping `function performs that processing.  If the function
             * indicates that the processing was unsuccessful (due to a parse error,
             * for example) then the mapping is tried again with another value.
             *
             * This allows a robust 'fall back to defaults' behaviour to be
             * implemented somewhat automatically.
             *
             * The first value that is tried is the user's setting for the key.  If
             * the mapping function fails to map this value, other values may be
             * tried in an unspecified order (system or site defaults, translated
             * schema default values, untranslated schema default values, etc).
             *
             * If the mapping function fails for all possible values, one additional
             * attempt is made: the mapping function is called with a %NULL value.
             * If the mapping function still indicates failure at this point then
             * the application will be aborted.
             *
             * The result parameter for the `mapping `function is pointed to a
             * #gpointer which is initially set to %NULL.  The same pointer is given
             * to each invocation of `mapping.`  The final value of that #gpointer is
             * what is returned by this function.  %NULL is valid; it is returned
             * just as any other value would be.
             */
            get_mapped(key: string, mapping: SettingsGetMapping): any | null;
            /**
             * Queries the range of a key.
             */
            get_range(key: string): GLib.Variant;
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for strings.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a string type in the schema for `settings.`
             */
            get_string(key: string): string;
            /**
             * A convenience variant of g_settings_get() for string arrays.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having an array of strings type in the schema for `settings.`
             */
            get_strv(key: string): string[];
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for 32-bit unsigned
             * integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a uint32 type in the schema for `settings.`
             */
            get_uint(key: string): number;
            /**
             * Gets the value that is stored at `key `in `settings.`
             *
             * A convenience variant of g_settings_get() for 64-bit unsigned
             * integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a uint64 type in the schema for `settings.`
             */
            get_uint64(key: string): number;
            /**
             * Checks the "user value" of a key, if there is one.
             *
             * The user value of a key is the last value that was set by the user.
             *
             * After calling g_settings_reset() this function should always return
             * %NULL (assuming something is not wrong with the system
             * configuration).
             *
             * It is possible that g_settings_get_value() will return a different
             * value than this function.  This can happen in the case that the user
             * set a value for a key that was subsequently locked down by the system
             * administrator -- this function will return the user's old value.
             *
             * This function may be useful for adding a "reset" option to a UI or
             * for providing indication that a particular value has been changed.
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings.`
             */
            get_user_value<T extends string = any>(key: string): GLib.Variant<T> | null;
            /**
             * Gets the value that is stored in `settings `for `key.`
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings.`
             */
            get_value<T extends string = any>(key: string): GLib.Variant<T>;
            /**
             * Finds out if a key can be written or not
             */
            is_writable(name: string): boolean;
            /**
             * Gets the list of children on `settings.`
             *
             * The list is exactly the list of strings for which it is not an error
             * to call g_settings_get_child().
             *
             * There is little reason to call this function from "normal" code, since
             * you should already know what children are in your schema. This function
             * may still be useful there for introspection reasons, however.
             *
             * You should free the return value with g_strfreev() when you are done
             * with it.
             */
            list_children(): string[];
            /**
             * Introspects the list of keys on `settings.`
             *
             * You should probably not be calling this function from "normal" code
             * (since you should already know what keys are in your schema).  This
             * function is intended for introspection reasons.
             *
             * You should free the return value with g_strfreev() when you are done
             * with it.
             */
            list_keys(): string[];
            /**
             * Checks if the given `value `is of the correct type and within the
             * permitted range for `key.`
             */
            range_check(key: string, value: GLib.Variant): boolean;
            /**
             * Resets `key `to its default value.
             *
             * This call resets the key, as much as possible, to its default value.
             * That might be the value specified in the schema or the one set by the
             * administrator.
             */
            reset(key: string): void;
            /**
             * Reverts all non-applied changes to the settings.  This function
             * does nothing unless `settings `is in 'delay-apply' mode; see
             * g_settings_delay().  In the normal case settings are always applied
             * immediately.
             *
             * Change notifications will be emitted for affected keys.
             */
            revert(): void;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for booleans.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a boolean type in the schema for `settings.`
             */
            set_boolean(key: string, value: boolean): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for doubles.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a 'double' type in the schema for `settings.`
             */
            set_double(key: string, value: number): boolean;
            /**
             * Looks up the enumerated type nick for `value `and writes it to key,
             * within `settings.`
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings `or is not marked as an enumerated type, or for
             * `value `not to be a valid value for the named type.
             *
             * After performing the write, accessing `key `directly with
             * g_settings_get_string() will return the 'nick' associated with
             * `value.`
             */
            set_enum(key: string, value: number): boolean;
            /**
             * Looks up the flags type nicks for the bits specified by value, puts
             * them in an array of strings and writes the array to key, within
             * `settings.`
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings `or is not marked as a flags type, or for value
             * to contain any bits that are not value for the named type.
             *
             * After performing the write, accessing `key `directly with
             * g_settings_get_strv() will return an array of 'nicks'; one for each
             * bit in `value.`
             */
            set_flags(key: string, value: number): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for 32-bit integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a int32 type in the schema for `settings.`
             */
            set_int(key: string, value: number): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for 64-bit integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a int64 type in the schema for `settings.`
             */
            set_int64(key: string, value: number): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for strings.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a string type in the schema for `settings.`
             */
            set_string(key: string, value: string): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for string arrays.  If
             * `value `is %NULL, then `key `is set to be the empty array.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having an array of strings type in the schema for `settings.`
             */
            set_strv(key: string, value?: string[] | null): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for 32-bit unsigned
             * integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a uint32 type in the schema for `settings.`
             */
            set_uint(key: string, value: number): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * A convenience variant of g_settings_set() for 64-bit unsigned
             * integers.
             *
             * It is a programmer error to give a `key `that isn't specified as
             * having a uint64 type in the schema for `settings.`
             */
            set_uint64(key: string, value: number): boolean;
            /**
             * Sets `key `in `settings `to `value.`
             *
             * It is a programmer error to give a `key `that isn't contained in the
             * schema for `settings `or for `value `to have the incorrect type, per
             * the schema.
             *
             * If `value `is floating then this function consumes the reference.
             */
            set_value(key: string, value: GLib.Variant): boolean;
            vfunc_change_event(keys: GLib.Quark, n_keys: number): boolean;
            vfunc_changed(key: string): void;
            vfunc_writable_change_event(key: GLib.Quark): boolean;
            vfunc_writable_changed(key: string): void;
            /**
             * Deprecated.
             */
            static list_relocatable_schemas(): string[];
            /**
             * Deprecated.
             */
            static list_schemas(): string[];
            /**
             * Ensures that all pending operations are complete for the default backend.
             *
             * Writes made to a #GSettings are handled asynchronously.  For this
             * reason, it is very unlikely that the changes have it to disk by the
             * time g_settings_set() returns.
             *
             * This call will block until all of the writes have made it to the
             * backend.  Since the mainloop is not running, no change notifications
             * will be dispatched during this call (but some may be queued by the
             * time the call is done).
             */
            static sync(): void;
            /**
             * Removes an existing binding for `property `on `object.`
             *
             * Note that bindings are automatically removed when the
             * object is finalized, so it is rarely necessary to call this
             * function.
             */
            static unbind(object: GObject.Object, property: string): void;
        }
        export module SettingsBackend {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class SettingsBackend extends GObject.Object {
            static $gtype: GObject.GType<SettingsBackend>;

            constructor(properties?: Partial<SettingsBackend.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SettingsBackend.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Signals that a single key has possibly changed.  Backend
             * implementations should call this if a key has possibly changed its
             * value.
             *
             * `key `must be a valid key (ie starting with a slash, not containing
             * '//', and not ending with a slash).
             *
             * The implementation must call this function during any call to
             * g_settings_backend_write(), before the call returns (except in the
             * case that no keys are actually changed and it cares to detect this
             * fact).  It may not rely on the existence of a mainloop for
             * dispatching the signal later.
             *
             * The implementation may call this function at any other time it likes
             * in response to other events (such as changes occurring outside of the
             * program).  These calls may originate from a mainloop or may originate
             * in response to any other action (including from calls to
             * g_settings_backend_write()).
             *
             * In the case that this call is in response to a call to
             * g_settings_backend_write() then `origin_tag `must be set to the same
             * value that was passed to that call.
             */
            changed(key: string, origin_tag?: any | null): void;
            /**
             * This call is a convenience wrapper.  It gets the list of changes from
             * tree, computes the longest common prefix and calls
             * g_settings_backend_changed().
             */
            changed_tree(tree: GLib.Tree, origin_tag?: any | null): void;
            /**
             * Signals that a list of keys have possibly changed.  Backend
             * implementations should call this if keys have possibly changed their
             * values.
             *
             * `path `must be a valid path (ie starting and ending with a slash and
             * not containing '//').  Each string in `items `must form a valid key
             * name when `path `is prefixed to it (ie: each item must not start or
             * end with '/' and must not contain '//').
             *
             * The meaning of this signal is that any of the key names resulting
             * from the contatenation of `path `with each item in `items `may have
             * changed.
             *
             * The same rules for when notifications must occur apply as per
             * g_settings_backend_changed().  These two calls can be used
             * interchangeably if exactly one item has changed (although in that
             * case g_settings_backend_changed() is definitely preferred).
             *
             * For efficiency reasons, the implementation should strive for `path `to
             * be as long as possible (ie: the longest common prefix of all of the
             * keys that were changed) but this is not strictly required.
             */
            keys_changed(path: string, items: string[], origin_tag?: any | null): void;
            /**
             * Signals that all keys below a given path may have possibly changed.
             * Backend implementations should call this if an entire path of keys
             * have possibly changed their values.
             *
             * `path `must be a valid path (ie starting and ending with a slash and
             * not containing '//').
             *
             * The meaning of this signal is that any of the key which has a name
             * starting with `path `may have changed.
             *
             * The same rules for when notifications must occur apply as per
             * g_settings_backend_changed().  This call might be an appropriate
             * reasponse to a 'reset' call but implementations are also free to
             * explicitly list the keys that were affected by that call if they can
             * easily do so.
             *
             * For efficiency reasons, the implementation should strive for `path `to
             * be as long as possible (ie: the longest common prefix of all of the
             * keys that were changed) but this is not strictly required.  As an
             * example, if this function is called with the path of "/" then every
             * single key in the application will be notified of a possible change.
             */
            path_changed(path: string, origin_tag?: any | null): void;
            /**
             * Signals that the writability of all keys below a given path may have
             * changed.
             *
             * Since GSettings performs no locking operations for itself, this call
             * will always be made in response to external events.
             */
            path_writable_changed(path: string): void;
            /**
             * Signals that the writability of a single key has possibly changed.
             *
             * Since GSettings performs no locking operations for itself, this call
             * will always be made in response to external events.
             */
            writable_changed(key: string): void;
            vfunc_get_writable(key: string): boolean;
            vfunc_read(key: string, expected_type: GLib.VariantType, default_value: boolean): GLib.Variant;
            vfunc_read_user_value(key: string, expected_type: GLib.VariantType): GLib.Variant;
            vfunc_reset(key: string, origin_tag?: any | null): void;
            vfunc_subscribe(name: string): void;
            vfunc_sync(): void;
            vfunc_unsubscribe(name: string): void;
            vfunc_write(key: string, value: GLib.Variant, origin_tag?: any | null): boolean;
            vfunc_write_tree(tree: GLib.Tree, origin_tag?: any | null): boolean;
            /**
             * Calculate the longest common prefix of all keys in a tree and write
             * out an array of the key names relative to that prefix and,
             * optionally, the value to store at each of those keys.
             *
             * You must free the value returned in path, `keys `and `values `using
             * g_free().  You should not attempt to free or unref the contents of
             * `keys `or `values.`
             */
            static flatten_tree(tree: GLib.Tree): [string, string[], GLib.Variant[] | null];
            /**
             * Returns the default #GSettingsBackend. It is possible to override
             * the default by setting the `GSETTINGS_BACKEND` environment variable
             * to the name of a settings backend.
             *
             * The user gets a reference to the backend.
             */
            static get_default(): SettingsBackend;
        }
        export module SimpleAction {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                enabled: boolean;
                name: string;
                parameter_type: GLib.VariantType;
                parameterType: GLib.VariantType;
                state: GLib.Variant;
                state_type: GLib.VariantType;
                stateType: GLib.VariantType;
            }
        }
        export class SimpleAction extends GObject.Object implements Action {
            static $gtype: GObject.GType<SimpleAction>;

            constructor(properties?: Partial<SimpleAction.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SimpleAction.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get enabled(): boolean;
            set enabled(val: boolean);
            get name(): string;
            get parameter_type(): GLib.VariantType;
            get parameterType(): GLib.VariantType;
            get state(): GLib.Variant;
            set state(val: GLib.Variant);
            get state_type(): GLib.VariantType;
            get stateType(): GLib.VariantType;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "activate", callback: (_source: this, parameter: GLib.Variant | null) => void): number;
            connect_after(
                signal: "activate",
                callback: (_source: this, parameter: GLib.Variant | null) => void
            ): number;
            emit(signal: "activate", parameter?: GLib.Variant | null): void;
            connect(signal: "change-state", callback: (_source: this, value: GLib.Variant | null) => void): number;
            connect_after(
                signal: "change-state",
                callback: (_source: this, value: GLib.Variant | null) => void
            ): number;
            emit(signal: "change-state", value?: GLib.Variant | null): void;

            // Constructors

            static ["new"](name: string, parameter_type?: GLib.VariantType | null): SimpleAction;
            static new_stateful(
                name: string,
                parameter_type: GLib.VariantType | null,
                state: GLib.Variant
            ): SimpleAction;

            // Members

            /**
             * Sets the action as enabled or not.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             *
             * This should only be called by the implementor of the action.  Users
             * of the action should not attempt to modify its enabled flag.
             */
            set_enabled(enabled: boolean): void;
            /**
             * Sets the state of the action.
             *
             * This directly updates the 'state' property to the given value.
             *
             * This should only be called by the implementor of the action.  Users
             * of the action should not attempt to directly modify the 'state'
             * property.  Instead, they should call g_action_change_state() to
             * request the change.
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            set_state(value: GLib.Variant): void;
            /**
             * Sets the state hint for the action.
             *
             * See g_action_get_state_hint() for more information about
             * action state hints.
             */
            set_state_hint(state_hint?: GLib.Variant | null): void;

            // Implemented Members

            /**
             * Activates the action.
             *
             * `parameter `must be the correct type of parameter for the action (ie:
             * the parameter type given at construction time).  If the parameter
             * type was %NULL then `parameter `must also be %NULL.
             *
             * If the `parameter `GVariant is floating, it is consumed.
             */
            activate(parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of `action `to be changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_get_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_get_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_state(value: GLib.Variant): void;
            /**
             * Checks if `action `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_enabled(): boolean;
            /**
             * Queries the name of `action.`
             */
            get_name(): string;
            /**
             * Queries the type of the parameter that must be given when activating
             * `action.`
             *
             * When activating the action using g_action_activate(), the #GVariant
             * given to that function must be of the type returned by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             */
            get_parameter_type(): GLib.VariantType | null;
            /**
             * Queries the current state of `action.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_get_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_state(): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of
             * `action.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_state_hint(): GLib.Variant | null;
            /**
             * Queries the type of the state of `action.`
             *
             * If the action is stateful (e.g. created with
             * g_simple_action_new_stateful()) then this function returns the
             * #GVariantType of the state.  This is the type of the initial value
             * given as the state. All calls to g_action_change_state() must give a
             * #GVariant of this type and g_action_get_state() will return a
             * #GVariant of the same type.
             *
             * If the action is not stateful (e.g. created with g_simple_action_new())
             * then this function will return %NULL. In that case, g_action_get_state()
             * will return %NULL and you must not call g_action_change_state().
             */
            get_state_type(): GLib.VariantType | null;
            /**
             * Activates the action.
             *
             * `parameter `must be the correct type of parameter for the action (ie:
             * the parameter type given at construction time).  If the parameter
             * type was %NULL then `parameter `must also be %NULL.
             *
             * If the `parameter `GVariant is floating, it is consumed.
             */
            vfunc_activate(parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of `action `to be changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_get_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_get_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_state(value: GLib.Variant): void;
            /**
             * Checks if `action `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_enabled(): boolean;
            /**
             * Queries the name of `action.`
             */
            vfunc_get_name(): string;
            /**
             * Queries the type of the parameter that must be given when activating
             * `action.`
             *
             * When activating the action using g_action_activate(), the #GVariant
             * given to that function must be of the type returned by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             */
            vfunc_get_parameter_type(): GLib.VariantType | null;
            /**
             * Queries the current state of `action.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_get_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_state(): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of
             * `action.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_state_hint(): GLib.Variant | null;
            /**
             * Queries the type of the state of `action.`
             *
             * If the action is stateful (e.g. created with
             * g_simple_action_new_stateful()) then this function returns the
             * #GVariantType of the state.  This is the type of the initial value
             * given as the state. All calls to g_action_change_state() must give a
             * #GVariant of this type and g_action_get_state() will return a
             * #GVariant of the same type.
             *
             * If the action is not stateful (e.g. created with g_simple_action_new())
             * then this function will return %NULL. In that case, g_action_get_state()
             * will return %NULL and you must not call g_action_change_state().
             */
            vfunc_get_state_type(): GLib.VariantType | null;
        }
        export module SimpleActionGroup {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class SimpleActionGroup extends GObject.Object implements ActionGroup, ActionMap {
            static $gtype: GObject.GType<SimpleActionGroup>;

            constructor(properties?: Partial<SimpleActionGroup.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SimpleActionGroup.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](): SimpleActionGroup;

            // Members

            /**
             * A convenience function for creating multiple #GSimpleAction instances
             * and adding them to the action group.
             */
            add_entries(entries: ActionEntry[], user_data?: any | null): void;
            /**
             * Adds an action to the action group.
             *
             * If the action group already contains an action with the same name as
             * `action `then the old action is dropped from the group.
             *
             * The action group takes its own reference on `action.`
             */
            insert(action: Action): void;
            /**
             * Looks up the action with the name `action_name `in the group.
             *
             * If no such action exists, returns %NULL.
             */
            lookup(action_name: string): Action;
            /**
             * Removes the named action from the action group.
             *
             * If no action of this name is in the group then nothing happens.
             */
            remove(action_name: string): void;

            // Implemented Members

            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            vfunc_has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            vfunc_list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            vfunc_query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Adds an action to the `action_map.`
             *
             * If the action map already contains an action with the same name
             * as `action `then the old action is dropped from the action map.
             *
             * The action map takes its own reference on `action.`
             */
            add_action(action: Action): void;
            /**
             * A convenience function for creating multiple #GSimpleAction instances
             * and adding them to a #GActionMap.
             *
             * Each action is constructed as per one #GActionEntry.
             *
             * |[&lt;!-- language="C" --&gt;
             * static void
             * activate_quit (GSimpleAction *simple,
             * GVariant      *parameter,
             * gpointer       user_data)
             * {
             * exit (0);
             * }
             *
             * static void
             * activate_print_string (GSimpleAction *simple,
             * GVariant      *parameter,
             * gpointer       user_data)
             * {
             * g_print ("%s\n", g_variant_get_string (parameter, NULL));
             * }
             *
             * static GActionGroup *
             * create_action_group (void)
             * {
             * const GActionEntry entries[] = {
             * { "quit",         activate_quit              },
             * { "print-string", activate_print_string, "s" }
             * };
             * GSimpleActionGroup *group;
             *
             * group = g_simple_action_group_new ();
             * g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
             *
             * return G_ACTION_GROUP (group);
             * }
             * ]|
             */
            add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
            /**
             * Looks up the action with the name `action_name `in `action_map.`
             *
             * If no such action exists, returns %NULL.
             */
            lookup_action(action_name: string): Action | null;
            /**
             * Removes the named action from the action map.
             *
             * If no action of this name is in the map then nothing happens.
             */
            remove_action(action_name: string): void;
            /**
             * Adds an action to the `action_map.`
             *
             * If the action map already contains an action with the same name
             * as `action `then the old action is dropped from the action map.
             *
             * The action map takes its own reference on `action.`
             */
            vfunc_add_action(action: Action): void;
            /**
             * Looks up the action with the name `action_name `in `action_map.`
             *
             * If no such action exists, returns %NULL.
             */
            vfunc_lookup_action(action_name: string): Action | null;
            /**
             * Removes the named action from the action map.
             *
             * If no action of this name is in the map then nothing happens.
             */
            vfunc_remove_action(action_name: string): void;
        }
        export module SimpleAsyncResult {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class SimpleAsyncResult extends GObject.Object implements AsyncResult {
            static $gtype: GObject.GType<SimpleAsyncResult>;

            constructor(properties?: Partial<SimpleAsyncResult.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SimpleAsyncResult.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](
                source_object?: GObject.Object | null,
                callback?: AsyncReadyCallback | null,
                source_tag?: any | null
            ): SimpleAsyncResult;
            static new_from_error(
                source_object: GObject.Object | null,
                callback: AsyncReadyCallback | null,
                error: GLib.Error
            ): SimpleAsyncResult;

            // Members

            /**
             * Completes an asynchronous I/O job immediately. Must be called in
             * the thread where the asynchronous result was to be delivered, as it
             * invokes the callback directly. If you are in a different thread use
             * g_simple_async_result_complete_in_idle().
             *
             * Calling this function takes a reference to `simple `for as long as
             * is needed to complete the call.
             */
            complete(): void;
            /**
             * Completes an asynchronous function in an idle handler in the
             * [thread-default main context][g-main-context-push-thread-default]
             * of the thread that `simple `was initially created in
             * (and re-pushes that context around the invocation of the callback).
             *
             * Calling this function takes a reference to `simple `for as long as
             * is needed to complete the call.
             */
            complete_in_idle(): void;
            /**
             * Gets the operation result boolean from within the asynchronous result.
             */
            get_op_res_gboolean(): boolean;
            /**
             * Gets a gssize from the asynchronous result.
             */
            get_op_res_gssize(): number;
            /**
             * Propagates an error from within the simple asynchronous result to
             * a given destination.
             *
             * If the #GCancellable given to a prior call to
             * g_simple_async_result_set_check_cancellable() is cancelled then this
             * function will return %TRUE with `dest `set appropriately.
             */
            propagate_error(): boolean;
            /**
             * Sets a #GCancellable to check before dispatching results.
             *
             * This function has one very specific purpose: the provided cancellable
             * is checked at the time of g_simple_async_result_propagate_error() If
             * it is cancelled, these functions will return an "Operation was
             * cancelled" error (%G_IO_ERROR_CANCELLED).
             *
             * Implementors of cancellable asynchronous functions should use this in
             * order to provide a guarantee to their callers that cancelling an
             * async operation will reliably result in an error being returned for
             * that operation (even if a positive result for the operation has
             * already been sent as an idle to the main context to be dispatched).
             *
             * The checking described above is done regardless of any call to the
             * unrelated g_simple_async_result_set_handle_cancellation() function.
             */
            set_check_cancellable(check_cancellable?: Cancellable | null): void;
            /**
             * Sets the result from a #GError.
             */
            set_from_error(error: GLib.Error): void;
            /**
             * Sets whether to handle cancellation within the asynchronous operation.
             *
             * This function has nothing to do with
             * g_simple_async_result_set_check_cancellable().  It only refers to the
             * #GCancellable passed to g_simple_async_result_run_in_thread().
             */
            set_handle_cancellation(handle_cancellation: boolean): void;
            /**
             * Sets the operation result to a boolean within the asynchronous result.
             */
            set_op_res_gboolean(op_res: boolean): void;
            /**
             * Sets the operation result within the asynchronous result to
             * the given `op_res.`
             */
            set_op_res_gssize(op_res: number): void;
            /**
             * Ensures that the data passed to the _finish function of an async
             * operation is consistent.  Three checks are performed.
             *
             * First, `result `is checked to ensure that it is really a
             * #GSimpleAsyncResult.  Second, `source `is checked to ensure that it
             * matches the source object of `result.`  Third, `source_tag `is
             * checked to ensure that it is equal to the `source_tag `argument given
             * to g_simple_async_result_new() (which, by convention, is a pointer
             * to the _async function corresponding to the _finish function from
             * which this function is called).  (Alternatively, if either
             * `source_tag `or result's source tag is %NULL, then the source tag
             * check is skipped.)
             */
            static is_valid(result: AsyncResult, source?: GObject.Object | null, source_tag?: any | null): boolean;

            // Implemented Members

            /**
             * Gets the source object from a #GAsyncResult.
             */
            get_source_object<T = GObject.Object>(): T;
            /**
             * Gets the user data from a #GAsyncResult.
             */
            get_user_data(): any | null;
            /**
             * Checks if `res `has the given `source_tag `(generally a function
             * pointer indicating the function `res `was created by).
             */
            is_tagged(source_tag?: any | null): boolean;
            /**
             * If `res `is a #GSimpleAsyncResult, this is equivalent to
             * g_simple_async_result_propagate_error(). Otherwise it returns
             * %FALSE.
             *
             * This can be used for legacy error handling in async *_finish()
             * wrapper functions that traditionally handled #GSimpleAsyncResult
             * error returns themselves rather than calling into the virtual method.
             * This should not be used in new code; #GAsyncResult errors that are
             * set by virtual methods should also be extracted by virtual methods,
             * to enable subclasses to chain up correctly.
             */
            legacy_propagate_error(): boolean;
            /**
             * Gets the source object from a #GAsyncResult.
             */
            vfunc_get_source_object<T = GObject.Object>(): T;
            /**
             * Gets the user data from a #GAsyncResult.
             */
            vfunc_get_user_data(): any | null;
            /**
             * Checks if `res `has the given `source_tag `(generally a function
             * pointer indicating the function `res `was created by).
             */
            vfunc_is_tagged(source_tag?: any | null): boolean;
        }
        export module SimpleIOStream {
            export interface ConstructorProperties extends IOStream.ConstructorProperties {
                [key: string]: any;
                input_stream: InputStream;
                inputStream: InputStream;
                output_stream: OutputStream;
                outputStream: OutputStream;
            }
        }
        export class SimpleIOStream extends IOStream {
            static $gtype: GObject.GType<SimpleIOStream>;

            constructor(properties?: Partial<SimpleIOStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SimpleIOStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get input_stream(): InputStream;
            get inputStream(): InputStream;
            get output_stream(): OutputStream;
            get outputStream(): OutputStream;

            // Constructors

            static ["new"](input_stream: InputStream, output_stream: OutputStream): SimpleIOStream;
        }
        export module SimplePermission {
            export interface ConstructorProperties extends Permission.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class SimplePermission extends Permission {
            static $gtype: GObject.GType<SimplePermission>;

            constructor(properties?: Partial<SimplePermission.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SimplePermission.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](allowed: boolean): SimplePermission;
        }
        export module SimpleProxyResolver {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                default_proxy: string;
                defaultProxy: string;
                ignore_hosts: string[];
                ignoreHosts: string[];
            }
        }
        export class SimpleProxyResolver extends GObject.Object implements ProxyResolver {
            static $gtype: GObject.GType<SimpleProxyResolver>;

            constructor(properties?: Partial<SimpleProxyResolver.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SimpleProxyResolver.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get default_proxy(): string;
            set default_proxy(val: string);
            get defaultProxy(): string;
            set defaultProxy(val: string);
            get ignore_hosts(): string[];
            set ignore_hosts(val: string[]);
            get ignoreHosts(): string[];
            set ignoreHosts(val: string[]);

            // Members

            /**
             * Sets the default proxy on resolver, to be used for any URIs that
             * don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
             * via g_simple_proxy_resolver_set_uri_proxy().
             *
             * If `default_proxy `starts with "socks://",
             * #GSimpleProxyResolver will treat it as referring to all three of
             * the socks5, socks4a, and socks4 proxy types.
             */
            set_default_proxy(default_proxy?: string | null): void;
            /**
             * Sets the list of ignored hosts.
             *
             * See #GSimpleProxyResolver:ignore-hosts for more details on how the
             * `ignore_hosts `argument is interpreted.
             */
            set_ignore_hosts(ignore_hosts: string[]): void;
            /**
             * Adds a URI-scheme-specific proxy to resolver; URIs whose scheme
             * matches `uri_scheme `(and which don't match
             * #GSimpleProxyResolver:ignore-hosts) will be proxied via `proxy.`
             *
             * As with #GSimpleProxyResolver:default-proxy, if `proxy `starts with
             * "socks://", #GSimpleProxyResolver will treat it
             * as referring to all three of the socks5, socks4a, and socks4 proxy
             * types.
             */
            set_uri_proxy(uri_scheme: string, proxy: string): void;
            /**
             * Creates a new #GSimpleProxyResolver. See
             * #GSimpleProxyResolver:default-proxy and
             * #GSimpleProxyResolver:ignore-hosts for more details on how the
             * arguments are interpreted.
             */
            static new(default_proxy?: string | null, ignore_hosts?: string[] | null): ProxyResolver;

            // Implemented Members

            /**
             * Checks if `resolver `can be used on this system. (This is used
             * internally; g_proxy_resolver_get_default() will only return a proxy
             * resolver that returns %TRUE for this method.)
             */
            is_supported(): boolean;
            /**
             * Looks into the system proxy configuration to determine what proxy,
             * if any, to use to connect to `uri.` The returned proxy URIs are of
             * the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
             * `direct://`, where &lt;protocol&gt; could be http, rtsp, socks
             * or other proxying protocol.
             *
             * If you don't know what network protocol is being used on the
             * socket, you should use `none` as the URI protocol.
             * In this case, the resolver might still return a generic proxy type
             * (such as SOCKS), but would not return protocol-specific proxy types
             * (such as http).
             *
             * `direct://` is used when no proxy is needed.
             * Direct connection should not be attempted unless it is part of the
             * returned array of proxies.
             */
            lookup(uri: string, cancellable?: Cancellable | null): string[];
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            lookup_async(uri: string, cancellable?: Cancellable | null): Promise<string[]>;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            lookup_async(uri: string, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            lookup_async(
                uri: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string[]> | void;
            /**
             * Call this function to obtain the array of proxy URIs when
             * g_proxy_resolver_lookup_async() is complete. See
             * g_proxy_resolver_lookup() for more details.
             */
            lookup_finish(result: AsyncResult): string[];
            /**
             * Checks if `resolver `can be used on this system. (This is used
             * internally; g_proxy_resolver_get_default() will only return a proxy
             * resolver that returns %TRUE for this method.)
             */
            vfunc_is_supported(): boolean;
            /**
             * Looks into the system proxy configuration to determine what proxy,
             * if any, to use to connect to `uri.` The returned proxy URIs are of
             * the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
             * `direct://`, where &lt;protocol&gt; could be http, rtsp, socks
             * or other proxying protocol.
             *
             * If you don't know what network protocol is being used on the
             * socket, you should use `none` as the URI protocol.
             * In this case, the resolver might still return a generic proxy type
             * (such as SOCKS), but would not return protocol-specific proxy types
             * (such as http).
             *
             * `direct://` is used when no proxy is needed.
             * Direct connection should not be attempted unless it is part of the
             * returned array of proxies.
             */
            vfunc_lookup(uri: string, cancellable?: Cancellable | null): string[];
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            vfunc_lookup_async(uri: string, cancellable?: Cancellable | null): Promise<string[]>;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            vfunc_lookup_async(
                uri: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            vfunc_lookup_async(
                uri: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string[]> | void;
            /**
             * Call this function to obtain the array of proxy URIs when
             * g_proxy_resolver_lookup_async() is complete. See
             * g_proxy_resolver_lookup() for more details.
             */
            vfunc_lookup_finish(result: AsyncResult): string[];
        }
        export module Socket {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                blocking: boolean;
                broadcast: boolean;
                family: SocketFamily;
                fd: number;
                keepalive: boolean;
                listen_backlog: number;
                listenBacklog: number;
                local_address: SocketAddress;
                localAddress: SocketAddress;
                multicast_loopback: boolean;
                multicastLoopback: boolean;
                multicast_ttl: number;
                multicastTtl: number;
                protocol: SocketProtocol;
                remote_address: SocketAddress;
                remoteAddress: SocketAddress;
                timeout: number;
                ttl: number;
                type: SocketType;
            }
        }
        export class Socket extends GObject.Object implements DatagramBased, Initable {
            static $gtype: GObject.GType<Socket>;

            constructor(properties?: Partial<Socket.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Socket.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get blocking(): boolean;
            set blocking(val: boolean);
            get broadcast(): boolean;
            set broadcast(val: boolean);
            get family(): SocketFamily;
            get fd(): number;
            get keepalive(): boolean;
            set keepalive(val: boolean);
            get listen_backlog(): number;
            set listen_backlog(val: number);
            get listenBacklog(): number;
            set listenBacklog(val: number);
            get local_address(): SocketAddress;
            get localAddress(): SocketAddress;
            get multicast_loopback(): boolean;
            set multicast_loopback(val: boolean);
            get multicastLoopback(): boolean;
            set multicastLoopback(val: boolean);
            get multicast_ttl(): number;
            set multicast_ttl(val: number);
            get multicastTtl(): number;
            set multicastTtl(val: number);
            get protocol(): SocketProtocol;
            get remote_address(): SocketAddress;
            get remoteAddress(): SocketAddress;
            get timeout(): number;
            set timeout(val: number);
            get ttl(): number;
            set ttl(val: number);
            get type(): SocketType;

            // Constructors

            static ["new"](family: SocketFamily, type: SocketType, protocol: SocketProtocol): Socket;
            static new_from_fd(fd: number): Socket;

            // Members

            /**
             * Accept incoming connections on a connection-based socket. This removes
             * the first outstanding connection request from the listening socket and
             * creates a #GSocket object for it.
             *
             * The `socket `must be bound to a local address with g_socket_bind() and
             * must be listening for incoming connections (g_socket_listen()).
             *
             * If there are no outstanding connections then the operation will block
             * or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
             * To be notified of an incoming connection, wait for the %G_IO_IN condition.
             */
            accept(cancellable?: Cancellable | null): Socket;
            /**
             * When a socket is created it is attached to an address family, but it
             * doesn't have an address in this family. g_socket_bind() assigns the
             * address (sometimes called name) of the socket.
             *
             * It is generally required to bind to a local address before you can
             * receive connections. (See g_socket_listen() and g_socket_accept() ).
             * In certain situations, you may also want to bind a socket that will be
             * used to initiate connections, though this is not normally required.
             *
             * If `socket `is a TCP socket, then `allow_reuse `controls the setting
             * of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
             * server sockets (sockets that you will eventually call
             * g_socket_accept() on), and %FALSE for client sockets. (Failing to
             * set this flag on a server socket may cause g_socket_bind() to return
             * %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
             * immediately restarted.)
             *
             * If `socket `is a UDP socket, then `allow_reuse `determines whether or
             * not other UDP sockets can be bound to the same address at the same
             * time. In particular, you can have several UDP sockets bound to the
             * same address, and they will all receive all of the multicast and
             * broadcast packets sent to that address. (The behavior of unicast
             * UDP packets to an address with multiple listeners is not defined.)
             */
            bind(address: SocketAddress, allow_reuse: boolean): boolean;
            /**
             * Checks and resets the pending connect error for the socket.
             * This is used to check for errors when g_socket_connect() is
             * used in non-blocking mode.
             */
            check_connect_result(): boolean;
            /**
             * Closes the socket, shutting down any active connection.
             *
             * Closing a socket does not wait for all outstanding I/O operations
             * to finish, so the caller should not rely on them to be guaranteed
             * to complete even if the close returns with no error.
             *
             * Once the socket is closed, all other operations will return
             * %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
             * return an error.
             *
             * Sockets will be automatically closed when the last reference
             * is dropped, but you might want to call this function to make sure
             * resources are released as early as possible.
             *
             * Beware that due to the way that TCP works, it is possible for
             * recently-sent data to be lost if either you close a socket while the
             * %G_IO_IN condition is set, or else if the remote connection tries to
             * send something to you after you close the socket but before it has
             * finished reading all of the data you sent. There is no easy generic
             * way to avoid this problem; the easiest fix is to design the network
             * protocol such that the client will never send data "out of turn".
             * Another solution is for the server to half-close the connection by
             * calling g_socket_shutdown() with only the `shutdown_write `flag set,
             * and then wait for the client to notice this and close its side of the
             * connection, after which the server can safely call g_socket_close().
             * (This is what #GTcpConnection does if you call
             * g_tcp_connection_set_graceful_disconnect(). But of course, this
             * only works if the client will close its connection after the server
             * does.)
             */
            close(): boolean;
            /**
             * Checks on the readiness of `socket `to perform operations.
             * The operations specified in `condition `are checked for and masked
             * against the currently-satisfied conditions on `socket.` The result
             * is returned.
             *
             * Note that on Windows, it is possible for an operation to return
             * %G_IO_ERROR_WOULD_BLOCK even immediately after
             * g_socket_condition_check() has claimed that the socket is ready for
             * writing. Rather than calling g_socket_condition_check() and then
             * writing to the socket if it succeeds, it is generally better to
             * simply try writing to the socket right away, and try again later if
             * the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
             * these conditions will always be set in the output if they are true.
             *
             * This call never blocks.
             */
            condition_check(condition: GLib.IOCondition): GLib.IOCondition;
            /**
             * Waits for up to `timeout_us `microseconds for `condition `to become true
             * on `socket.` If the condition is met, %TRUE is returned.
             *
             * If `cancellable `is cancelled before the condition is met, or if
             * `timeout_us `(or the socket's #GSocket:timeout) is reached before the
             * condition is met, then %FALSE is returned and error, if non-%NULL,
             * is set to the appropriate value (%G_IO_ERROR_CANCELLED or
             * %G_IO_ERROR_TIMED_OUT).
             *
             * If you don't want a timeout, use g_socket_condition_wait().
             * (Alternatively, you can pass -1 for `timeout_us.`)
             *
             * Note that although `timeout_us `is in microseconds for consistency with
             * other GLib APIs, this function actually only has millisecond
             * resolution, and the behavior is undefined if `timeout_us `is not an
             * exact number of milliseconds.
             */
            condition_timed_wait(
                condition: GLib.IOCondition,
                timeout_us: number,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Waits for `condition `to become true on `socket.` When the condition
             * is met, %TRUE is returned.
             *
             * If `cancellable `is cancelled before the condition is met, or if the
             * socket has a timeout set and it is reached before the condition is
             * met, then %FALSE is returned and error, if non-%NULL, is set to
             * the appropriate value (%G_IO_ERROR_CANCELLED or
             * %G_IO_ERROR_TIMED_OUT).
             *
             * See also g_socket_condition_timed_wait().
             */
            condition_wait(condition: GLib.IOCondition, cancellable?: Cancellable | null): boolean;
            // Conflicted with Gio.DatagramBased.condition_wait
            condition_wait(...args: never[]): any;
            /**
             * Connect the socket to the specified remote address.
             *
             * For connection oriented socket this generally means we attempt to make
             * a connection to the `address.` For a connection-less socket it sets
             * the default address for g_socket_send() and discards all incoming datagrams
             * from other sources.
             *
             * Generally connection oriented sockets can only connect once, but
             * connection-less sockets can connect multiple times to change the
             * default address.
             *
             * If the connect call needs to do network I/O it will block, unless
             * non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
             * and the user can be notified of the connection finishing by waiting
             * for the G_IO_OUT condition. The result of the connection must then be
             * checked with g_socket_check_connect_result().
             */
            connect(address: SocketAddress, cancellable?: Cancellable | null): boolean;
            connect(...args: never[]): any;
            /**
             * Creates a #GSocketConnection subclass of the right type for
             * `socket.`
             */
            connection_factory_create_connection(): SocketConnection;
            /**
             * Get the amount of data pending in the OS input buffer, without blocking.
             *
             * If `socket `is a UDP or SCTP socket, this will return the size of
             * just the next packet, even if additional packets are buffered after
             * that one.
             *
             * Note that on Windows, this function is rather inefficient in the
             * UDP case, and so if you know any plausible upper bound on the size
             * of the incoming packet, it is better to just do a
             * g_socket_receive() with a buffer of that size, rather than calling
             * g_socket_get_available_bytes() first and then doing a receive of
             * exactly the right size.
             */
            get_available_bytes(): number;
            /**
             * Gets the blocking mode of the socket. For details on blocking I/O,
             * see g_socket_set_blocking().
             */
            get_blocking(): boolean;
            /**
             * Gets the broadcast setting on socket; if %TRUE,
             * it is possible to send packets to broadcast
             * addresses.
             */
            get_broadcast(): boolean;
            /**
             * Returns the credentials of the foreign process connected to this
             * socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
             * sockets).
             *
             * If this operation isn't supported on the OS, the method fails with
             * the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
             * by reading the %SO_PEERCRED option on the underlying socket.
             *
             * This method can be expected to be available on the following platforms:
             *
             * - Linux since GLib 2.26
             * - OpenBSD since GLib 2.30
             * - Solaris, Illumos and OpenSolaris since GLib 2.40
             * - NetBSD since GLib 2.42
             * - macOS, tvOS, iOS since GLib 2.66
             *
             * Other ways to obtain credentials from a foreign peer includes the
             * #GUnixCredentialsMessage type and
             * g_unix_connection_send_credentials() /
             * g_unix_connection_receive_credentials() functions.
             */
            get_credentials(): Credentials;
            /**
             * Gets the socket family of the socket.
             */
            get_family(): SocketFamily;
            /**
             * Returns the underlying OS socket object. On unix this
             * is a socket file descriptor, and on Windows this is
             * a Winsock2 SOCKET handle. This may be useful for
             * doing platform specific or otherwise unusual operations
             * on the socket.
             */
            get_fd(): number;
            /**
             * Gets the keepalive mode of the socket. For details on this,
             * see g_socket_set_keepalive().
             */
            get_keepalive(): boolean;
            /**
             * Gets the listen backlog setting of the socket. For details on this,
             * see g_socket_set_listen_backlog().
             */
            get_listen_backlog(): number;
            /**
             * Try to get the local address of a bound socket. This is only
             * useful if the socket has been bound to a local address,
             * either explicitly or implicitly when connecting.
             */
            get_local_address(): SocketAddress;
            /**
             * Gets the multicast loopback setting on socket; if %TRUE (the
             * default), outgoing multicast packets will be looped back to
             * multicast listeners on the same host.
             */
            get_multicast_loopback(): boolean;
            /**
             * Gets the multicast time-to-live setting on socket; see
             * g_socket_set_multicast_ttl() for more details.
             */
            get_multicast_ttl(): number;
            /**
             * Gets the value of an integer-valued option on socket, as with
             * getsockopt(). (If you need to fetch a  non-integer-valued option,
             * you will need to call getsockopt() directly.)
             *
             * The [&lt;gio/gnetworking.h&gt;][gio-gnetworking.h]
             * header pulls in system headers that will define most of the
             * standard/portable socket options. For unusual socket protocols or
             * platform-dependent options, you may need to include additional
             * headers.
             *
             * Note that even for socket options that are a single byte in size,
             * `value `is still a pointer to a #gint variable, not a #guchar;
             * g_socket_get_option() will handle the conversion internally.
             */
            get_option(level: number, optname: number): [boolean, number];
            /**
             * Gets the socket protocol id the socket was created with.
             * In case the protocol is unknown, -1 is returned.
             */
            get_protocol(): SocketProtocol;
            /**
             * Try to get the remote address of a connected socket. This is only
             * useful for connection oriented sockets that have been connected.
             */
            get_remote_address(): SocketAddress;
            /**
             * Gets the socket type of the socket.
             */
            get_socket_type(): SocketType;
            /**
             * Gets the timeout setting of the socket. For details on this, see
             * g_socket_set_timeout().
             */
            get_timeout(): number;
            /**
             * Gets the unicast time-to-live setting on socket; see
             * g_socket_set_ttl() for more details.
             */
            get_ttl(): number;
            /**
             * Checks whether a socket is closed.
             */
            is_closed(): boolean;
            /**
             * Check whether the socket is connected. This is only useful for
             * connection-oriented sockets.
             *
             * If using g_socket_shutdown(), this function will return %TRUE until the
             * socket has been shut down for reading and writing. If you do a non-blocking
             * connect, this function will not return %TRUE until after you call
             * g_socket_check_connect_result().
             */
            is_connected(): boolean;
            /**
             * Registers `socket `to receive multicast messages sent to `group.`
             * `socket `must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
             * been bound to an appropriate interface and port with
             * g_socket_bind().
             *
             * If `iface `is %NULL, the system will automatically pick an interface
             * to bind to based on `group.`
             *
             * If `source_specific `is %TRUE, source-specific multicast as defined
             * in RFC 4604 is used. Note that on older platforms this may fail
             * with a %G_IO_ERROR_NOT_SUPPORTED error.
             *
             * To bind to a given source-specific multicast address, use
             * g_socket_join_multicast_group_ssm() instead.
             */
            join_multicast_group(group: InetAddress, source_specific: boolean, iface?: string | null): boolean;
            /**
             * Registers `socket `to receive multicast messages sent to `group.`
             * `socket `must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
             * been bound to an appropriate interface and port with
             * g_socket_bind().
             *
             * If `iface `is %NULL, the system will automatically pick an interface
             * to bind to based on `group.`
             *
             * If `source_specific `is not %NULL, use source-specific multicast as
             * defined in RFC 4604. Note that on older platforms this may fail
             * with a %G_IO_ERROR_NOT_SUPPORTED error.
             *
             * Note that this function can be called multiple times for the same
             * `group `with different `source_specific `in order to receive multicast
             * packets from more than one source.
             */
            join_multicast_group_ssm(
                group: InetAddress,
                source_specific?: InetAddress | null,
                iface?: string | null
            ): boolean;
            /**
             * Removes `socket `from the multicast group defined by group, iface,
             * and `source_specific `(which must all have the same values they had
             * when you joined the group).
             *
             * `socket `remains bound to its address and port, and can still receive
             * unicast messages after calling this.
             *
             * To unbind to a given source-specific multicast address, use
             * g_socket_leave_multicast_group_ssm() instead.
             */
            leave_multicast_group(group: InetAddress, source_specific: boolean, iface?: string | null): boolean;
            /**
             * Removes `socket `from the multicast group defined by group, iface,
             * and `source_specific `(which must all have the same values they had
             * when you joined the group).
             *
             * `socket `remains bound to its address and port, and can still receive
             * unicast messages after calling this.
             */
            leave_multicast_group_ssm(
                group: InetAddress,
                source_specific?: InetAddress | null,
                iface?: string | null
            ): boolean;
            /**
             * Marks the socket as a server socket, i.e. a socket that is used
             * to accept incoming requests using g_socket_accept().
             *
             * Before calling this the socket must be bound to a local address using
             * g_socket_bind().
             *
             * To set the maximum amount of outstanding clients, use
             * g_socket_set_listen_backlog().
             */
            listen(): boolean;
            /**
             * Receive data (up to `size `bytes) from a socket. This is mainly used by
             * connection-oriented sockets; it is identical to g_socket_receive_from()
             * with `address `set to %NULL.
             *
             * For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
             * g_socket_receive() will always read either 0 or 1 complete messages from
             * the socket. If the received message is too large to fit in buffer, then
             * the data beyond `size `bytes will be discarded, without any explicit
             * indication that this has occurred.
             *
             * For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
             * number of bytes, up to `size.` If more than `size `bytes have been
             * received, the additional data will be returned in future calls to
             * g_socket_receive().
             *
             * If the socket is in blocking mode the call will block until there
             * is some data to receive, the connection is closed, or there is an
             * error. If there is no data available and the socket is in
             * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
             * returned. To be notified when data is available, wait for the
             * %G_IO_IN condition.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            receive(cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Receive data (up to `size `bytes) from a socket.
             *
             * If `address `is non-%NULL then `address `will be set equal to the
             * source address of the received packet.
             * `address `is owned by the caller.
             *
             * See g_socket_receive() for additional information.
             */
            receive_from(cancellable?: Cancellable | null): [number, SocketAddress | null, Uint8Array];
            /**
             * Receive data from a socket.  For receiving multiple messages, see
             * g_socket_receive_messages(); for easier use, see
             * g_socket_receive() and g_socket_receive_from().
             *
             * If `address `is non-%NULL then `address `will be set equal to the
             * source address of the received packet.
             * `address `is owned by the caller.
             *
             * `vector `must point to an array of #GInputVector structs and
             * `num_vectors `must be the length of this array.  These structs
             * describe the buffers that received data will be scattered into.
             * If `num_vectors `is -1, then `vectors `is assumed to be terminated
             * by a #GInputVector with a %NULL buffer pointer.
             *
             * As a special case, if `num_vectors `is 0 (in which case, vectors
             * may of course be %NULL), then a single byte is received and
             * discarded. This is to facilitate the common practice of sending a
             * single '\0' byte for the purposes of transferring ancillary data.
             *
             * messages, if non-%NULL, will be set to point to a newly-allocated
             * array of #GSocketControlMessage instances or %NULL if no such
             * messages was received. These correspond to the control messages
             * received from the kernel, one #GSocketControlMessage per message
             * from the kernel. This array is %NULL-terminated and must be freed
             * by the caller using g_free() after calling g_object_unref() on each
             * element. If `messages `is %NULL, any control messages received will
             * be discarded.
             *
             * num_messages, if non-%NULL, will be set to the number of control
             * messages received.
             *
             * If both `messages `and `num_messages `are non-%NULL, then
             * `num_messages `gives the number of #GSocketControlMessage instances
             * in `messages `(ie: not including the %NULL terminator).
             *
             * `flags `is an in/out parameter. The commonly available arguments
             * for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too
             * (and g_socket_receive_message() may pass system-specific flags out).
             * Flags passed in to the parameter affect the receive operation; flags returned
             * out of it are relevant to the specific returned message.
             *
             * As with g_socket_receive(), data may be discarded if `socket `is
             * %G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
             * provide enough buffer space to read a complete message. You can pass
             * %G_SOCKET_MSG_PEEK in `flags `to peek at the current message without
             * removing it from the receive queue, but there is no portable way to find
             * out the length of the message other than by reading it into a
             * sufficiently-large buffer.
             *
             * If the socket is in blocking mode the call will block until there
             * is some data to receive, the connection is closed, or there is an
             * error. If there is no data available and the socket is in
             * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
             * returned. To be notified when data is available, wait for the
             * %G_IO_IN condition.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            receive_message(
                vectors: InputVector[],
                flags: number,
                cancellable?: Cancellable | null
            ): [number, SocketAddress | null, SocketControlMessage[] | null, number];
            /**
             * Receive multiple data messages from `socket `in one go.  This is the most
             * complicated and fully-featured version of this call. For easier use, see
             * g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
             *
             * `messages `must point to an array of #GInputMessage structs and
             * `num_messages `must be the length of this array. Each #GInputMessage
             * contains a pointer to an array of #GInputVector structs describing the
             * buffers that the data received in each message will be written to. Using
             * multiple #GInputVectors is more memory-efficient than manually copying data
             * out of a single buffer to multiple sources, and more system-call-efficient
             * than making multiple calls to g_socket_receive(), such as in scenarios where
             * a lot of data packets need to be received (e.g. high-bandwidth video
             * streaming over RTP/UDP).
             *
             * `flags `modify how all messages are received. The commonly available
             * arguments for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too. These
             * flags affect the overall receive operation. Flags affecting individual
             * messages are returned in #GInputMessage.flags.
             *
             * The other members of #GInputMessage are treated as described in its
             * documentation.
             *
             * If #GSocket:blocking is %TRUE the call will block until `num_messages `have
             * been received, or the end of the stream is reached.
             *
             * If #GSocket:blocking is %FALSE the call will return up to num_messages
             * without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
             * operating system to be received.
             *
             * In blocking mode, if #GSocket:timeout is positive and is reached before any
             * messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
             * `num_messages `are returned. (Note: This is effectively the
             * behaviour of `MSG_WAITFORONE` with recvmmsg().)
             *
             * To be notified when messages are available, wait for the
             * %G_IO_IN condition. Note though that you may still receive
             * %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
             * previously notified of a %G_IO_IN condition.
             *
             * If the remote peer closes the connection, any messages queued in the
             * operating system will be returned, and subsequent calls to
             * g_socket_receive_messages() will return 0 (with no error set).
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be received; otherwise the number of
             * messages successfully received before the error will be returned.
             */
            receive_messages(messages: InputMessage[], flags: number, cancellable?: Cancellable | null): number;
            // Conflicted with Gio.DatagramBased.receive_messages
            receive_messages(...args: never[]): any;
            /**
             * This behaves exactly the same as g_socket_receive(), except that
             * the choice of blocking or non-blocking behavior is determined by
             * the `blocking `argument rather than by socket's properties.
             */
            receive_with_blocking(blocking: boolean, cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Tries to send `size `bytes from `buffer `on the socket. This is
             * mainly used by connection-oriented sockets; it is identical to
             * g_socket_send_to() with `address `set to %NULL.
             *
             * If the socket is in blocking mode the call will block until there is
             * space for the data in the socket queue. If there is no space available
             * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
             * will be returned. To be notified when space is available, wait for the
             * %G_IO_OUT condition. Note though that you may still receive
             * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
             * notified of a %G_IO_OUT condition. (On Windows in particular, this is
             * very common due to the way the underlying APIs work.)
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            send(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
            /**
             * Send data to `address `on `socket.`  For sending multiple messages see
             * g_socket_send_messages(); for easier use, see
             * g_socket_send() and g_socket_send_to().
             *
             * If `address `is %NULL then the message is sent to the default receiver
             * (set by g_socket_connect()).
             *
             * `vectors `must point to an array of #GOutputVector structs and
             * `num_vectors `must be the length of this array. (If `num_vectors `is -1,
             * then `vectors `is assumed to be terminated by a #GOutputVector with a
             * %NULL buffer pointer.) The #GOutputVector structs describe the buffers
             * that the sent data will be gathered from. Using multiple
             * #GOutputVectors is more memory-efficient than manually copying
             * data from multiple sources into a single buffer, and more
             * network-efficient than making multiple calls to g_socket_send().
             *
             * messages, if non-%NULL, is taken to point to an array of num_messages
             * #GSocketControlMessage instances. These correspond to the control
             * messages to be sent on the socket.
             * If `num_messages `is -1 then `messages `is treated as a %NULL-terminated
             * array.
             *
             * `flags `modify how the message is sent. The commonly available arguments
             * for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too.
             *
             * If the socket is in blocking mode the call will block until there is
             * space for the data in the socket queue. If there is no space available
             * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
             * will be returned. To be notified when space is available, wait for the
             * %G_IO_OUT condition. Note though that you may still receive
             * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
             * notified of a %G_IO_OUT condition. (On Windows in particular, this is
             * very common due to the way the underlying APIs work.)
             *
             * The sum of the sizes of each #GOutputVector in vectors must not be
             * greater than %G_MAXSSIZE. If the message can be larger than this,
             * then it is mandatory to use the g_socket_send_message_with_timeout()
             * function.
             *
             * On error -1 is returned and `error `is set accordingly.
             */
            send_message(
                address: SocketAddress | null,
                vectors: OutputVector[],
                messages: SocketControlMessage[] | null,
                flags: number,
                cancellable?: Cancellable | null
            ): number;
            /**
             * This behaves exactly the same as g_socket_send_message(), except that
             * the choice of timeout behavior is determined by the `timeout_us `argument
             * rather than by socket's properties.
             *
             * On error %G_POLLABLE_RETURN_FAILED is returned and `error `is set accordingly, or
             * if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
             * returned. `bytes_written `will contain 0 in both cases.
             */
            send_message_with_timeout(
                address: SocketAddress | null,
                vectors: OutputVector[],
                messages: SocketControlMessage[] | null,
                flags: number,
                timeout_us: number,
                cancellable?: Cancellable | null
            ): [PollableReturn, number];
            /**
             * Send multiple data messages from `socket `in one go.  This is the most
             * complicated and fully-featured version of this call. For easier use, see
             * g_socket_send(), g_socket_send_to(), and g_socket_send_message().
             *
             * `messages `must point to an array of #GOutputMessage structs and
             * `num_messages `must be the length of this array. Each #GOutputMessage
             * contains an address to send the data to, and a pointer to an array of
             * #GOutputVector structs to describe the buffers that the data to be sent
             * for each message will be gathered from. Using multiple #GOutputVectors is
             * more memory-efficient than manually copying data from multiple sources
             * into a single buffer, and more network-efficient than making multiple
             * calls to g_socket_send(). Sending multiple messages in one go avoids the
             * overhead of making a lot of syscalls in scenarios where a lot of data
             * packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
             * or where the same data needs to be sent to multiple recipients.
             *
             * `flags `modify how the message is sent. The commonly available arguments
             * for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too.
             *
             * If the socket is in blocking mode the call will block until there is
             * space for all the data in the socket queue. If there is no space available
             * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
             * will be returned if no data was written at all, otherwise the number of
             * messages sent will be returned. To be notified when space is available,
             * wait for the %G_IO_OUT condition. Note though that you may still receive
             * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
             * notified of a %G_IO_OUT condition. (On Windows in particular, this is
             * very common due to the way the underlying APIs work.)
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be sent; otherwise the number of messages
             * successfully sent before the error will be returned.
             */
            send_messages(messages: OutputMessage[], flags: number, cancellable?: Cancellable | null): number;
            // Conflicted with Gio.DatagramBased.send_messages
            send_messages(...args: never[]): any;
            /**
             * Tries to send `size `bytes from `buffer `to `address.` If `address `is
             * %NULL then the message is sent to the default receiver (set by
             * g_socket_connect()).
             *
             * See g_socket_send() for additional information.
             */
            send_to(
                address: SocketAddress | null,
                buffer: Uint8Array | string,
                cancellable?: Cancellable | null
            ): number;
            /**
             * This behaves exactly the same as g_socket_send(), except that
             * the choice of blocking or non-blocking behavior is determined by
             * the `blocking `argument rather than by socket's properties.
             */
            send_with_blocking(
                buffer: Uint8Array | string,
                blocking: boolean,
                cancellable?: Cancellable | null
            ): number;
            /**
             * Sets the blocking mode of the socket. In blocking mode
             * all operations (which don’t take an explicit blocking parameter) block until
             * they succeed or there is an error. In
             * non-blocking mode all functions return results immediately or
             * with a %G_IO_ERROR_WOULD_BLOCK error.
             *
             * All sockets are created in blocking mode. However, note that the
             * platform level socket is always non-blocking, and blocking mode
             * is a GSocket level feature.
             */
            set_blocking(blocking: boolean): void;
            /**
             * Sets whether `socket `should allow sending to broadcast addresses.
             * This is %FALSE by default.
             */
            set_broadcast(broadcast: boolean): void;
            /**
             * Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
             * this flag is set on a socket, the system will attempt to verify that the
             * remote socket endpoint is still present if a sufficiently long period of
             * time passes with no data being exchanged. If the system is unable to
             * verify the presence of the remote endpoint, it will automatically close
             * the connection.
             *
             * This option is only functional on certain kinds of sockets. (Notably,
             * %G_SOCKET_PROTOCOL_TCP sockets.)
             *
             * The exact time between pings is system- and protocol-dependent, but will
             * normally be at least two hours. Most commonly, you would set this flag
             * on a server socket if you want to allow clients to remain idle for long
             * periods of time, but also want to ensure that connections are eventually
             * garbage-collected if clients crash or become unreachable.
             */
            set_keepalive(keepalive: boolean): void;
            /**
             * Sets the maximum number of outstanding connections allowed
             * when listening on this socket. If more clients than this are
             * connecting to the socket and the application is not handling them
             * on time then the new connections will be refused.
             *
             * Note that this must be called before g_socket_listen() and has no
             * effect if called after that.
             */
            set_listen_backlog(backlog: number): void;
            /**
             * Sets whether outgoing multicast packets will be received by sockets
             * listening on that multicast address on the same host. This is %TRUE
             * by default.
             */
            set_multicast_loopback(loopback: boolean): void;
            /**
             * Sets the time-to-live for outgoing multicast datagrams on `socket.`
             * By default, this is 1, meaning that multicast packets will not leave
             * the local network.
             */
            set_multicast_ttl(ttl: number): void;
            /**
             * Sets the value of an integer-valued option on socket, as with
             * setsockopt(). (If you need to set a non-integer-valued option,
             * you will need to call setsockopt() directly.)
             *
             * The [&lt;gio/gnetworking.h&gt;][gio-gnetworking.h]
             * header pulls in system headers that will define most of the
             * standard/portable socket options. For unusual socket protocols or
             * platform-dependent options, you may need to include additional
             * headers.
             */
            set_option(level: number, optname: number, value: number): boolean;
            /**
             * Sets the time in seconds after which I/O operations on `socket `will
             * time out if they have not yet completed.
             *
             * On a blocking socket, this means that any blocking #GSocket
             * operation will time out after `timeout `seconds of inactivity,
             * returning %G_IO_ERROR_TIMED_OUT.
             *
             * On a non-blocking socket, calls to g_socket_condition_wait() will
             * also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
             * created with g_socket_create_source() will trigger after
             * `timeout `seconds of inactivity, with the requested condition
             * set, at which point calling g_socket_receive(), g_socket_send(),
             * g_socket_check_connect_result(), etc, will fail with
             * %G_IO_ERROR_TIMED_OUT.
             *
             * If `timeout `is 0 (the default), operations will never time out
             * on their own.
             *
             * Note that if an I/O operation is interrupted by a signal, this may
             * cause the timeout to be reset.
             */
            set_timeout(timeout: number): void;
            /**
             * Sets the time-to-live for outgoing unicast packets on `socket.`
             * By default the platform-specific default value is used.
             */
            set_ttl(ttl: number): void;
            /**
             * Shut down part or all of a full-duplex connection.
             *
             * If `shutdown_read `is %TRUE then the receiving side of the connection
             * is shut down, and further reading is disallowed.
             *
             * If `shutdown_write `is %TRUE then the sending side of the connection
             * is shut down, and further writing is disallowed.
             *
             * It is allowed for both `shutdown_read `and `shutdown_write `to be %TRUE.
             *
             * One example where it is useful to shut down only one side of a connection is
             * graceful disconnect for TCP connections where you close the sending side,
             * then wait for the other side to close the connection, thus ensuring that the
             * other side saw all sent data.
             */
            shutdown(shutdown_read: boolean, shutdown_write: boolean): boolean;
            /**
             * Checks if a socket is capable of speaking IPv4.
             *
             * IPv4 sockets are capable of speaking IPv4.  On some operating systems
             * and under some combinations of circumstances IPv6 sockets are also
             * capable of speaking IPv4.  See RFC 3493 section 3.7 for more
             * information.
             *
             * No other types of sockets are currently considered as being capable
             * of speaking IPv4.
             */
            speaks_ipv4(): boolean;

            // Implemented Members

            /**
             * Creates a #GSource that can be attached to a #GMainContext to monitor for
             * the availability of the specified `condition `on the #GDatagramBased. The
             * #GSource keeps a reference to the `datagram_based.`
             *
             * The callback on the source is of the #GDatagramBasedSourceFunc type.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be reported in the callback if they are true.
             *
             * If non-%NULL, `cancellable `can be used to cancel the source, which will
             * cause the source to trigger, reporting the current condition (which is
             * likely 0 unless cancellation happened at the same time as a condition
             * change). You can check for this in the callback using
             * g_cancellable_is_cancelled().
             */
            create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks on the readiness of `datagram_based `to perform operations. The
             * operations specified in `condition `are checked for and masked against the
             * currently-satisfied conditions on `datagram_based.` The result is returned.
             *
             * %G_IO_IN will be set in the return value if data is available to read with
             * g_datagram_based_receive_messages(), or if the connection is closed remotely
             * (EOS); and if the datagram_based has not been closed locally using some
             * implementation-specific method (such as g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket).
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * %G_IO_OUT will be set if it is expected that at least one byte can be sent
             * using g_datagram_based_send_messages() without blocking. It will not be set
             * if the datagram_based has been closed locally.
             *
             * %G_IO_HUP will be set if the connection has been closed locally.
             *
             * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
             * previously enqueued using g_datagram_based_send_messages().
             *
             * Note that on Windows, it is possible for an operation to return
             * %G_IO_ERROR_WOULD_BLOCK even immediately after
             * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
             * ready for writing. Rather than calling g_datagram_based_condition_check() and
             * then writing to the #GDatagramBased if it succeeds, it is generally better to
             * simply try writing right away, and try again later if the initial attempt
             * returns %G_IO_ERROR_WOULD_BLOCK.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be set in the output if they are true. Apart from
             * these flags, the output is guaranteed to be masked by `condition.`
             *
             * This call never blocks.
             */
            vfunc_condition_check(condition: GLib.IOCondition): GLib.IOCondition;
            /**
             * Waits for up to `timeout `microseconds for condition to become true on
             * `datagram_based.` If the condition is met, %TRUE is returned.
             *
             * If `cancellable `is cancelled before the condition is met, or if `timeout `is
             * reached before the condition is met, then %FALSE is returned and `error `is
             * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
             */
            vfunc_condition_wait(
                condition: GLib.IOCondition,
                timeout: number,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Creates a #GSource that can be attached to a #GMainContext to monitor for
             * the availability of the specified `condition `on the #GDatagramBased. The
             * #GSource keeps a reference to the `datagram_based.`
             *
             * The callback on the source is of the #GDatagramBasedSourceFunc type.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be reported in the callback if they are true.
             *
             * If non-%NULL, `cancellable `can be used to cancel the source, which will
             * cause the source to trigger, reporting the current condition (which is
             * likely 0 unless cancellation happened at the same time as a condition
             * change). You can check for this in the callback using
             * g_cancellable_is_cancelled().
             */
            vfunc_create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
            /**
             * Receive one or more data messages from `datagram_based `in one go.
             *
             * `messages `must point to an array of #GInputMessage structs and
             * `num_messages `must be the length of this array. Each #GInputMessage
             * contains a pointer to an array of #GInputVector structs describing the
             * buffers that the data received in each message will be written to.
             *
             * `flags `modify how all messages are received. The commonly available
             * arguments for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too. These
             * flags affect the overall receive operation. Flags affecting individual
             * messages are returned in #GInputMessage.flags.
             *
             * The other members of #GInputMessage are treated as described in its
             * documentation.
             *
             * If `timeout `is negative the call will block until `num_messages `have been
             * received, the connection is closed remotely (EOS), `cancellable `is cancelled,
             * or an error occurs.
             *
             * If `timeout `is 0 the call will return up to `num_messages `without blocking,
             * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
             * to be received.
             *
             * If `timeout `is positive the call will block on the same conditions as if
             * `timeout `were negative. If the timeout is reached
             * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
             * otherwise it will return the number of messages received before timing out.
             * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
             * recvmmsg().)
             *
             * To be notified when messages are available, wait for the %G_IO_IN condition.
             * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
             * g_datagram_based_receive_messages() even if you were previously notified of a
             * %G_IO_IN condition.
             *
             * If the remote peer closes the connection, any messages queued in the
             * underlying receive buffer will be returned, and subsequent calls to
             * g_datagram_based_receive_messages() will return 0 (with no error set).
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be received; otherwise the number of
             * messages successfully received before the error will be returned. If
             * `cancellable `is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
             * other error.
             */
            vfunc_receive_messages(
                messages: InputMessage[],
                flags: number,
                timeout: number,
                cancellable?: Cancellable | null
            ): number;
            /**
             * Send one or more data messages from `datagram_based `in one go.
             *
             * `messages `must point to an array of #GOutputMessage structs and
             * `num_messages `must be the length of this array. Each #GOutputMessage
             * contains an address to send the data to, and a pointer to an array of
             * #GOutputVector structs to describe the buffers that the data to be sent
             * for each message will be gathered from.
             *
             * `flags `modify how the message is sent. The commonly available arguments
             * for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too.
             *
             * The other members of #GOutputMessage are treated as described in its
             * documentation.
             *
             * If `timeout `is negative the call will block until `num_messages `have been
             * sent, `cancellable `is cancelled, or an error occurs.
             *
             * If `timeout `is 0 the call will send up to `num_messages `without blocking,
             * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
             *
             * If `timeout `is positive the call will block on the same conditions as if
             * `timeout `were negative. If the timeout is reached before any messages are
             * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
             * of messages sent before timing out.
             *
             * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
             * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
             * g_datagram_based_send_messages() even if you were previously notified of a
             * %G_IO_OUT condition. (On Windows in particular, this is very common due to
             * the way the underlying APIs work.)
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_write `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be sent; otherwise the number of messages
             * successfully sent before the error will be returned. If `cancellable `is
             * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
             */
            vfunc_send_messages(
                messages: OutputMessage[],
                flags: number,
                timeout: number,
                cancellable?: Cancellable | null
            ): number;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module SocketAddress {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                family: SocketFamily;
            }
        }
        export abstract class SocketAddress extends GObject.Object implements SocketConnectable {
            static $gtype: GObject.GType<SocketAddress>;

            constructor(properties?: Partial<SocketAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketAddress.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get family(): SocketFamily;

            // Constructors

            static new_from_native(_native: any, len: number): SocketAddress;

            // Members

            /**
             * Gets the socket family type of `address.`
             */
            get_family(): SocketFamily;
            /**
             * Gets the size of address's native struct sockaddr.
             * You can use this to allocate memory to pass to
             * g_socket_address_to_native().
             */
            get_native_size(): number;
            /**
             * Converts a #GSocketAddress to a native struct sockaddr, which can
             * be passed to low-level functions like connect() or bind().
             *
             * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
             * is returned. If the address type is not known on the system
             * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
             */
            to_native(dest: any | null, destlen: number): boolean;
            /**
             * Gets the socket family type of `address.`
             */
            vfunc_get_family(): SocketFamily;
            /**
             * Gets the size of address's native struct sockaddr.
             * You can use this to allocate memory to pass to
             * g_socket_address_to_native().
             */
            vfunc_get_native_size(): number;
            /**
             * Converts a #GSocketAddress to a native struct sockaddr, which can
             * be passed to low-level functions like connect() or bind().
             *
             * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
             * is returned. If the address type is not known on the system
             * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
             */
            vfunc_to_native(dest: any | null, destlen: number): boolean;

            // Implemented Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }
        export module SocketAddressEnumerator {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class SocketAddressEnumerator extends GObject.Object {
            static $gtype: GObject.GType<SocketAddressEnumerator>;

            constructor(properties?: Partial<SocketAddressEnumerator.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketAddressEnumerator.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Retrieves the next #GSocketAddress from `enumerator.` Note that this
             * may block for some amount of time. (Eg, a #GNetworkAddress may need
             * to do a DNS lookup before it can return an address.) Use
             * g_socket_address_enumerator_next_async() if you need to avoid
             * blocking.
             *
             * If `enumerator `is expected to yield addresses, but for some reason
             * is unable to (eg, because of a DNS error), then the first call to
             * g_socket_address_enumerator_next() will return an appropriate error
             * in *`error.` However, if the first call to
             * g_socket_address_enumerator_next() succeeds, then any further
             * internal errors (other than `cancellable `being triggered) will be
             * ignored.
             */
            next(cancellable?: Cancellable | null): SocketAddress | null;
            /**
             * Asynchronously retrieves the next #GSocketAddress from enumerator
             * and then calls callback, which must call
             * g_socket_address_enumerator_next_finish() to get the result.
             *
             * It is an error to call this multiple times before the previous callback has finished.
             */
            next_async(cancellable?: Cancellable | null): Promise<SocketAddress | null>;
            /**
             * Asynchronously retrieves the next #GSocketAddress from enumerator
             * and then calls callback, which must call
             * g_socket_address_enumerator_next_finish() to get the result.
             *
             * It is an error to call this multiple times before the previous callback has finished.
             */
            next_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously retrieves the next #GSocketAddress from enumerator
             * and then calls callback, which must call
             * g_socket_address_enumerator_next_finish() to get the result.
             *
             * It is an error to call this multiple times before the previous callback has finished.
             */
            next_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SocketAddress | null> | void;
            /**
             * Retrieves the result of a completed call to
             * g_socket_address_enumerator_next_async(). See
             * g_socket_address_enumerator_next() for more information about
             * error handling.
             */
            next_finish(result: AsyncResult): SocketAddress | null;
            /**
             * Retrieves the next #GSocketAddress from `enumerator.` Note that this
             * may block for some amount of time. (Eg, a #GNetworkAddress may need
             * to do a DNS lookup before it can return an address.) Use
             * g_socket_address_enumerator_next_async() if you need to avoid
             * blocking.
             *
             * If `enumerator `is expected to yield addresses, but for some reason
             * is unable to (eg, because of a DNS error), then the first call to
             * g_socket_address_enumerator_next() will return an appropriate error
             * in *`error.` However, if the first call to
             * g_socket_address_enumerator_next() succeeds, then any further
             * internal errors (other than `cancellable `being triggered) will be
             * ignored.
             */
            vfunc_next(cancellable?: Cancellable | null): SocketAddress | null;
            /**
             * Asynchronously retrieves the next #GSocketAddress from enumerator
             * and then calls callback, which must call
             * g_socket_address_enumerator_next_finish() to get the result.
             *
             * It is an error to call this multiple times before the previous callback has finished.
             */
            vfunc_next_async(cancellable?: Cancellable | null): Promise<SocketAddress | null>;
            /**
             * Asynchronously retrieves the next #GSocketAddress from enumerator
             * and then calls callback, which must call
             * g_socket_address_enumerator_next_finish() to get the result.
             *
             * It is an error to call this multiple times before the previous callback has finished.
             */
            vfunc_next_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously retrieves the next #GSocketAddress from enumerator
             * and then calls callback, which must call
             * g_socket_address_enumerator_next_finish() to get the result.
             *
             * It is an error to call this multiple times before the previous callback has finished.
             */
            vfunc_next_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SocketAddress | null> | void;
            /**
             * Retrieves the result of a completed call to
             * g_socket_address_enumerator_next_async(). See
             * g_socket_address_enumerator_next() for more information about
             * error handling.
             */
            vfunc_next_finish(result: AsyncResult): SocketAddress | null;
        }
        export module SocketClient {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                enable_proxy: boolean;
                enableProxy: boolean;
                family: SocketFamily;
                local_address: SocketAddress;
                localAddress: SocketAddress;
                protocol: SocketProtocol;
                proxy_resolver: ProxyResolver;
                proxyResolver: ProxyResolver;
                timeout: number;
                tls: boolean;
                tls_validation_flags: TlsCertificateFlags;
                tlsValidationFlags: TlsCertificateFlags;
                type: SocketType;
            }
        }
        export class SocketClient extends GObject.Object {
            static $gtype: GObject.GType<SocketClient>;

            constructor(properties?: Partial<SocketClient.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketClient.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get enable_proxy(): boolean;
            set enable_proxy(val: boolean);
            get enableProxy(): boolean;
            set enableProxy(val: boolean);
            get family(): SocketFamily;
            set family(val: SocketFamily);
            get local_address(): SocketAddress;
            set local_address(val: SocketAddress);
            get localAddress(): SocketAddress;
            set localAddress(val: SocketAddress);
            get protocol(): SocketProtocol;
            set protocol(val: SocketProtocol);
            get proxy_resolver(): ProxyResolver;
            set proxy_resolver(val: ProxyResolver);
            get proxyResolver(): ProxyResolver;
            set proxyResolver(val: ProxyResolver);
            get timeout(): number;
            set timeout(val: number);
            get tls(): boolean;
            set tls(val: boolean);
            get tls_validation_flags(): TlsCertificateFlags;
            set tls_validation_flags(val: TlsCertificateFlags);
            get tlsValidationFlags(): TlsCertificateFlags;
            set tlsValidationFlags(val: TlsCertificateFlags);
            get type(): SocketType;
            set type(val: SocketType);

            // Signals

            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect_after(
                signal: "event",
                callback: (
                    _source: this,
                    event: SocketClientEvent,
                    connectable: SocketConnectable,
                    connection: IOStream | null
                ) => void
            ): number;
            emit(
                signal: "event",
                event: SocketClientEvent,
                connectable: SocketConnectable,
                connection?: IOStream | null
            ): void;

            // Constructors

            static ["new"](): SocketClient;

            // Members

            /**
             * Enable proxy protocols to be handled by the application. When the
             * indicated proxy protocol is returned by the #GProxyResolver,
             * #GSocketClient will consider this protocol as supported but will
             * not try to find a #GProxy instance to handle handshaking. The
             * application must check for this case by calling
             * g_socket_connection_get_remote_address() on the returned
             * #GSocketConnection, and seeing if it's a #GProxyAddress of the
             * appropriate type, to determine whether or not it needs to handle
             * the proxy handshaking itself.
             *
             * This should be used for proxy protocols that are dialects of
             * another protocol such as HTTP proxy. It also allows cohabitation of
             * proxy protocols that are reused between protocols. A good example
             * is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
             * be use as generic socket proxy through the HTTP CONNECT method.
             *
             * When the proxy is detected as being an application proxy, TLS handshake
             * will be skipped. This is required to let the application do the proxy
             * specific handshake.
             */
            add_application_proxy(protocol: string): void;
            /**
             * Tries to resolve the `connectable `and make a network connection to it.
             *
             * Upon a successful connection, a new #GSocketConnection is constructed
             * and returned.  The caller owns this new object and must drop their
             * reference to it when finished with it.
             *
             * The type of the #GSocketConnection object returned depends on the type of
             * the underlying socket that is used. For instance, for a TCP/IP connection
             * it will be a #GTcpConnection.
             *
             * The socket created will be the same family as the address that the
             * `connectable `resolves to, unless family is set with g_socket_client_set_family()
             * or indirectly via g_socket_client_set_local_address(). The socket type
             * defaults to %G_SOCKET_TYPE_STREAM but can be set with
             * g_socket_client_set_socket_type().
             *
             * If a local address is specified with g_socket_client_set_local_address() the
             * socket will be bound to this address before connecting.
             */
            connect(connectable: SocketConnectable, cancellable?: Cancellable | null): SocketConnection;
            connect(...args: never[]): any;
            /**
             * This is the asynchronous version of g_socket_client_connect().
             *
             * You may wish to prefer the asynchronous version even in synchronous
             * command line programs because, since 2.60, it implements
             * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
             * recommendations to work around long connection timeouts in networks
             * where IPv6 is broken by performing an IPv4 connection simultaneously
             * without waiting for IPv6 to time out, which is not supported by the
             * synchronous call. (This is not an API guarantee, and may change in
             * the future.)
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_finish() to get
             * the result of the operation.
             */
            connect_async(connectable: SocketConnectable, cancellable?: Cancellable | null): Promise<SocketConnection>;
            /**
             * This is the asynchronous version of g_socket_client_connect().
             *
             * You may wish to prefer the asynchronous version even in synchronous
             * command line programs because, since 2.60, it implements
             * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
             * recommendations to work around long connection timeouts in networks
             * where IPv6 is broken by performing an IPv4 connection simultaneously
             * without waiting for IPv6 to time out, which is not supported by the
             * synchronous call. (This is not an API guarantee, and may change in
             * the future.)
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_finish() to get
             * the result of the operation.
             */
            connect_async(
                connectable: SocketConnectable,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * This is the asynchronous version of g_socket_client_connect().
             *
             * You may wish to prefer the asynchronous version even in synchronous
             * command line programs because, since 2.60, it implements
             * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
             * recommendations to work around long connection timeouts in networks
             * where IPv6 is broken by performing an IPv4 connection simultaneously
             * without waiting for IPv6 to time out, which is not supported by the
             * synchronous call. (This is not an API guarantee, and may change in
             * the future.)
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_finish() to get
             * the result of the operation.
             */
            connect_async(
                connectable: SocketConnectable,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SocketConnection> | void;
            /**
             * Finishes an async connect operation. See g_socket_client_connect_async()
             */
            connect_finish(result: AsyncResult): SocketConnection;
            /**
             * This is a helper function for g_socket_client_connect().
             *
             * Attempts to create a TCP connection to the named host.
             *
             * `host_and_port `may be in any of a number of recognized formats; an IPv6
             * address, an IPv4 address, or a domain name (in which case a DNS
             * lookup is performed).  Quoting with [] is supported for all address
             * types.  A port override may be specified in the usual way with a
             * colon.  Ports may be given as decimal numbers or symbolic names (in
             * which case an /etc/services lookup is performed).
             *
             * If no port override is given in `host_and_port `then `default_port `will be
             * used as the port number to connect to.
             *
             * In general, `host_and_port `is expected to be provided by the user (allowing
             * them to give the hostname, and a port override if necessary) and
             * `default_port `is expected to be provided by the application.
             *
             * In the case that an IP address is given, a single connection
             * attempt is made.  In the case that a name is given, multiple
             * connection attempts may be made, in turn and according to the
             * number of address records in DNS, until a connection succeeds.
             *
             * Upon a successful connection, a new #GSocketConnection is constructed
             * and returned.  The caller owns this new object and must drop their
             * reference to it when finished with it.
             *
             * In the event of any failure (DNS error, service not found, no hosts
             * connectable) %NULL is returned and `error `(if non-%NULL) is set
             * accordingly.
             */
            connect_to_host(
                host_and_port: string,
                default_port: number,
                cancellable?: Cancellable | null
            ): SocketConnection;
            /**
             * This is the asynchronous version of g_socket_client_connect_to_host().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_to_host_finish() to get
             * the result of the operation.
             */
            connect_to_host_async(
                host_and_port: string,
                default_port: number,
                cancellable?: Cancellable | null
            ): Promise<SocketConnection>;
            /**
             * This is the asynchronous version of g_socket_client_connect_to_host().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_to_host_finish() to get
             * the result of the operation.
             */
            connect_to_host_async(
                host_and_port: string,
                default_port: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * This is the asynchronous version of g_socket_client_connect_to_host().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_to_host_finish() to get
             * the result of the operation.
             */
            connect_to_host_async(
                host_and_port: string,
                default_port: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SocketConnection> | void;
            /**
             * Finishes an async connect operation. See g_socket_client_connect_to_host_async()
             */
            connect_to_host_finish(result: AsyncResult): SocketConnection;
            /**
             * Attempts to create a TCP connection to a service.
             *
             * This call looks up the SRV record for `service `at `domain `for the
             * "tcp" protocol.  It then attempts to connect, in turn, to each of
             * the hosts providing the service until either a connection succeeds
             * or there are no hosts remaining.
             *
             * Upon a successful connection, a new #GSocketConnection is constructed
             * and returned.  The caller owns this new object and must drop their
             * reference to it when finished with it.
             *
             * In the event of any failure (DNS error, service not found, no hosts
             * connectable) %NULL is returned and `error `(if non-%NULL) is set
             * accordingly.
             */
            connect_to_service(domain: string, service: string, cancellable?: Cancellable | null): SocketConnection;
            /**
             * This is the asynchronous version of
             * g_socket_client_connect_to_service().
             */
            connect_to_service_async(
                domain: string,
                service: string,
                cancellable?: Cancellable | null
            ): Promise<SocketConnection>;
            /**
             * This is the asynchronous version of
             * g_socket_client_connect_to_service().
             */
            connect_to_service_async(
                domain: string,
                service: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * This is the asynchronous version of
             * g_socket_client_connect_to_service().
             */
            connect_to_service_async(
                domain: string,
                service: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SocketConnection> | void;
            /**
             * Finishes an async connect operation. See g_socket_client_connect_to_service_async()
             */
            connect_to_service_finish(result: AsyncResult): SocketConnection;
            /**
             * This is a helper function for g_socket_client_connect().
             *
             * Attempts to create a TCP connection with a network URI.
             *
             * `uri `may be any valid URI containing an "authority" (hostname/port)
             * component. If a port is not specified in the URI, default_port
             * will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
             * (#GSocketClient does not know to automatically assume TLS for
             * certain URI schemes.)
             *
             * Using this rather than g_socket_client_connect() or
             * g_socket_client_connect_to_host() allows #GSocketClient to
             * determine when to use application-specific proxy protocols.
             *
             * Upon a successful connection, a new #GSocketConnection is constructed
             * and returned.  The caller owns this new object and must drop their
             * reference to it when finished with it.
             *
             * In the event of any failure (DNS error, service not found, no hosts
             * connectable) %NULL is returned and `error `(if non-%NULL) is set
             * accordingly.
             */
            connect_to_uri(uri: string, default_port: number, cancellable?: Cancellable | null): SocketConnection;
            /**
             * This is the asynchronous version of g_socket_client_connect_to_uri().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_to_uri_finish() to get
             * the result of the operation.
             */
            connect_to_uri_async(
                uri: string,
                default_port: number,
                cancellable?: Cancellable | null
            ): Promise<SocketConnection>;
            /**
             * This is the asynchronous version of g_socket_client_connect_to_uri().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_to_uri_finish() to get
             * the result of the operation.
             */
            connect_to_uri_async(
                uri: string,
                default_port: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * This is the asynchronous version of g_socket_client_connect_to_uri().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_client_connect_to_uri_finish() to get
             * the result of the operation.
             */
            connect_to_uri_async(
                uri: string,
                default_port: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<SocketConnection> | void;
            /**
             * Finishes an async connect operation. See g_socket_client_connect_to_uri_async()
             */
            connect_to_uri_finish(result: AsyncResult): SocketConnection;
            /**
             * Gets the proxy enable state; see g_socket_client_set_enable_proxy()
             */
            get_enable_proxy(): boolean;
            /**
             * Gets the socket family of the socket client.
             *
             * See g_socket_client_set_family() for details.
             */
            get_family(): SocketFamily;
            /**
             * Gets the local address of the socket client.
             *
             * See g_socket_client_set_local_address() for details.
             */
            get_local_address(): SocketAddress | null;
            /**
             * Gets the protocol name type of the socket client.
             *
             * See g_socket_client_set_protocol() for details.
             */
            get_protocol(): SocketProtocol;
            /**
             * Gets the #GProxyResolver being used by `client.` Normally, this will
             * be the resolver returned by g_proxy_resolver_get_default(), but you
             * can override it with g_socket_client_set_proxy_resolver().
             */
            get_proxy_resolver(): ProxyResolver;
            /**
             * Gets the socket type of the socket client.
             *
             * See g_socket_client_set_socket_type() for details.
             */
            get_socket_type(): SocketType;
            /**
             * Gets the I/O timeout time for sockets created by `client.`
             *
             * See g_socket_client_set_timeout() for details.
             */
            get_timeout(): number;
            /**
             * Gets whether `client `creates TLS connections. See
             * g_socket_client_set_tls() for details.
             */
            get_tls(): boolean;
            /**
             * Gets the TLS validation flags used creating TLS connections via
             * `client.`
             *
             * This function does not work as originally designed and is impossible
             * to use correctly. See #GSocketClient:tls-validation-flags for more
             * information.
             */
            get_tls_validation_flags(): TlsCertificateFlags;
            /**
             * Sets whether or not `client `attempts to make connections via a
             * proxy server. When enabled (the default), #GSocketClient will use a
             * #GProxyResolver to determine if a proxy protocol such as SOCKS is
             * needed, and automatically do the necessary proxy negotiation.
             *
             * See also g_socket_client_set_proxy_resolver().
             */
            set_enable_proxy(enable: boolean): void;
            /**
             * Sets the socket family of the socket client.
             * If this is set to something other than %G_SOCKET_FAMILY_INVALID
             * then the sockets created by this object will be of the specified
             * family.
             *
             * This might be useful for instance if you want to force the local
             * connection to be an ipv4 socket, even though the address might
             * be an ipv6 mapped to ipv4 address.
             */
            set_family(family: SocketFamily): void;
            /**
             * Sets the local address of the socket client.
             * The sockets created by this object will bound to the
             * specified address (if not %NULL) before connecting.
             *
             * This is useful if you want to ensure that the local
             * side of the connection is on a specific port, or on
             * a specific interface.
             */
            set_local_address(address?: SocketAddress | null): void;
            /**
             * Sets the protocol of the socket client.
             * The sockets created by this object will use of the specified
             * protocol.
             *
             * If `protocol `is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
             * protocol for the socket family and type.
             */
            set_protocol(protocol: SocketProtocol): void;
            /**
             * Overrides the #GProxyResolver used by `client.` You can call this if
             * you want to use specific proxies, rather than using the system
             * default proxy settings.
             *
             * Note that whether or not the proxy resolver is actually used
             * depends on the setting of #GSocketClient:enable-proxy, which is not
             * changed by this function (but which is %TRUE by default)
             */
            set_proxy_resolver(proxy_resolver?: ProxyResolver | null): void;
            /**
             * Sets the socket type of the socket client.
             * The sockets created by this object will be of the specified
             * type.
             *
             * It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
             * as GSocketClient is used for connection oriented services.
             */
            set_socket_type(type: SocketType): void;
            /**
             * Sets the I/O timeout for sockets created by `client.` `timeout `is a
             * time in seconds, or 0 for no timeout (the default).
             *
             * The timeout value affects the initial connection attempt as well,
             * so setting this may cause calls to g_socket_client_connect(), etc,
             * to fail with %G_IO_ERROR_TIMED_OUT.
             */
            set_timeout(timeout: number): void;
            /**
             * Sets whether `client `creates TLS (aka SSL) connections. If `tls `is
             * %TRUE, `client `will wrap its connections in a #GTlsClientConnection
             * and perform a TLS handshake when connecting.
             *
             * Note that since #GSocketClient must return a #GSocketConnection,
             * but #GTlsClientConnection is not a #GSocketConnection, this
             * actually wraps the resulting #GTlsClientConnection in a
             * #GTcpWrapperConnection when returning it. You can use
             * g_tcp_wrapper_connection_get_base_io_stream() on the return value
             * to extract the #GTlsClientConnection.
             *
             * If you need to modify the behavior of the TLS handshake (eg, by
             * setting a client-side certificate to use, or connecting to the
             * #GTlsConnection::accept-certificate signal), you can connect to
             * client's #GSocketClient::event signal and wait for it to be
             * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
             * a chance to see the #GTlsClientConnection before the handshake
             * starts.
             */
            set_tls(tls: boolean): void;
            /**
             * Sets the TLS validation flags used when creating TLS connections
             * via `client.` The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
             *
             * This function does not work as originally designed and is impossible
             * to use correctly. See #GSocketClient:tls-validation-flags for more
             * information.
             */
            set_tls_validation_flags(flags: TlsCertificateFlags): void;
            vfunc_event(event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream): void;
        }
        export module SocketConnection {
            export interface ConstructorProperties extends IOStream.ConstructorProperties {
                [key: string]: any;
                socket: Socket;
            }
        }
        export class SocketConnection extends IOStream {
            static $gtype: GObject.GType<SocketConnection>;

            constructor(properties?: Partial<SocketConnection.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketConnection.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get socket(): Socket;

            // Members

            /**
             * Connect `connection `to the specified remote address.
             */
            connect(address: SocketAddress, cancellable?: Cancellable | null): boolean;
            connect(...args: never[]): any;
            /**
             * Asynchronously connect `connection `to the specified remote address.
             *
             * This clears the #GSocket:blocking flag on connection's underlying
             * socket if it is currently set.
             *
             * Use g_socket_connection_connect_finish() to retrieve the result.
             */
            connect_async(address: SocketAddress, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously connect `connection `to the specified remote address.
             *
             * This clears the #GSocket:blocking flag on connection's underlying
             * socket if it is currently set.
             *
             * Use g_socket_connection_connect_finish() to retrieve the result.
             */
            connect_async(
                address: SocketAddress,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously connect `connection `to the specified remote address.
             *
             * This clears the #GSocket:blocking flag on connection's underlying
             * socket if it is currently set.
             *
             * Use g_socket_connection_connect_finish() to retrieve the result.
             */
            connect_async(
                address: SocketAddress,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Gets the result of a g_socket_connection_connect_async() call.
             */
            connect_finish(result: AsyncResult): boolean;
            /**
             * Try to get the local address of a socket connection.
             */
            get_local_address(): SocketAddress;
            /**
             * Try to get the remote address of a socket connection.
             *
             * Since GLib 2.40, when used with g_socket_client_connect() or
             * g_socket_client_connect_async(), during emission of
             * %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
             * address that will be used for the connection.  This allows
             * applications to print e.g. "Connecting to example.com
             * (10.42.77.3)...".
             */
            get_remote_address(): SocketAddress;
            /**
             * Gets the underlying #GSocket object of the connection.
             * This can be useful if you want to do something unusual on it
             * not supported by the #GSocketConnection APIs.
             */
            get_socket(): Socket;
            /**
             * Checks if `connection `is connected. This is equivalent to calling
             * g_socket_is_connected() on connection's underlying #GSocket.
             */
            is_connected(): boolean;
            /**
             * Looks up the #GType to be used when creating socket connections on
             * sockets with the specified family, `type `and `protocol_id.`
             *
             * If no type is registered, the #GSocketConnection base type is returned.
             */
            static factory_lookup_type(family: SocketFamily, type: SocketType, protocol_id: number): GObject.GType;
            /**
             * Looks up the #GType to be used when creating socket connections on
             * sockets with the specified family, `type `and `protocol.`
             *
             * If no type is registered, the #GSocketConnection base type is returned.
             */
            static factory_register_type(
                g_type: GObject.GType,
                family: SocketFamily,
                type: SocketType,
                protocol: number
            ): void;
        }
        export module SocketControlMessage {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class SocketControlMessage extends GObject.Object {
            static $gtype: GObject.GType<SocketControlMessage>;

            constructor(properties?: Partial<SocketControlMessage.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketControlMessage.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Returns the "level" (i.e. the originating protocol) of the control message.
             * This is often SOL_SOCKET.
             */
            get_level(): number;
            /**
             * Returns the protocol specific type of the control message.
             * For instance, for UNIX fd passing this would be SCM_RIGHTS.
             */
            get_msg_type(): number;
            /**
             * Returns the space required for the control message, not including
             * headers or alignment.
             */
            get_size(): number;
            /**
             * Converts the data in the message to bytes placed in the
             * message.
             *
             * `data `is guaranteed to have enough space to fit the size
             * returned by g_socket_control_message_get_size() on this
             * object.
             */
            serialize(data: any): void;
            /**
             * Returns the "level" (i.e. the originating protocol) of the control message.
             * This is often SOL_SOCKET.
             */
            vfunc_get_level(): number;
            /**
             * Returns the space required for the control message, not including
             * headers or alignment.
             */
            vfunc_get_size(): number;
            vfunc_get_type(): number;
            /**
             * Converts the data in the message to bytes placed in the
             * message.
             *
             * `data `is guaranteed to have enough space to fit the size
             * returned by g_socket_control_message_get_size() on this
             * object.
             */
            vfunc_serialize(data: any): void;
            /**
             * Tries to deserialize a socket control message of a given
             * `level `and `type.` This will ask all known (to GType) subclasses
             * of #GSocketControlMessage if they can understand this kind
             * of message and if so deserialize it into a #GSocketControlMessage.
             *
             * If there is no implementation for this kind of control message, %NULL
             * will be returned.
             */
            static deserialize(level: number, type: number, data: Uint8Array | string): SocketControlMessage | null;
        }
        export module SocketListener {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                listen_backlog: number;
                listenBacklog: number;
            }
        }
        export class SocketListener extends GObject.Object {
            static $gtype: GObject.GType<SocketListener>;

            constructor(properties?: Partial<SocketListener.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketListener.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get listen_backlog(): number;
            set listen_backlog(val: number);
            get listenBacklog(): number;
            set listenBacklog(val: number);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "event",
                callback: (_source: this, event: SocketListenerEvent, socket: Socket) => void
            ): number;
            connect_after(
                signal: "event",
                callback: (_source: this, event: SocketListenerEvent, socket: Socket) => void
            ): number;
            emit(signal: "event", event: SocketListenerEvent, socket: Socket): void;

            // Constructors

            static ["new"](): SocketListener;

            // Members

            /**
             * Blocks waiting for a client to connect to any of the sockets added
             * to the listener. Returns a #GSocketConnection for the socket that was
             * accepted.
             *
             * If `source_object `is not %NULL it will be filled out with the source
             * object specified when the corresponding socket or address was added
             * to the listener.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            accept(cancellable?: Cancellable | null): [SocketConnection, GObject.Object | null];
            /**
             * This is the asynchronous version of g_socket_listener_accept().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_listener_accept_finish()
             * to get the result of the operation.
             */
            accept_async(cancellable?: Cancellable | null): Promise<[SocketConnection, GObject.Object | null]>;
            /**
             * This is the asynchronous version of g_socket_listener_accept().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_listener_accept_finish()
             * to get the result of the operation.
             */
            accept_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * This is the asynchronous version of g_socket_listener_accept().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_listener_accept_finish()
             * to get the result of the operation.
             */
            accept_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[SocketConnection, GObject.Object | null]> | void;
            /**
             * Finishes an async accept operation. See g_socket_listener_accept_async()
             */
            accept_finish(result: AsyncResult): [SocketConnection, GObject.Object | null];
            /**
             * Blocks waiting for a client to connect to any of the sockets added
             * to the listener. Returns the #GSocket that was accepted.
             *
             * If you want to accept the high-level #GSocketConnection, not a #GSocket,
             * which is often the case, then you should use g_socket_listener_accept()
             * instead.
             *
             * If `source_object `is not %NULL it will be filled out with the source
             * object specified when the corresponding socket or address was added
             * to the listener.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            accept_socket(cancellable?: Cancellable | null): [Socket, GObject.Object | null];
            /**
             * This is the asynchronous version of g_socket_listener_accept_socket().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_listener_accept_socket_finish()
             * to get the result of the operation.
             */
            accept_socket_async(cancellable?: Cancellable | null): Promise<[Socket, GObject.Object | null]>;
            /**
             * This is the asynchronous version of g_socket_listener_accept_socket().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_listener_accept_socket_finish()
             * to get the result of the operation.
             */
            accept_socket_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * This is the asynchronous version of g_socket_listener_accept_socket().
             *
             * When the operation is finished `callback `will be
             * called. You can then call g_socket_listener_accept_socket_finish()
             * to get the result of the operation.
             */
            accept_socket_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[Socket, GObject.Object | null]> | void;
            /**
             * Finishes an async accept operation. See g_socket_listener_accept_socket_async()
             */
            accept_socket_finish(result: AsyncResult): [Socket, GObject.Object | null];
            /**
             * Creates a socket of type `type `and protocol protocol, binds
             * it to `address `and adds it to the set of sockets we're accepting
             * sockets from.
             *
             * Note that adding an IPv6 address, depending on the platform,
             * may or may not result in a listener that also accepts IPv4
             * connections.  For more deterministic behavior, see
             * g_socket_listener_add_inet_port().
             *
             * `source_object `will be passed out in the various calls
             * to accept to identify this particular source, which is
             * useful if you're listening on multiple addresses and do
             * different things depending on what address is connected to.
             *
             * If successful and `effective_address `is non-%NULL then it will
             * be set to the address that the binding actually occurred at.  This
             * is helpful for determining the port number that was used for when
             * requesting a binding to port 0 (ie: "any port").  This address, if
             * requested, belongs to the caller and must be freed.
             *
             * Call g_socket_listener_close() to stop listening on address; this will not
             * be done automatically when you drop your final reference to listener, as
             * references may be held internally.
             */
            add_address(
                address: SocketAddress,
                type: SocketType,
                protocol: SocketProtocol,
                source_object?: GObject.Object | null
            ): [boolean, SocketAddress | null];
            /**
             * Listens for TCP connections on any available port number for both
             * IPv6 and IPv4 (if each is available).
             *
             * This is useful if you need to have a socket for incoming connections
             * but don't care about the specific port number.
             *
             * `source_object `will be passed out in the various calls
             * to accept to identify this particular source, which is
             * useful if you're listening on multiple addresses and do
             * different things depending on what address is connected to.
             */
            add_any_inet_port(source_object?: GObject.Object | null): number;
            /**
             * Helper function for g_socket_listener_add_address() that
             * creates a TCP/IP socket listening on IPv4 and IPv6 (if
             * supported) on the specified port on all interfaces.
             *
             * `source_object `will be passed out in the various calls
             * to accept to identify this particular source, which is
             * useful if you're listening on multiple addresses and do
             * different things depending on what address is connected to.
             *
             * Call g_socket_listener_close() to stop listening on port; this will not
             * be done automatically when you drop your final reference to listener, as
             * references may be held internally.
             */
            add_inet_port(port: number, source_object?: GObject.Object | null): boolean;
            /**
             * Adds `socket `to the set of sockets that we try to accept
             * new clients from. The socket must be bound to a local
             * address and listened to.
             *
             * `source_object `will be passed out in the various calls
             * to accept to identify this particular source, which is
             * useful if you're listening on multiple addresses and do
             * different things depending on what address is connected to.
             *
             * The `socket `will not be automatically closed when the `listener `is finalized
             * unless the listener held the final reference to the socket. Before GLib 2.42,
             * the `socket `was automatically closed on finalization of the listener, even
             * if references to it were held elsewhere.
             */
            add_socket(socket: Socket, source_object?: GObject.Object | null): boolean;
            /**
             * Closes all the sockets in the listener.
             */
            close(): void;
            /**
             * Sets the listen backlog on the sockets in the listener. This must be called
             * before adding any sockets, addresses or ports to the #GSocketListener (for
             * example, by calling g_socket_listener_add_inet_port()) to be effective.
             *
             * See g_socket_set_listen_backlog() for details
             */
            set_backlog(listen_backlog: number): void;
            vfunc_changed(): void;
            vfunc_event(event: SocketListenerEvent, socket: Socket): void;
        }
        export module SocketService {
            export interface ConstructorProperties extends SocketListener.ConstructorProperties {
                [key: string]: any;
                active: boolean;
            }
        }
        export class SocketService extends SocketListener {
            static $gtype: GObject.GType<SocketService>;

            constructor(properties?: Partial<SocketService.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SocketService.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get active(): boolean;
            set active(val: boolean);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "incoming",
                callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean
            ): number;
            connect_after(
                signal: "incoming",
                callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean
            ): number;
            emit(signal: "incoming", connection: SocketConnection, source_object?: GObject.Object | null): void;

            // Constructors

            static ["new"](): SocketService;

            // Members

            /**
             * Check whether the service is active or not. An active
             * service will accept new clients that connect, while
             * a non-active service will let connecting clients queue
             * up until the service is started.
             */
            is_active(): boolean;
            /**
             * Restarts the service, i.e. start accepting connections
             * from the added sockets when the mainloop runs. This only needs
             * to be called after the service has been stopped from
             * g_socket_service_stop().
             *
             * This call is thread-safe, so it may be called from a thread
             * handling an incoming client request.
             */
            start(): void;
            /**
             * Stops the service, i.e. stops accepting connections
             * from the added sockets when the mainloop runs.
             *
             * This call is thread-safe, so it may be called from a thread
             * handling an incoming client request.
             *
             * Note that this only stops accepting new connections; it does not
             * close the listening sockets, and you can call
             * g_socket_service_start() again later to begin listening again. To
             * close the listening sockets, call g_socket_listener_close(). (This
             * will happen automatically when the #GSocketService is finalized.)
             *
             * This must be called before calling g_socket_listener_close() as
             * the socket service will start accepting connections immediately
             * when a new socket is added.
             */
            stop(): void;
            vfunc_incoming(connection: SocketConnection, source_object: GObject.Object): boolean;
        }
        export module Subprocess {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                argv: string[];
                flags: SubprocessFlags;
            }
        }
        export class Subprocess extends GObject.Object implements Initable {
            static $gtype: GObject.GType<Subprocess>;

            constructor(properties?: Partial<Subprocess.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Subprocess.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set argv(val: string[]);
            set flags(val: SubprocessFlags);

            // Constructors

            static ["new"](argv: string[], flags: SubprocessFlags): Subprocess;

            // Members

            /**
             * Communicate with the subprocess until it terminates, and all input
             * and output has been completed.
             *
             * If `stdin_buf `is given, the subprocess must have been created with
             * %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
             * stdin of the subprocess and the pipe is closed (ie: EOF).
             *
             * At the same time (as not to cause blocking when dealing with large
             * amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
             * %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
             * streams.  The data that was read is returned in `stdout `and/or
             * the `stderr.`
             *
             * If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
             * `stdout_buf `will contain the data read from stdout.  Otherwise, for
             * subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
             * `stdout_buf `will be set to %NULL.  Similar provisions apply to
             * `stderr_buf `and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
             *
             * As usual, any output variable may be given as %NULL to ignore it.
             *
             * If you desire the stdout and stderr data to be interleaved, create
             * the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
             * %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
             * in `stdout_buf `and `stderr_buf `will be set to %NULL.
             *
             * In case of any error (including cancellation), %FALSE will be
             * returned with `error `set.  Some or all of the stdin data may have
             * been written.  Any stdout or stderr data that has been read will be
             * discarded. None of the out variables (aside from error) will have
             * been set to anything in particular and should not be inspected.
             *
             * In the case that %TRUE is returned, the subprocess has exited and the
             * exit status inspection APIs (eg: g_subprocess_get_if_exited(),
             * g_subprocess_get_exit_status()) may be used.
             *
             * You should not attempt to use any of the subprocess pipes after
             * starting this function, since they may be left in strange states,
             * even if the operation was cancelled.  You should especially not
             * attempt to interact with the pipes while the operation is in progress
             * (either from another thread or if using the asynchronous version).
             */
            communicate(
                stdin_buf?: GLib.Bytes | null,
                cancellable?: Cancellable | null
            ): [boolean, GLib.Bytes | null, GLib.Bytes | null];
            /**
             * Asynchronous version of g_subprocess_communicate().  Complete
             * invocation with g_subprocess_communicate_finish().
             */
            communicate_async(
                stdin_buf?: GLib.Bytes | null,
                cancellable?: Cancellable | null
            ): Promise<[GLib.Bytes | null, GLib.Bytes | null]>;
            /**
             * Asynchronous version of g_subprocess_communicate().  Complete
             * invocation with g_subprocess_communicate_finish().
             */
            communicate_async(
                stdin_buf: GLib.Bytes | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronous version of g_subprocess_communicate().  Complete
             * invocation with g_subprocess_communicate_finish().
             */
            communicate_async(
                stdin_buf?: GLib.Bytes | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[GLib.Bytes | null, GLib.Bytes | null]> | void;
            /**
             * Complete an invocation of g_subprocess_communicate_async().
             */
            communicate_finish(result: AsyncResult): [boolean, GLib.Bytes | null, GLib.Bytes | null];
            /**
             * Like g_subprocess_communicate(), but validates the output of the
             * process as UTF-8, and returns it as a regular NUL terminated string.
             *
             * On error, `stdout_buf `and `stderr_buf `will be set to undefined values and
             * should not be used.
             */
            communicate_utf8(stdin_buf: string | null, cancellable: Cancellable | null): [boolean, string, string];
            /**
             * Asynchronous version of g_subprocess_communicate_utf8().  Complete
             * invocation with g_subprocess_communicate_utf8_finish().
             */
            communicate_utf8_async(
                stdin_buf?: string | null,
                cancellable?: Cancellable | null
            ): Promise<[string, string]>;
            /**
             * Asynchronous version of g_subprocess_communicate_utf8().  Complete
             * invocation with g_subprocess_communicate_utf8_finish().
             */
            communicate_utf8_async(
                stdin_buf: string | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronous version of g_subprocess_communicate_utf8().  Complete
             * invocation with g_subprocess_communicate_utf8_finish().
             */
            communicate_utf8_async(
                stdin_buf?: string | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[string, string]> | void;
            /**
             * Complete an invocation of g_subprocess_communicate_utf8_async().
             */
            communicate_utf8_finish(result: AsyncResult): [boolean, string, string];
            /**
             * Use an operating-system specific method to attempt an immediate,
             * forceful termination of the process.  There is no mechanism to
             * determine whether or not the request itself was successful;
             * however, you can use g_subprocess_wait() to monitor the status of
             * the process after calling this function.
             *
             * On Unix, this function sends %SIGKILL.
             */
            force_exit(): void;
            /**
             * Check the exit status of the subprocess, given that it exited
             * normally.  This is the value passed to the exit() system call or the
             * return value from main.
             *
             * This is equivalent to the system WEXITSTATUS macro.
             *
             * It is an error to call this function before g_subprocess_wait() and
             * unless g_subprocess_get_if_exited() returned %TRUE.
             */
            get_exit_status(): number;
            /**
             * On UNIX, returns the process ID as a decimal string.
             * On Windows, returns the result of GetProcessId() also as a string.
             * If the subprocess has terminated, this will return %NULL.
             */
            get_identifier(): string | null;
            /**
             * Check if the given subprocess exited normally (ie: by way of exit()
             * or return from main()).
             *
             * This is equivalent to the system WIFEXITED macro.
             *
             * It is an error to call this function before g_subprocess_wait() has
             * returned.
             */
            get_if_exited(): boolean;
            /**
             * Check if the given subprocess terminated in response to a signal.
             *
             * This is equivalent to the system WIFSIGNALED macro.
             *
             * It is an error to call this function before g_subprocess_wait() has
             * returned.
             */
            get_if_signaled(): boolean;
            /**
             * Gets the raw status code of the process, as from waitpid().
             *
             * This value has no particular meaning, but it can be used with the
             * macros defined by the system headers such as WIFEXITED.  It can also
             * be used with g_spawn_check_wait_status().
             *
             * It is more likely that you want to use g_subprocess_get_if_exited()
             * followed by g_subprocess_get_exit_status().
             *
             * It is an error to call this function before g_subprocess_wait() has
             * returned.
             */
            get_status(): number;
            /**
             * Gets the #GInputStream from which to read the stderr output of
             * `subprocess.`
             *
             * The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
             * otherwise %NULL will be returned.
             */
            get_stderr_pipe(): InputStream | null;
            /**
             * Gets the #GOutputStream that you can write to in order to give data
             * to the stdin of `subprocess.`
             *
             * The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
             * not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
             */
            get_stdin_pipe(): OutputStream | null;
            /**
             * Gets the #GInputStream from which to read the stdout output of
             * `subprocess.`
             *
             * The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
             * otherwise %NULL will be returned.
             */
            get_stdout_pipe(): InputStream | null;
            /**
             * Checks if the process was "successful".  A process is considered
             * successful if it exited cleanly with an exit status of 0, either by
             * way of the exit() system call or return from main().
             *
             * It is an error to call this function before g_subprocess_wait() has
             * returned.
             */
            get_successful(): boolean;
            /**
             * Get the signal number that caused the subprocess to terminate, given
             * that it terminated due to a signal.
             *
             * This is equivalent to the system WTERMSIG macro.
             *
             * It is an error to call this function before g_subprocess_wait() and
             * unless g_subprocess_get_if_signaled() returned %TRUE.
             */
            get_term_sig(): number;
            /**
             * Sends the UNIX signal `signal_num `to the subprocess, if it is still
             * running.
             *
             * This API is race-free.  If the subprocess has terminated, it will not
             * be signalled.
             *
             * This API is not available on Windows.
             */
            send_signal(signal_num: number): void;
            /**
             * Synchronously wait for the subprocess to terminate.
             *
             * After the process terminates you can query its exit status with
             * functions such as g_subprocess_get_if_exited() and
             * g_subprocess_get_exit_status().
             *
             * This function does not fail in the case of the subprocess having
             * abnormal termination.  See g_subprocess_wait_check() for that.
             *
             * Cancelling `cancellable `doesn't kill the subprocess.  Call
             * g_subprocess_force_exit() if it is desirable.
             */
            wait(cancellable?: Cancellable | null): boolean;
            /**
             * Wait for the subprocess to terminate.
             *
             * This is the asynchronous version of g_subprocess_wait().
             */
            wait_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Wait for the subprocess to terminate.
             *
             * This is the asynchronous version of g_subprocess_wait().
             */
            wait_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Wait for the subprocess to terminate.
             *
             * This is the asynchronous version of g_subprocess_wait().
             */
            wait_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Combines g_subprocess_wait() with g_spawn_check_wait_status().
             */
            wait_check(cancellable?: Cancellable | null): boolean;
            /**
             * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
             *
             * This is the asynchronous version of g_subprocess_wait_check().
             */
            wait_check_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
             *
             * This is the asynchronous version of g_subprocess_wait_check().
             */
            wait_check_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
             *
             * This is the asynchronous version of g_subprocess_wait_check().
             */
            wait_check_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Collects the result of a previous call to
             * g_subprocess_wait_check_async().
             */
            wait_check_finish(result: AsyncResult): boolean;
            /**
             * Collects the result of a previous call to
             * g_subprocess_wait_async().
             */
            wait_finish(result: AsyncResult): boolean;

            // Implemented Members

            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }
        export module SubprocessLauncher {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                flags: SubprocessFlags;
            }
        }
        export class SubprocessLauncher extends GObject.Object {
            static $gtype: GObject.GType<SubprocessLauncher>;

            constructor(properties?: Partial<SubprocessLauncher.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<SubprocessLauncher.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set flags(val: SubprocessFlags);

            // Constructors

            static ["new"](flags: SubprocessFlags): SubprocessLauncher;

            // Members

            /**
             * Closes all the file descriptors previously passed to the object with
             * g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
             *
             * After calling this method, any subsequent calls to g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
             * return %G_IO_ERROR_CLOSED. This method is idempotent if
             * called more than once.
             *
             * This function is called automatically when the #GSubprocessLauncher
             * is disposed, but is provided separately so that garbage collected
             * language bindings can call it earlier to guarantee when FDs are closed.
             */
            close(): void;
            /**
             * Returns the value of the environment variable `variable `in the
             * environment of processes launched from this launcher.
             *
             * On UNIX, the returned string can be an arbitrary byte string.
             * On Windows, it will be UTF-8.
             */
            getenv(variable: string): string | null;
            /**
             * Sets the current working directory that processes will be launched
             * with.
             *
             * By default processes are launched with the current working directory
             * of the launching process at the time of launch.
             */
            set_cwd(cwd: string): void;
            /**
             * Replace the entire environment of processes launched from this
             * launcher with the given 'environ' variable.
             *
             * Typically you will build this variable by using g_listenv() to copy
             * the process 'environ' and using the functions g_environ_setenv(),
             * g_environ_unsetenv(), etc.
             *
             * As an alternative, you can use g_subprocess_launcher_setenv(),
             * g_subprocess_launcher_unsetenv(), etc.
             *
             * Pass an empty array to set an empty environment. Pass %NULL to inherit the
             * parent process’ environment. As of GLib 2.54, the parent process’ environment
             * will be copied when g_subprocess_launcher_set_environ() is called.
             * Previously, it was copied when the subprocess was executed. This means the
             * copied environment may now be modified (using g_subprocess_launcher_setenv(),
             * etc.) before launching the subprocess.
             *
             * On UNIX, all strings in this array can be arbitrary byte strings.
             * On Windows, they should be in UTF-8.
             */
            set_environ(env: string[]): void;
            /**
             * Sets the flags on the launcher.
             *
             * The default flags are %G_SUBPROCESS_FLAGS_NONE.
             *
             * You may not set flags that specify conflicting options for how to
             * handle a particular stdio stream (eg: specifying both
             * %G_SUBPROCESS_FLAGS_STDIN_PIPE and
             * %G_SUBPROCESS_FLAGS_STDIN_INHERIT).
             *
             * You may also not set a flag that conflicts with a previous call to a
             * function like g_subprocess_launcher_set_stdin_file_path() or
             * g_subprocess_launcher_take_stdout_fd().
             */
            set_flags(flags: SubprocessFlags): void;
            /**
             * Sets the file path to use as the stderr for spawned processes.
             *
             * If `path `is %NULL then any previously given path is unset.
             *
             * The file will be created or truncated when the process is spawned, as
             * would be the case if using '2&gt;' at the shell.
             *
             * If you want to send both stdout and stderr to the same file then use
             * %G_SUBPROCESS_FLAGS_STDERR_MERGE.
             *
             * You may not set a stderr file path if a stderr fd is already set or
             * if the launcher flags contain any flags directing stderr elsewhere.
             *
             * This feature is only available on UNIX.
             */
            set_stderr_file_path(path?: string | null): void;
            /**
             * Sets the file path to use as the stdin for spawned processes.
             *
             * If `path `is %NULL then any previously given path is unset.
             *
             * The file must exist or spawning the process will fail.
             *
             * You may not set a stdin file path if a stdin fd is already set or if
             * the launcher flags contain any flags directing stdin elsewhere.
             *
             * This feature is only available on UNIX.
             */
            set_stdin_file_path(path: string): void;
            /**
             * Sets the file path to use as the stdout for spawned processes.
             *
             * If `path `is %NULL then any previously given path is unset.
             *
             * The file will be created or truncated when the process is spawned, as
             * would be the case if using '&gt;' at the shell.
             *
             * You may not set a stdout file path if a stdout fd is already set or
             * if the launcher flags contain any flags directing stdout elsewhere.
             *
             * This feature is only available on UNIX.
             */
            set_stdout_file_path(path?: string | null): void;
            /**
             * Sets the environment variable `variable `in the environment of
             * processes launched from this launcher.
             *
             * On UNIX, both the variable's name and value can be arbitrary byte
             * strings, except that the variable's name cannot contain '='.
             * On Windows, they should be in UTF-8.
             */
            setenv(variable: string, value: string, overwrite: boolean): void;
            /**
             * Creates a #GSubprocess given a provided array of arguments.
             */
            spawnv(argv: string[]): Subprocess;
            /**
             * Transfer an arbitrary file descriptor from parent process to the
             * child.  This function takes ownership of the source_fd; it will be closed
             * in the parent when `self `is freed.
             *
             * By default, all file descriptors from the parent will be closed.
             * This function allows you to create (for example) a custom `pipe()` or
             * `socketpair()` before launching the process, and choose the target
             * descriptor in the child.
             *
             * An example use case is GNUPG, which has a command line argument
             * `--passphrase-fd` providing a file descriptor number where it expects
             * the passphrase to be written.
             */
            take_fd(source_fd: number, target_fd: number): void;
            /**
             * Sets the file descriptor to use as the stderr for spawned processes.
             *
             * If `fd `is -1 then any previously given fd is unset.
             *
             * Note that the default behaviour is to pass stderr through to the
             * stderr of the parent process.
             *
             * The passed `fd `belongs to the #GSubprocessLauncher.  It will be
             * automatically closed when the launcher is finalized.  The file
             * descriptor will also be closed on the child side when executing the
             * spawned process.
             *
             * You may not set a stderr fd if a stderr file path is already set or
             * if the launcher flags contain any flags directing stderr elsewhere.
             *
             * This feature is only available on UNIX.
             */
            take_stderr_fd(fd: number): void;
            /**
             * Sets the file descriptor to use as the stdin for spawned processes.
             *
             * If `fd `is -1 then any previously given fd is unset.
             *
             * Note that if your intention is to have the stdin of the calling
             * process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
             * is a better way to go about doing that.
             *
             * The passed `fd `is noted but will not be touched in the current
             * process.  It is therefore necessary that it be kept open by the
             * caller until the subprocess is spawned.  The file descriptor will
             * also not be explicitly closed on the child side, so it must be marked
             * O_CLOEXEC if that's what you want.
             *
             * You may not set a stdin fd if a stdin file path is already set or if
             * the launcher flags contain any flags directing stdin elsewhere.
             *
             * This feature is only available on UNIX.
             */
            take_stdin_fd(fd: number): void;
            /**
             * Sets the file descriptor to use as the stdout for spawned processes.
             *
             * If `fd `is -1 then any previously given fd is unset.
             *
             * Note that the default behaviour is to pass stdout through to the
             * stdout of the parent process.
             *
             * The passed `fd `is noted but will not be touched in the current
             * process.  It is therefore necessary that it be kept open by the
             * caller until the subprocess is spawned.  The file descriptor will
             * also not be explicitly closed on the child side, so it must be marked
             * O_CLOEXEC if that's what you want.
             *
             * You may not set a stdout fd if a stdout file path is already set or
             * if the launcher flags contain any flags directing stdout elsewhere.
             *
             * This feature is only available on UNIX.
             */
            take_stdout_fd(fd: number): void;
            /**
             * Removes the environment variable `variable `from the environment of
             * processes launched from this launcher.
             *
             * On UNIX, the variable's name can be an arbitrary byte string not
             * containing '='. On Windows, it should be in UTF-8.
             */
            unsetenv(variable: string): void;
        }
        export module Task {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                completed: boolean;
            }
        }
        export class Task extends GObject.Object implements AsyncResult {
            static $gtype: GObject.GType<Task>;

            constructor(properties?: Partial<Task.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Task.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get completed(): boolean;

            // Constructors

            static ["new"](
                source_object?: GObject.Object | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback | null
            ): Task;

            // Members

            /**
             * Gets task's #GCancellable
             */
            get_cancellable(): Cancellable | null;
            /**
             * Gets task's check-cancellable flag. See
             * g_task_set_check_cancellable() for more details.
             */
            get_check_cancellable(): boolean;
            /**
             * Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
             * the task’s callback is invoked, and will return %FALSE if called from inside
             * the callback.
             */
            get_completed(): boolean;
            /**
             * Gets the #GMainContext that `task `will return its result in (that
             * is, the context that was the
             * [thread-default main context][g-main-context-push-thread-default]
             * at the point when `task `was created).
             *
             * This will always return a non-%NULL value, even if the task's
             * context is the default #GMainContext.
             */
            get_context(): GLib.MainContext;
            /**
             * Gets task’s name. See g_task_set_name().
             */
            get_name(): string | null;
            /**
             * Gets task's priority
             */
            get_priority(): number;
            /**
             * Gets task's return-on-cancel flag. See
             * g_task_set_return_on_cancel() for more details.
             */
            get_return_on_cancel(): boolean;
            /**
             * Gets the source object from `task.` Like
             * g_async_result_get_source_object(), but does not ref the object.
             */
            get_source_object<T = GObject.Object>(): T;
            /**
             * Gets task's source tag. See g_task_set_source_tag().
             */
            get_source_tag(): any | null;
            /**
             * Gets task's `task_data`.
             */
            get_task_data(): any | null;
            /**
             * Tests if `task `resulted in an error.
             */
            had_error(): boolean;
            /**
             * Gets the result of `task `as a #gboolean.
             *
             * If the task resulted in an error, or was cancelled, then this will
             * instead return %FALSE and set `error.`
             *
             * Since this method transfers ownership of the return value (or
             * error) to the caller, you may only call it once.
             */
            propagate_boolean(): boolean;
            /**
             * Gets the result of `task `as an integer (#gssize).
             *
             * If the task resulted in an error, or was cancelled, then this will
             * instead return -1 and set `error.`
             *
             * Since this method transfers ownership of the return value (or
             * error) to the caller, you may only call it once.
             */
            propagate_int(): number;
            /**
             * Gets the result of `task `as a pointer, and transfers ownership
             * of that value to the caller.
             *
             * If the task resulted in an error, or was cancelled, then this will
             * instead return %NULL and set `error.`
             *
             * Since this method transfers ownership of the return value (or
             * error) to the caller, you may only call it once.
             */
            propagate_pointer(): any | null;
            /**
             * Gets the result of `task `as a #GValue, and transfers ownership of
             * that value to the caller. As with g_task_return_value(), this is
             * a generic low-level method; g_task_propagate_pointer() and the like
             * will usually be more useful for C code.
             *
             * If the task resulted in an error, or was cancelled, then this will
             * instead set `error `and return %FALSE.
             *
             * Since this method transfers ownership of the return value (or
             * error) to the caller, you may only call it once.
             */
            propagate_value(): [boolean, unknown];
            /**
             * Sets task's result to `result `and completes the task (see
             * g_task_return_pointer() for more discussion of exactly what this
             * means).
             */
            return_boolean(result: boolean): void;
            /**
             * Sets task's result to `error `(which `task `assumes ownership of)
             * and completes the task (see g_task_return_pointer() for more
             * discussion of exactly what this means).
             *
             * Note that since the task takes ownership of error, and since the
             * task may be completed before returning from g_task_return_error(),
             * you cannot assume that `error `is still valid after calling this.
             * Call g_error_copy() on the error if you need to keep a local copy
             * as well.
             *
             * See also g_task_return_new_error().
             */
            return_error(error: GLib.Error): void;
            /**
             * Checks if task's #GCancellable has been cancelled, and if so, sets
             * task's error accordingly and completes the task (see
             * g_task_return_pointer() for more discussion of exactly what this
             * means).
             */
            return_error_if_cancelled(): boolean;
            /**
             * Sets task's result to `result `and completes the task (see
             * g_task_return_pointer() for more discussion of exactly what this
             * means).
             */
            return_int(result: number): void;
            /**
             * Sets task's result to `result `and completes the task. If result
             * is not %NULL, then `result_destroy `will be used to free `result `if
             * the caller does not take ownership of it with
             * g_task_propagate_pointer().
             *
             * "Completes the task" means that for an ordinary asynchronous task
             * it will either invoke the task's callback, or else queue that
             * callback to be invoked in the proper #GMainContext, or in the next
             * iteration of the current #GMainContext. For a task run via
             * g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
             * method will save `result `to be returned to the caller later, but
             * the task will not actually be completed until the #GTaskThreadFunc
             * exits.
             *
             * Note that since the task may be completed before returning from
             * g_task_return_pointer(), you cannot assume that `result `is still
             * valid after calling this, unless you are still holding another
             * reference on it.
             */
            return_pointer(result?: any | null, result_destroy?: GLib.DestroyNotify | null): void;
            /**
             * Sets task's result to `result `(by copying it) and completes the task.
             *
             * If `result `is %NULL then a #GValue of type %G_TYPE_POINTER
             * with a value of %NULL will be used for the result.
             *
             * This is a very generic low-level method intended primarily for use
             * by language bindings; for C code, g_task_return_pointer() and the
             * like will normally be much easier to use.
             */
            return_value(result?: GObject.Value | null): void;
            /**
             * Runs `task_func `in another thread. When `task_func `returns, task's
             * #GAsyncReadyCallback will be invoked in task's #GMainContext.
             *
             * This takes a ref on `task `until the task completes.
             *
             * See #GTaskThreadFunc for more details about how `task_func `is handled.
             *
             * Although GLib currently rate-limits the tasks queued via
             * g_task_run_in_thread(), you should not assume that it will always
             * do this. If you have a very large number of tasks to run (several tens of
             * tasks), but don't want them to all run at once, you should only queue a
             * limited number of them (around ten) at a time.
             */
            run_in_thread(task_func: TaskThreadFunc): void;
            /**
             * Runs `task_func `in another thread, and waits for it to return or be
             * cancelled. You can use g_task_propagate_pointer(), etc, afterward
             * to get the result of `task_func.`
             *
             * See #GTaskThreadFunc for more details about how `task_func `is handled.
             *
             * Normally this is used with tasks created with a %NULL
             * `callback`, but note that even if the task does
             * have a callback, it will not be invoked when `task_func `returns.
             * #GTask:completed will be set to %TRUE just before this function returns.
             *
             * Although GLib currently rate-limits the tasks queued via
             * g_task_run_in_thread_sync(), you should not assume that it will
             * always do this. If you have a very large number of tasks to run,
             * but don't want them to all run at once, you should only queue a
             * limited number of them at a time.
             */
            run_in_thread_sync(task_func: TaskThreadFunc): void;
            /**
             * Sets or clears task's check-cancellable flag. If this is %TRUE
             * (the default), then g_task_propagate_pointer(), etc, and
             * g_task_had_error() will check the task's #GCancellable first, and
             * if it has been cancelled, then they will consider the task to have
             * returned an "Operation was cancelled" error
             * (%G_IO_ERROR_CANCELLED), regardless of any other error or return
             * value the task may have had.
             *
             * If `check_cancellable `is %FALSE, then the #GTask will not check the
             * cancellable itself, and it is up to task's owner to do this (eg,
             * via g_task_return_error_if_cancelled()).
             *
             * If you are using g_task_set_return_on_cancel() as well, then
             * you must leave check-cancellable set %TRUE.
             */
            set_check_cancellable(check_cancellable: boolean): void;
            /**
             * Sets task’s name, used in debugging and profiling. The name defaults to
             * %NULL.
             *
             * The task name should describe in a human readable way what the task does.
             * For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
             * name of the #GSource used for idle completion of the task.
             *
             * This function may only be called before the `task `is first used in a thread
             * other than the one it was constructed in. It is called automatically by
             * g_task_set_source_tag() if not called already.
             */
            set_name(name?: string | null): void;
            /**
             * Sets task's priority. If you do not call this, it will default to
             * %G_PRIORITY_DEFAULT.
             *
             * This will affect the priority of #GSources created with
             * g_task_attach_source() and the scheduling of tasks run in threads,
             * and can also be explicitly retrieved later via
             * g_task_get_priority().
             */
            set_priority(priority: number): void;
            /**
             * Sets or clears task's return-on-cancel flag. This is only
             * meaningful for tasks run via g_task_run_in_thread() or
             * g_task_run_in_thread_sync().
             *
             * If `return_on_cancel `is %TRUE, then cancelling task's
             * #GCancellable will immediately cause it to return, as though the
             * task's #GTaskThreadFunc had called
             * g_task_return_error_if_cancelled() and then returned.
             *
             * This allows you to create a cancellable wrapper around an
             * uninterruptible function. The #GTaskThreadFunc just needs to be
             * careful that it does not modify any externally-visible state after
             * it has been cancelled. To do that, the thread should call
             * g_task_set_return_on_cancel() again to (atomically) set
             * return-on-cancel %FALSE before making externally-visible changes;
             * if the task gets cancelled before the return-on-cancel flag could
             * be changed, g_task_set_return_on_cancel() will indicate this by
             * returning %FALSE.
             *
             * You can disable and re-enable this flag multiple times if you wish.
             * If the task's #GCancellable is cancelled while return-on-cancel is
             * %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
             * again will cause the task to be cancelled at that point.
             *
             * If the task's #GCancellable is already cancelled before you call
             * g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
             * #GTaskThreadFunc will still be run (for consistency), but the task
             * will also be completed right away.
             */
            set_return_on_cancel(return_on_cancel: boolean): boolean;
            /**
             * Sets task's source tag.
             *
             * You can use this to tag a task return
             * value with a particular pointer (usually a pointer to the function
             * doing the tagging) and then later check it using
             * g_task_get_source_tag() (or g_async_result_is_tagged()) in the
             * task's "finish" function, to figure out if the response came from a
             * particular place.
             *
             * A macro wrapper around this function will automatically set the
             * task’s name to the string form of `source_tag `if it’s not already
             * set, for convenience.
             */
            set_source_tag(source_tag?: any | null): void;
            /**
             * Sets task’s name, used in debugging and profiling.
             *
             * This is a variant of g_task_set_name() that avoids copying `name.`
             */
            set_static_name(name?: string | null): void;
            /**
             * Sets task's task data (freeing the existing task data, if any).
             */
            set_task_data(task_data?: any | null, task_data_destroy?: GLib.DestroyNotify | null): void;
            /**
             * Checks that `result `is a #GTask, and that `source_object `is its
             * source object (or that `source_object `is %NULL and `result `has no
             * source object). This can be used in g_return_if_fail() checks.
             */
            static is_valid(result: AsyncResult, source_object?: GObject.Object | null): boolean;
            /**
             * Creates a #GTask and then immediately calls g_task_return_error()
             * on it. Use this in the wrapper function of an asynchronous method
             * when you want to avoid even calling the virtual method. You can
             * then use g_async_result_is_tagged() in the finish method wrapper to
             * check if the result there is tagged as having been created by the
             * wrapper method, and deal with it appropriately if so.
             *
             * See also g_task_report_new_error().
             */
            static report_error(
                source_object: GObject.Object | null,
                callback: AsyncReadyCallback<Task> | null,
                source_tag: any | null,
                error: GLib.Error
            ): void;

            // Implemented Members

            /**
             * Gets the user data from a #GAsyncResult.
             */
            get_user_data(): any | null;
            /**
             * Checks if `res `has the given `source_tag `(generally a function
             * pointer indicating the function `res `was created by).
             */
            is_tagged(source_tag?: any | null): boolean;
            /**
             * If `res `is a #GSimpleAsyncResult, this is equivalent to
             * g_simple_async_result_propagate_error(). Otherwise it returns
             * %FALSE.
             *
             * This can be used for legacy error handling in async *_finish()
             * wrapper functions that traditionally handled #GSimpleAsyncResult
             * error returns themselves rather than calling into the virtual method.
             * This should not be used in new code; #GAsyncResult errors that are
             * set by virtual methods should also be extracted by virtual methods,
             * to enable subclasses to chain up correctly.
             */
            legacy_propagate_error(): boolean;
            /**
             * Gets the source object from a #GAsyncResult.
             */
            vfunc_get_source_object<T = GObject.Object>(): T;
            /**
             * Gets the user data from a #GAsyncResult.
             */
            vfunc_get_user_data(): any | null;
            /**
             * Checks if `res `has the given `source_tag `(generally a function
             * pointer indicating the function `res `was created by).
             */
            vfunc_is_tagged(source_tag?: any | null): boolean;
        }
        export module TcpConnection {
            export interface ConstructorProperties extends SocketConnection.ConstructorProperties {
                [key: string]: any;
                graceful_disconnect: boolean;
                gracefulDisconnect: boolean;
            }
        }
        export class TcpConnection extends SocketConnection {
            static $gtype: GObject.GType<TcpConnection>;

            constructor(properties?: Partial<TcpConnection.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TcpConnection.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get graceful_disconnect(): boolean;
            set graceful_disconnect(val: boolean);
            get gracefulDisconnect(): boolean;
            set gracefulDisconnect(val: boolean);

            // Members

            /**
             * Checks if graceful disconnects are used. See
             * g_tcp_connection_set_graceful_disconnect().
             */
            get_graceful_disconnect(): boolean;
            /**
             * This enables graceful disconnects on close. A graceful disconnect
             * means that we signal the receiving end that the connection is terminated
             * and wait for it to close the connection before closing the connection.
             *
             * A graceful disconnect means that we can be sure that we successfully sent
             * all the outstanding data to the other end, or get an error reported.
             * However, it also means we have to wait for all the data to reach the
             * other side and for it to acknowledge this by closing the socket, which may
             * take a while. For this reason it is disabled by default.
             */
            set_graceful_disconnect(graceful_disconnect: boolean): void;
        }
        export module TcpWrapperConnection {
            export interface ConstructorProperties extends TcpConnection.ConstructorProperties {
                [key: string]: any;
                base_io_stream: IOStream;
                baseIoStream: IOStream;
            }
        }
        export class TcpWrapperConnection extends TcpConnection {
            static $gtype: GObject.GType<TcpWrapperConnection>;

            constructor(properties?: Partial<TcpWrapperConnection.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TcpWrapperConnection.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get base_io_stream(): IOStream;
            get baseIoStream(): IOStream;

            // Constructors

            static ["new"](base_io_stream: IOStream, socket: Socket): TcpWrapperConnection;

            // Members

            /**
             * Gets conn's base #GIOStream
             */
            get_base_io_stream(): IOStream;
        }
        export module TestDBus {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                flags: TestDBusFlags;
            }
        }
        export class TestDBus extends GObject.Object {
            static $gtype: GObject.GType<TestDBus>;

            constructor(properties?: Partial<TestDBus.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TestDBus.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get flags(): TestDBusFlags;

            // Constructors

            static ["new"](flags: TestDBusFlags): TestDBus;

            // Members

            /**
             * Add a path where dbus-daemon will look up .service files. This can't be
             * called after g_test_dbus_up().
             */
            add_service_dir(path: string): void;
            /**
             * Stop the session bus started by g_test_dbus_up().
             *
             * This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
             * to be destroyed. This is done to ensure that the next unit test won't get a
             * leaked singleton from this test.
             */
            down(): void;
            /**
             * Get the address on which dbus-daemon is running. If g_test_dbus_up() has not
             * been called yet, %NULL is returned. This can be used with
             * g_dbus_connection_new_for_address().
             */
            get_bus_address(): string | null;
            /**
             * Get the flags of the #GTestDBus object.
             */
            get_flags(): TestDBusFlags;
            /**
             * Stop the session bus started by g_test_dbus_up().
             *
             * Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
             * singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
             * tests wanting to verify behaviour after the session bus has been stopped
             * can use this function but should still call g_test_dbus_down() when done.
             */
            stop(): void;
            /**
             * Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
             * call, it is safe for unit tests to start sending messages on the session bus.
             *
             * If this function is called from setup callback of g_test_add(),
             * g_test_dbus_down() must be called in its teardown callback.
             *
             * If this function is called from unit test's main(), then g_test_dbus_down()
             * must be called after g_test_run().
             */
            up(): void;
            /**
             * Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
             * won't use user's session bus.
             *
             * This is useful for unit tests that want to verify behaviour when no session
             * bus is running. It is not necessary to call this if unit test already calls
             * g_test_dbus_up() before acquiring the session bus.
             */
            static unset(): void;
        }
        export module ThemedIcon {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                name: string;
                names: string[];
                use_default_fallbacks: boolean;
                useDefaultFallbacks: boolean;
            }
        }
        export class ThemedIcon extends GObject.Object implements Icon {
            static $gtype: GObject.GType<ThemedIcon>;

            constructor(properties?: Partial<ThemedIcon.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ThemedIcon.ConstructorProperties>, ...args: any[]): void;

            // Properties
            set name(val: string);
            get names(): string[];
            get use_default_fallbacks(): boolean;
            get useDefaultFallbacks(): boolean;

            // Constructors

            static ["new"](iconname: string): ThemedIcon;
            static new_from_names(iconnames: string[]): ThemedIcon;
            static new_with_default_fallbacks(iconname: string): ThemedIcon;

            // Members

            /**
             * Append a name to the list of icons from within `icon.`
             *
             * Note that doing so invalidates the hash computed by prior calls
             * to g_icon_hash().
             */
            append_name(iconname: string): void;
            /**
             * Gets the names of icons from within `icon.`
             */
            get_names(): string[];
            /**
             * Prepend a name to the list of icons from within `icon.`
             *
             * Note that doing so invalidates the hash computed by prior calls
             * to g_icon_hash().
             */
            prepend_name(iconname: string): void;

            // Implemented Members

            /**
             * Checks if two icons are equal.
             */
            equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            serialize(): GLib.Variant | null;
            /**
             * Generates a textual representation of `icon `that can be used for
             * serialization such as when passing `icon `to a different process or
             * saving it to persistent storage. Use g_icon_new_for_string() to
             * get `icon `back from the returned string.
             *
             * The encoding of the returned string is proprietary to #GIcon except
             * in the following two cases
             *
             * - If `icon `is a #GFileIcon, the returned string is a native path
             * (such as `/path/to/my icon.png`) without escaping
             * if the #GFile for `icon `is a native file.  If the file is not
             * native, the returned string is the result of g_file_get_uri()
             * (such as `sftp://path/to/my%20icon.png`).
             *
             * - If `icon `is a #GThemedIcon with exactly one name and no fallbacks,
             * the encoding is simply the name (such as `network-server`).
             */
            to_string(): string | null;
            /**
             * Checks if two icons are equal.
             */
            vfunc_equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            vfunc_hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            vfunc_serialize(): GLib.Variant | null;
            /**
             * Serializes the `icon `into string tokens.
             * This is can be invoked when g_icon_new_for_string() is called.
             */
            vfunc_to_tokens(): [boolean, string[], number];
        }
        export module ThreadedSocketService {
            export interface ConstructorProperties extends SocketService.ConstructorProperties {
                [key: string]: any;
                max_threads: number;
                maxThreads: number;
            }
        }
        export class ThreadedSocketService extends SocketService {
            static $gtype: GObject.GType<ThreadedSocketService>;

            constructor(properties?: Partial<ThreadedSocketService.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ThreadedSocketService.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get max_threads(): number;
            get maxThreads(): number;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "run",
                callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean
            ): number;
            connect_after(
                signal: "run",
                callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean
            ): number;
            emit(signal: "run", connection: SocketConnection, source_object?: GObject.Object | null): void;

            // Constructors

            static ["new"](max_threads: number): ThreadedSocketService;
            // Conflicted with Gio.SocketService.new
            static ["new"](...args: never[]): any;

            // Members

            vfunc_run(connection: SocketConnection, source_object: GObject.Object): boolean;
        }
        export module TlsCertificate {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                certificate: Uint8Array;
                certificate_pem: string;
                certificatePem: string;
                dns_names: any[];
                dnsNames: any[];
                ip_addresses: any[];
                ipAddresses: any[];
                issuer: TlsCertificate;
                issuer_name: string;
                issuerName: string;
                not_valid_after: GLib.DateTime;
                notValidAfter: GLib.DateTime;
                not_valid_before: GLib.DateTime;
                notValidBefore: GLib.DateTime;
                password: string;
                pkcs11_uri: string;
                pkcs11Uri: string;
                pkcs12_data: Uint8Array;
                pkcs12Data: Uint8Array;
                private_key: Uint8Array;
                privateKey: Uint8Array;
                private_key_pem: string;
                privateKeyPem: string;
                private_key_pkcs11_uri: string;
                privateKeyPkcs11Uri: string;
                subject_name: string;
                subjectName: string;
            }
        }
        export abstract class TlsCertificate extends GObject.Object {
            static $gtype: GObject.GType<TlsCertificate>;

            constructor(properties?: Partial<TlsCertificate.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TlsCertificate.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get certificate(): Uint8Array;
            get certificate_pem(): string;
            get certificatePem(): string;
            get dns_names(): any[];
            get dnsNames(): any[];
            get ip_addresses(): any[];
            get ipAddresses(): any[];
            get issuer(): TlsCertificate;
            get issuer_name(): string;
            get issuerName(): string;
            get not_valid_after(): GLib.DateTime;
            get notValidAfter(): GLib.DateTime;
            get not_valid_before(): GLib.DateTime;
            get notValidBefore(): GLib.DateTime;
            set password(val: string);
            get pkcs11_uri(): string;
            get pkcs11Uri(): string;
            set pkcs12_data(val: Uint8Array);
            set pkcs12Data(val: Uint8Array);
            get private_key(): Uint8Array;
            get privateKey(): Uint8Array;
            get private_key_pem(): string;
            get privateKeyPem(): string;
            get private_key_pkcs11_uri(): string;
            get privateKeyPkcs11Uri(): string;
            get subject_name(): string;
            get subjectName(): string;

            // Constructors

            static new_from_file(file: string): TlsCertificate;
            static new_from_file_with_password(file: string, password: string): TlsCertificate;
            static new_from_files(cert_file: string, key_file: string): TlsCertificate;
            static new_from_pem(data: string, length: number): TlsCertificate;
            static new_from_pkcs11_uris(pkcs11_uri: string, private_key_pkcs11_uri?: string | null): TlsCertificate;
            static new_from_pkcs12(data: Uint8Array | string, password?: string | null): TlsCertificate;

            // Members

            /**
             * Gets the value of #GTlsCertificate:dns-names.
             */
            get_dns_names(): GLib.Bytes[] | null;
            /**
             * Gets the value of #GTlsCertificate:ip-addresses.
             */
            get_ip_addresses(): InetAddress[] | null;
            /**
             * Gets the #GTlsCertificate representing cert's issuer, if known
             */
            get_issuer(): TlsCertificate | null;
            /**
             * Returns the issuer name from the certificate.
             */
            get_issuer_name(): string | null;
            /**
             * Returns the time at which the certificate became or will become invalid.
             */
            get_not_valid_after(): GLib.DateTime | null;
            /**
             * Returns the time at which the certificate became or will become valid.
             */
            get_not_valid_before(): GLib.DateTime | null;
            /**
             * Returns the subject name from the certificate.
             */
            get_subject_name(): string | null;
            /**
             * Check if two #GTlsCertificate objects represent the same certificate.
             * The raw DER byte data of the two certificates are checked for equality.
             * This has the effect that two certificates may compare equal even if
             * their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
             * #GTlsCertificate:private-key-pem properties differ.
             */
            is_same(cert_two: TlsCertificate): boolean;
            /**
             * This verifies `cert `and returns a set of #GTlsCertificateFlags
             * indicating any problems found with it. This can be used to verify a
             * certificate outside the context of making a connection, or to
             * check a certificate against a CA that is not part of the system
             * CA database.
             *
             * If `cert `is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
             *
             * If `identity `is not %NULL, cert's name(s) will be compared against
             * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
             * value if it does not match. If `identity `is %NULL, that bit will
             * never be set in the return value.
             *
             * If `trusted_ca `is not %NULL, then `cert `(or one of the certificates
             * in its chain) must be signed by it, or else
             * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
             * `trusted_ca `is %NULL, that bit will never be set in the return
             * value.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * error will be set in the return value, but it does not guarantee
             * that all possible errors will be set. Accordingly, you may not safely
             * decide to ignore any particular type of error. For example, it would
             * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
             * expired certificates, because this could potentially be the only
             * error flag set even if other problems exist with the certificate.
             *
             * Because TLS session context is not used, #GTlsCertificate may not
             * perform as many checks on the certificates as #GTlsConnection would.
             * For example, certificate constraints may not be honored, and
             * revocation checks may not be performed. The best way to verify TLS
             * certificates used by a TLS connection is to let #GTlsConnection
             * handle the verification.
             */
            verify(identity?: SocketConnectable | null, trusted_ca?: TlsCertificate | null): TlsCertificateFlags;
            /**
             * This verifies `cert `and returns a set of #GTlsCertificateFlags
             * indicating any problems found with it. This can be used to verify a
             * certificate outside the context of making a connection, or to
             * check a certificate against a CA that is not part of the system
             * CA database.
             *
             * If `cert `is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
             *
             * If `identity `is not %NULL, cert's name(s) will be compared against
             * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
             * value if it does not match. If `identity `is %NULL, that bit will
             * never be set in the return value.
             *
             * If `trusted_ca `is not %NULL, then `cert `(or one of the certificates
             * in its chain) must be signed by it, or else
             * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
             * `trusted_ca `is %NULL, that bit will never be set in the return
             * value.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * error will be set in the return value, but it does not guarantee
             * that all possible errors will be set. Accordingly, you may not safely
             * decide to ignore any particular type of error. For example, it would
             * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
             * expired certificates, because this could potentially be the only
             * error flag set even if other problems exist with the certificate.
             *
             * Because TLS session context is not used, #GTlsCertificate may not
             * perform as many checks on the certificates as #GTlsConnection would.
             * For example, certificate constraints may not be honored, and
             * revocation checks may not be performed. The best way to verify TLS
             * certificates used by a TLS connection is to let #GTlsConnection
             * handle the verification.
             */
            vfunc_verify(identity?: SocketConnectable | null, trusted_ca?: TlsCertificate | null): TlsCertificateFlags;
            /**
             * Creates one or more #GTlsCertificates from the PEM-encoded
             * data in `file.` If `file `cannot be read or parsed, the function will
             * return %NULL and set `error.` If `file `does not contain any
             * PEM-encoded certificates, this will return an empty list and not
             * set `error.`
             */
            static list_new_from_file(file: string): TlsCertificate[];
        }
        export module TlsConnection {
            export interface ConstructorProperties extends IOStream.ConstructorProperties {
                [key: string]: any;
                advertised_protocols: string[];
                advertisedProtocols: string[];
                base_io_stream: IOStream;
                baseIoStream: IOStream;
                certificate: TlsCertificate;
                ciphersuite_name: string;
                ciphersuiteName: string;
                database: TlsDatabase;
                interaction: TlsInteraction;
                negotiated_protocol: string;
                negotiatedProtocol: string;
                peer_certificate: TlsCertificate;
                peerCertificate: TlsCertificate;
                peer_certificate_errors: TlsCertificateFlags;
                peerCertificateErrors: TlsCertificateFlags;
                protocol_version: TlsProtocolVersion;
                protocolVersion: TlsProtocolVersion;
                rehandshake_mode: TlsRehandshakeMode;
                rehandshakeMode: TlsRehandshakeMode;
                require_close_notify: boolean;
                requireCloseNotify: boolean;
                use_system_certdb: boolean;
                useSystemCertdb: boolean;
            }
        }
        export abstract class TlsConnection extends IOStream {
            static $gtype: GObject.GType<TlsConnection>;

            constructor(properties?: Partial<TlsConnection.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TlsConnection.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get advertised_protocols(): string[];
            set advertised_protocols(val: string[]);
            get advertisedProtocols(): string[];
            set advertisedProtocols(val: string[]);
            get base_io_stream(): IOStream;
            get baseIoStream(): IOStream;
            get certificate(): TlsCertificate;
            set certificate(val: TlsCertificate);
            get ciphersuite_name(): string;
            get ciphersuiteName(): string;
            get database(): TlsDatabase;
            set database(val: TlsDatabase);
            get interaction(): TlsInteraction;
            set interaction(val: TlsInteraction);
            get negotiated_protocol(): string;
            get negotiatedProtocol(): string;
            get peer_certificate(): TlsCertificate;
            get peerCertificate(): TlsCertificate;
            get peer_certificate_errors(): TlsCertificateFlags;
            get peerCertificateErrors(): TlsCertificateFlags;
            get protocol_version(): TlsProtocolVersion;
            get protocolVersion(): TlsProtocolVersion;
            get rehandshake_mode(): TlsRehandshakeMode;
            set rehandshake_mode(val: TlsRehandshakeMode);
            get rehandshakeMode(): TlsRehandshakeMode;
            set rehandshakeMode(val: TlsRehandshakeMode);
            get require_close_notify(): boolean;
            set require_close_notify(val: boolean);
            get requireCloseNotify(): boolean;
            set requireCloseNotify(val: boolean);
            get use_system_certdb(): boolean;
            set use_system_certdb(val: boolean);
            get useSystemCertdb(): boolean;
            set useSystemCertdb(val: boolean);

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(
                signal: "accept-certificate",
                callback: (_source: this, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean
            ): number;
            connect_after(
                signal: "accept-certificate",
                callback: (_source: this, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean
            ): number;
            emit(signal: "accept-certificate", peer_cert: TlsCertificate, errors: TlsCertificateFlags): void;

            // Members

            /**
             * Used by #GTlsConnection implementations to emit the
             * #GTlsConnection::accept-certificate signal.
             */
            emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
            /**
             * Gets conn's certificate, as set by
             * g_tls_connection_set_certificate().
             */
            get_certificate(): TlsCertificate | null;
            /**
             * Query the TLS backend for TLS channel binding data of `type `for `conn.`
             *
             * This call retrieves TLS channel binding data as specified in RFC
             * [5056](https://tools.ietf.org/html/rfc5056), RFC
             * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
             * binding data is returned in `data.`  The `data `is resized by the callee
             * using #GByteArray buffer management and will be freed when the data
             * is destroyed by g_byte_array_unref(). If `data `is %NULL, it will only
             * check whether TLS backend is able to fetch the data (e.g. whether type
             * is supported by the TLS backend). It does not guarantee that the data
             * will be available though.  That could happen if TLS connection does not
             * support `type `or the binding data is not available yet due to additional
             * negotiation or input required.
             */
            get_channel_binding_data(type: TlsChannelBindingType): [boolean, Uint8Array | null];
            /**
             * Returns the name of the current TLS ciphersuite, or %NULL if the
             * connection has not handshaked or has been closed. Beware that the TLS
             * backend may use any of multiple different naming conventions, because
             * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
             * are different from each other and different from the standard, IANA-
             * registered ciphersuite names. The ciphersuite name is intended to be
             * displayed to the user for informative purposes only, and parsing it
             * is not recommended.
             */
            get_ciphersuite_name(): string | null;
            /**
             * Gets the certificate database that `conn `uses to verify
             * peer certificates. See g_tls_connection_set_database().
             */
            get_database(): TlsDatabase | null;
            /**
             * Get the object that will be used to interact with the user. It will be used
             * for things like prompting the user for passwords. If %NULL is returned, then
             * no user interaction will occur for this connection.
             */
            get_interaction(): TlsInteraction | null;
            /**
             * Gets the name of the application-layer protocol negotiated during
             * the handshake.
             *
             * If the peer did not use the ALPN extension, or did not advertise a
             * protocol that matched one of conn's protocols, or the TLS backend
             * does not support ALPN, then this will be %NULL. See
             * g_tls_connection_set_advertised_protocols().
             */
            get_negotiated_protocol(): string | null;
            /**
             * Gets conn's peer's certificate after the handshake has completed
             * or failed. (It is not set during the emission of
             * #GTlsConnection::accept-certificate.)
             */
            get_peer_certificate(): TlsCertificate | null;
            /**
             * Gets the errors associated with validating conn's peer's
             * certificate, after the handshake has completed or failed. (It is
             * not set during the emission of #GTlsConnection::accept-certificate.)
             *
             * See #GTlsConnection:peer-certificate-errors for more information.
             */
            get_peer_certificate_errors(): TlsCertificateFlags;
            /**
             * Returns the current TLS protocol version, which may be
             * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
             * has been closed, or if the TLS backend has implemented a protocol version
             * that is not a recognized #GTlsProtocolVersion.
             */
            get_protocol_version(): TlsProtocolVersion;
            /**
             * Gets `conn `rehandshaking mode. See
             * g_tls_connection_set_rehandshake_mode() for details.
             */
            get_rehandshake_mode(): TlsRehandshakeMode;
            /**
             * Tests whether or not `conn `expects a proper TLS close notification
             * when the connection is closed. See
             * g_tls_connection_set_require_close_notify() for details.
             */
            get_require_close_notify(): boolean;
            /**
             * Gets whether `conn `uses the system certificate database to verify
             * peer certificates. See g_tls_connection_set_use_system_certdb().
             */
            get_use_system_certdb(): boolean;
            /**
             * Attempts a TLS handshake on `conn.`
             *
             * On the client side, it is never necessary to call this method;
             * although the connection needs to perform a handshake after
             * connecting (or after sending a "STARTTLS"-type command),
             * #GTlsConnection will handle this for you automatically when you try
             * to send or receive data on the connection. You can call
             * g_tls_connection_handshake() manually if you want to know whether
             * the initial handshake succeeded or failed (as opposed to just
             * immediately trying to use `conn `to read or write, in which case,
             * if it fails, it may not be possible to tell if it failed before or
             * after completing the handshake), but beware that servers may reject
             * client authentication after the handshake has completed, so a
             * successful handshake does not indicate the connection will be usable.
             *
             * Likewise, on the server side, although a handshake is necessary at
             * the beginning of the communication, you do not need to call this
             * function explicitly unless you want clearer error reporting.
             *
             * Previously, calling g_tls_connection_handshake() after the initial
             * handshake would trigger a rehandshake; however, this usage was
             * deprecated in GLib 2.60 because rehandshaking was removed from the
             * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
             * the initial handshake will no longer do anything.
             *
             * When using a #GTlsConnection created by #GSocketClient, the
             * #GSocketClient performs the initial handshake, so calling this
             * function manually is not recommended.
             *
             * #GTlsConnection::accept_certificate may be emitted during the
             * handshake.
             */
            handshake(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_tls_connection_handshake() for more information.
             */
            handshake_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_tls_connection_handshake() for more information.
             */
            handshake_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_tls_connection_handshake() for more information.
             */
            handshake_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS handshake operation. See
             * g_tls_connection_handshake() for more information.
             */
            handshake_finish(result: AsyncResult): boolean;
            /**
             * Sets the list of application-layer protocols to advertise that the
             * caller is willing to speak on this connection. The
             * Application-Layer Protocol Negotiation (ALPN) extension will be
             * used to negotiate a compatible protocol with the peer; use
             * g_tls_connection_get_negotiated_protocol() to find the negotiated
             * protocol after the handshake.  Specifying %NULL for the the value
             * of `protocols `will disable ALPN negotiation.
             *
             * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
             * for a list of registered protocol IDs.
             */
            set_advertised_protocols(protocols?: string[] | null): void;
            /**
             * This sets the certificate that `conn `will present to its peer
             * during the TLS handshake. For a #GTlsServerConnection, it is
             * mandatory to set this, and that will normally be done at construct
             * time.
             *
             * For a #GTlsClientConnection, this is optional. If a handshake fails
             * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
             * requires a certificate, and if you try connecting again, you should
             * call this method first. You can call
             * g_tls_client_connection_get_accepted_cas() on the failed connection
             * to get a list of Certificate Authorities that the server will
             * accept certificates from.
             *
             * (It is also possible that a server will allow the connection with
             * or without a certificate; in that case, if you don't provide a
             * certificate, you can tell that the server requested one by the fact
             * that g_tls_client_connection_get_accepted_cas() will return
             * non-%NULL.)
             */
            set_certificate(certificate: TlsCertificate): void;
            /**
             * Sets the certificate database that is used to verify peer certificates.
             * This is set to the default database by default. See
             * g_tls_backend_get_default_database(). If set to %NULL, then
             * peer certificate validation will always set the
             * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
             * #GTlsConnection::accept-certificate will always be emitted on
             * client-side connections, unless that bit is not set in
             * #GTlsClientConnection:validation-flags).
             *
             * There are nonintuitive security implications when using a non-default
             * database. See #GTlsConnection:database for details.
             */
            set_database(database?: TlsDatabase | null): void;
            /**
             * Set the object that will be used to interact with the user. It will be used
             * for things like prompting the user for passwords.
             *
             * The `interaction `argument will normally be a derived subclass of
             * #GTlsInteraction. %NULL can also be provided if no user interaction
             * should occur for this connection.
             */
            set_interaction(interaction?: TlsInteraction | null): void;
            /**
             * Since GLib 2.64, changing the rehandshake mode is no longer supported
             * and will have no effect. With TLS 1.3, rehandshaking has been removed from
             * the TLS protocol, replaced by separate post-handshake authentication and
             * rekey operations.
             */
            set_rehandshake_mode(mode: TlsRehandshakeMode): void;
            /**
             * Sets whether or not `conn `expects a proper TLS close notification
             * before the connection is closed. If this is %TRUE (the default),
             * then `conn `will expect to receive a TLS close notification from its
             * peer before the connection is closed, and will return a
             * %G_TLS_ERROR_EOF error if the connection is closed without proper
             * notification (since this may indicate a network error, or
             * man-in-the-middle attack).
             *
             * In some protocols, the application will know whether or not the
             * connection was closed cleanly based on application-level data
             * (because the application-level data includes a length field, or is
             * somehow self-delimiting); in this case, the close notify is
             * redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
             * in TLS 1.0 it is technically an error, but often done anyway.) You
             * can use g_tls_connection_set_require_close_notify() to tell conn
             * to allow an "unannounced" connection close, in which case the close
             * will show up as a 0-length read, as in a non-TLS
             * #GSocketConnection, and it is up to the application to check that
             * the data has been fully received.
             *
             * Note that this only affects the behavior when the peer closes the
             * connection; when the application calls g_io_stream_close() itself
             * on conn, this will send a close notification regardless of the
             * setting of this property. If you explicitly want to do an unclean
             * close, you can close conn's #GTlsConnection:base-io-stream rather
             * than closing `conn `itself, but note that this may only be done when no other
             * operations are pending on `conn `or the base I/O stream.
             */
            set_require_close_notify(require_close_notify: boolean): void;
            /**
             * Sets whether `conn `uses the system certificate database to verify
             * peer certificates. This is %TRUE by default. If set to %FALSE, then
             * peer certificate validation will always set the
             * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
             * #GTlsConnection::accept-certificate will always be emitted on
             * client-side connections, unless that bit is not set in
             * #GTlsClientConnection:validation-flags).
             */
            set_use_system_certdb(use_system_certdb: boolean): void;
            vfunc_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
            vfunc_get_binding_data(type: TlsChannelBindingType, data: Uint8Array | string): boolean;
            /**
             * Gets the name of the application-layer protocol negotiated during
             * the handshake.
             *
             * If the peer did not use the ALPN extension, or did not advertise a
             * protocol that matched one of conn's protocols, or the TLS backend
             * does not support ALPN, then this will be %NULL. See
             * g_tls_connection_set_advertised_protocols().
             */
            vfunc_get_negotiated_protocol(): string | null;
            /**
             * Attempts a TLS handshake on `conn.`
             *
             * On the client side, it is never necessary to call this method;
             * although the connection needs to perform a handshake after
             * connecting (or after sending a "STARTTLS"-type command),
             * #GTlsConnection will handle this for you automatically when you try
             * to send or receive data on the connection. You can call
             * g_tls_connection_handshake() manually if you want to know whether
             * the initial handshake succeeded or failed (as opposed to just
             * immediately trying to use `conn `to read or write, in which case,
             * if it fails, it may not be possible to tell if it failed before or
             * after completing the handshake), but beware that servers may reject
             * client authentication after the handshake has completed, so a
             * successful handshake does not indicate the connection will be usable.
             *
             * Likewise, on the server side, although a handshake is necessary at
             * the beginning of the communication, you do not need to call this
             * function explicitly unless you want clearer error reporting.
             *
             * Previously, calling g_tls_connection_handshake() after the initial
             * handshake would trigger a rehandshake; however, this usage was
             * deprecated in GLib 2.60 because rehandshaking was removed from the
             * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
             * the initial handshake will no longer do anything.
             *
             * When using a #GTlsConnection created by #GSocketClient, the
             * #GSocketClient performs the initial handshake, so calling this
             * function manually is not recommended.
             *
             * #GTlsConnection::accept_certificate may be emitted during the
             * handshake.
             */
            vfunc_handshake(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_tls_connection_handshake() for more information.
             */
            vfunc_handshake_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_tls_connection_handshake() for more information.
             */
            vfunc_handshake_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_tls_connection_handshake() for more information.
             */
            vfunc_handshake_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS handshake operation. See
             * g_tls_connection_handshake() for more information.
             */
            vfunc_handshake_finish(result: AsyncResult): boolean;
        }
        export module TlsDatabase {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export abstract class TlsDatabase extends GObject.Object {
            static $gtype: GObject.GType<TlsDatabase>;

            constructor(properties?: Partial<TlsDatabase.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TlsDatabase.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Create a handle string for the certificate. The database will only be able
             * to create a handle for certificates that originate from the database. In
             * cases where the database cannot create a handle for a certificate, %NULL
             * will be returned.
             *
             * This handle should be stable across various instances of the application,
             * and between applications. If a certificate is modified in the database,
             * then it is not guaranteed that this handle will continue to point to it.
             */
            create_certificate_handle(certificate: TlsCertificate): string | null;
            /**
             * Look up a certificate by its handle.
             *
             * The handle should have been created by calling
             * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
             * the same TLS backend. The handle is designed to remain valid across
             * instantiations of the database.
             *
             * If the handle is no longer valid, or does not point to a certificate in
             * this database, then %NULL will be returned.
             *
             * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
             * the lookup operation asynchronously.
             */
            lookup_certificate_for_handle(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): TlsCertificate | null;
            /**
             * Asynchronously look up a certificate by its handle in the database. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             */
            lookup_certificate_for_handle_async(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificate>;
            /**
             * Asynchronously look up a certificate by its handle in the database. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             */
            lookup_certificate_for_handle_async(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously look up a certificate by its handle in the database. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             */
            lookup_certificate_for_handle_async(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificate> | void;
            /**
             * Finish an asynchronous lookup of a certificate by its handle. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             *
             * If the handle is no longer valid, or does not point to a certificate in
             * this database, then %NULL will be returned.
             */
            lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate;
            /**
             * Look up the issuer of `certificate `in the database. The
             * #GTlsCertificate:issuer property of `certificate `is not modified, and
             * the two certificates are not hooked into a chain.
             *
             * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
             * to perform the lookup operation asynchronously.
             *
             * Beware this function cannot be used to build certification paths. The
             * issuer certificate returned by this function may not be the same as
             * the certificate that would actually be used to construct a valid
             * certification path during certificate verification.
             * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
             * why an issuer certificate cannot be naively assumed to be part of the
             * the certification path (though GLib's TLS backends may not follow the
             * path building strategies outlined in this RFC). Due to the complexity
             * of certification path building, GLib does not provide any way to know
             * which certification path will actually be used when verifying a TLS
             * certificate. Accordingly, this function cannot be used to make
             * security-related decisions. Only GLib itself should make security
             * decisions about TLS certificates.
             */
            lookup_certificate_issuer(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): TlsCertificate;
            /**
             * Asynchronously look up the issuer of `certificate `in the database. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            lookup_certificate_issuer_async(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificate>;
            /**
             * Asynchronously look up the issuer of `certificate `in the database. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            lookup_certificate_issuer_async(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously look up the issuer of `certificate `in the database. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            lookup_certificate_issuer_async(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificate> | void;
            /**
             * Finish an asynchronous lookup issuer operation. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate;
            /**
             * Look up certificates issued by this issuer in the database.
             *
             * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
             * the lookup operation asynchronously.
             */
            lookup_certificates_issued_by(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): TlsCertificate[];
            /**
             * Asynchronously look up certificates issued by this issuer in the database. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             *
             * The database may choose to hold a reference to the issuer byte array for the duration
             * of of this asynchronous operation. The byte array should not be modified during
             * this time.
             */
            lookup_certificates_issued_by_async(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificate[]>;
            /**
             * Asynchronously look up certificates issued by this issuer in the database. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             *
             * The database may choose to hold a reference to the issuer byte array for the duration
             * of of this asynchronous operation. The byte array should not be modified during
             * this time.
             */
            lookup_certificates_issued_by_async(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously look up certificates issued by this issuer in the database. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             *
             * The database may choose to hold a reference to the issuer byte array for the duration
             * of of this asynchronous operation. The byte array should not be modified during
             * this time.
             */
            lookup_certificates_issued_by_async(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificate[]> | void;
            /**
             * Finish an asynchronous lookup of certificates. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             */
            lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[];
            /**
             * Determines the validity of a certificate chain, outside the context
             * of a TLS session.
             *
             * `chain `is a chain of #GTlsCertificate objects each pointing to the next
             * certificate in the chain by its #GTlsCertificate:issuer property.
             *
             * `purpose `describes the purpose (or usage) for which the certificate
             * is being used. Typically `purpose `will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
             * which means that the certificate is being used to authenticate a server
             * (and we are acting as the client).
             *
             * The `identity `is used to ensure the server certificate is valid for
             * the expected peer identity. If the identity does not match the
             * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
             * return value. If `identity `is %NULL, that bit will never be set in
             * the return value. The peer identity may also be used to check for
             * pinned certificates (trust exceptions) in the database. These may
             * override the normal verification process on a host-by-host basis.
             *
             * Currently there are no flags, and %G_TLS_DATABASE_VERIFY_NONE should be
             * used.
             *
             * If `chain `is found to be valid, then the return value will be 0. If
             * `chain `is found to be invalid, then the return value will indicate at
             * least one problem found. If the function is unable to determine
             * whether `chain `is valid (for example, because `cancellable `is
             * triggered before it completes) then the return value will be
             * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error `will be set accordingly.
             * `error `is not set when `chain `is successfully analyzed but found to
             * be invalid.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * error will be set in the return value, but it does not guarantee
             * that all possible errors will be set. Accordingly, you may not safely
             * decide to ignore any particular type of error. For example, it would
             * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
             * expired certificates, because this could potentially be the only
             * error flag set even if other problems exist with the certificate.
             *
             * Prior to GLib 2.48, GLib's default TLS backend modified `chain `to
             * represent the certification path built by #GTlsDatabase during
             * certificate verification by adjusting the #GTlsCertificate:issuer
             * property of each certificate in `chain.` Since GLib 2.48, this no
             * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
             * represent the actual certification path used during certificate
             * verification.
             *
             * Because TLS session context is not used, #GTlsDatabase may not
             * perform as many checks on the certificates as #GTlsConnection would.
             * For example, certificate constraints may not be honored, and
             * revocation checks may not be performed. The best way to verify TLS
             * certificates used by a TLS connection is to let #GTlsConnection
             * handle the verification.
             *
             * The TLS backend may attempt to look up and add missing certificates
             * to the chain. This may involve HTTP requests to download missing
             * certificates.
             *
             * This function can block. Use g_tls_database_verify_chain_async() to
             * perform the verification operation asynchronously.
             */
            verify_chain(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable?: Cancellable | null
            ): TlsCertificateFlags;
            /**
             * Asynchronously determines the validity of a certificate chain after
             * looking up and adding any missing certificates to the chain. See
             * g_tls_database_verify_chain() for more information.
             */
            verify_chain_async(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificateFlags>;
            /**
             * Asynchronously determines the validity of a certificate chain after
             * looking up and adding any missing certificates to the chain. See
             * g_tls_database_verify_chain() for more information.
             */
            verify_chain_async(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously determines the validity of a certificate chain after
             * looking up and adding any missing certificates to the chain. See
             * g_tls_database_verify_chain() for more information.
             */
            verify_chain_async(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificateFlags> | void;
            /**
             * Finish an asynchronous verify chain operation. See
             * g_tls_database_verify_chain() for more information.
             *
             * If `chain `is found to be valid, then the return value will be 0. If
             * `chain `is found to be invalid, then the return value will indicate
             * the problems found. If the function is unable to determine whether
             * `chain `is valid or not (eg, because `cancellable `is triggered
             * before it completes) then the return value will be
             * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error `will be set
             * accordingly. `error `is not set when `chain `is successfully analyzed
             * but found to be invalid.
             */
            verify_chain_finish(result: AsyncResult): TlsCertificateFlags;
            /**
             * Create a handle string for the certificate. The database will only be able
             * to create a handle for certificates that originate from the database. In
             * cases where the database cannot create a handle for a certificate, %NULL
             * will be returned.
             *
             * This handle should be stable across various instances of the application,
             * and between applications. If a certificate is modified in the database,
             * then it is not guaranteed that this handle will continue to point to it.
             */
            vfunc_create_certificate_handle(certificate: TlsCertificate): string | null;
            /**
             * Look up a certificate by its handle.
             *
             * The handle should have been created by calling
             * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
             * the same TLS backend. The handle is designed to remain valid across
             * instantiations of the database.
             *
             * If the handle is no longer valid, or does not point to a certificate in
             * this database, then %NULL will be returned.
             *
             * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
             * the lookup operation asynchronously.
             */
            vfunc_lookup_certificate_for_handle(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): TlsCertificate | null;
            /**
             * Asynchronously look up a certificate by its handle in the database. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             */
            vfunc_lookup_certificate_for_handle_async(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificate>;
            /**
             * Asynchronously look up a certificate by its handle in the database. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             */
            vfunc_lookup_certificate_for_handle_async(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously look up a certificate by its handle in the database. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             */
            vfunc_lookup_certificate_for_handle_async(
                handle: string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificate> | void;
            /**
             * Finish an asynchronous lookup of a certificate by its handle. See
             * g_tls_database_lookup_certificate_for_handle() for more information.
             *
             * If the handle is no longer valid, or does not point to a certificate in
             * this database, then %NULL will be returned.
             */
            vfunc_lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate;
            /**
             * Look up the issuer of `certificate `in the database. The
             * #GTlsCertificate:issuer property of `certificate `is not modified, and
             * the two certificates are not hooked into a chain.
             *
             * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
             * to perform the lookup operation asynchronously.
             *
             * Beware this function cannot be used to build certification paths. The
             * issuer certificate returned by this function may not be the same as
             * the certificate that would actually be used to construct a valid
             * certification path during certificate verification.
             * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
             * why an issuer certificate cannot be naively assumed to be part of the
             * the certification path (though GLib's TLS backends may not follow the
             * path building strategies outlined in this RFC). Due to the complexity
             * of certification path building, GLib does not provide any way to know
             * which certification path will actually be used when verifying a TLS
             * certificate. Accordingly, this function cannot be used to make
             * security-related decisions. Only GLib itself should make security
             * decisions about TLS certificates.
             */
            vfunc_lookup_certificate_issuer(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): TlsCertificate;
            /**
             * Asynchronously look up the issuer of `certificate `in the database. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            vfunc_lookup_certificate_issuer_async(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificate>;
            /**
             * Asynchronously look up the issuer of `certificate `in the database. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            vfunc_lookup_certificate_issuer_async(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously look up the issuer of `certificate `in the database. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            vfunc_lookup_certificate_issuer_async(
                certificate: TlsCertificate,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificate> | void;
            /**
             * Finish an asynchronous lookup issuer operation. See
             * g_tls_database_lookup_certificate_issuer() for more information.
             */
            vfunc_lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate;
            /**
             * Look up certificates issued by this issuer in the database.
             *
             * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
             * the lookup operation asynchronously.
             */
            vfunc_lookup_certificates_issued_by(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): TlsCertificate[];
            /**
             * Asynchronously look up certificates issued by this issuer in the database. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             *
             * The database may choose to hold a reference to the issuer byte array for the duration
             * of of this asynchronous operation. The byte array should not be modified during
             * this time.
             */
            vfunc_lookup_certificates_issued_by_async(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificate[]>;
            /**
             * Asynchronously look up certificates issued by this issuer in the database. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             *
             * The database may choose to hold a reference to the issuer byte array for the duration
             * of of this asynchronous operation. The byte array should not be modified during
             * this time.
             */
            vfunc_lookup_certificates_issued_by_async(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously look up certificates issued by this issuer in the database. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             *
             * The database may choose to hold a reference to the issuer byte array for the duration
             * of of this asynchronous operation. The byte array should not be modified during
             * this time.
             */
            vfunc_lookup_certificates_issued_by_async(
                issuer_raw_dn: Uint8Array | string,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseLookupFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificate[]> | void;
            /**
             * Finish an asynchronous lookup of certificates. See
             * g_tls_database_lookup_certificates_issued_by() for more information.
             */
            vfunc_lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[];
            /**
             * Determines the validity of a certificate chain, outside the context
             * of a TLS session.
             *
             * `chain `is a chain of #GTlsCertificate objects each pointing to the next
             * certificate in the chain by its #GTlsCertificate:issuer property.
             *
             * `purpose `describes the purpose (or usage) for which the certificate
             * is being used. Typically `purpose `will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
             * which means that the certificate is being used to authenticate a server
             * (and we are acting as the client).
             *
             * The `identity `is used to ensure the server certificate is valid for
             * the expected peer identity. If the identity does not match the
             * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
             * return value. If `identity `is %NULL, that bit will never be set in
             * the return value. The peer identity may also be used to check for
             * pinned certificates (trust exceptions) in the database. These may
             * override the normal verification process on a host-by-host basis.
             *
             * Currently there are no flags, and %G_TLS_DATABASE_VERIFY_NONE should be
             * used.
             *
             * If `chain `is found to be valid, then the return value will be 0. If
             * `chain `is found to be invalid, then the return value will indicate at
             * least one problem found. If the function is unable to determine
             * whether `chain `is valid (for example, because `cancellable `is
             * triggered before it completes) then the return value will be
             * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error `will be set accordingly.
             * `error `is not set when `chain `is successfully analyzed but found to
             * be invalid.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * error will be set in the return value, but it does not guarantee
             * that all possible errors will be set. Accordingly, you may not safely
             * decide to ignore any particular type of error. For example, it would
             * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
             * expired certificates, because this could potentially be the only
             * error flag set even if other problems exist with the certificate.
             *
             * Prior to GLib 2.48, GLib's default TLS backend modified `chain `to
             * represent the certification path built by #GTlsDatabase during
             * certificate verification by adjusting the #GTlsCertificate:issuer
             * property of each certificate in `chain.` Since GLib 2.48, this no
             * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
             * represent the actual certification path used during certificate
             * verification.
             *
             * Because TLS session context is not used, #GTlsDatabase may not
             * perform as many checks on the certificates as #GTlsConnection would.
             * For example, certificate constraints may not be honored, and
             * revocation checks may not be performed. The best way to verify TLS
             * certificates used by a TLS connection is to let #GTlsConnection
             * handle the verification.
             *
             * The TLS backend may attempt to look up and add missing certificates
             * to the chain. This may involve HTTP requests to download missing
             * certificates.
             *
             * This function can block. Use g_tls_database_verify_chain_async() to
             * perform the verification operation asynchronously.
             */
            vfunc_verify_chain(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable?: Cancellable | null
            ): TlsCertificateFlags;
            /**
             * Asynchronously determines the validity of a certificate chain after
             * looking up and adding any missing certificates to the chain. See
             * g_tls_database_verify_chain() for more information.
             */
            vfunc_verify_chain_async(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsCertificateFlags>;
            /**
             * Asynchronously determines the validity of a certificate chain after
             * looking up and adding any missing certificates to the chain. See
             * g_tls_database_verify_chain() for more information.
             */
            vfunc_verify_chain_async(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously determines the validity of a certificate chain after
             * looking up and adding any missing certificates to the chain. See
             * g_tls_database_verify_chain() for more information.
             */
            vfunc_verify_chain_async(
                chain: TlsCertificate,
                purpose: string,
                identity: SocketConnectable | null,
                interaction: TlsInteraction | null,
                flags: TlsDatabaseVerifyFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsCertificateFlags> | void;
            /**
             * Finish an asynchronous verify chain operation. See
             * g_tls_database_verify_chain() for more information.
             *
             * If `chain `is found to be valid, then the return value will be 0. If
             * `chain `is found to be invalid, then the return value will indicate
             * the problems found. If the function is unable to determine whether
             * `chain `is valid or not (eg, because `cancellable `is triggered
             * before it completes) then the return value will be
             * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error `will be set
             * accordingly. `error `is not set when `chain `is successfully analyzed
             * but found to be invalid.
             */
            vfunc_verify_chain_finish(result: AsyncResult): TlsCertificateFlags;
        }
        export module TlsInteraction {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class TlsInteraction extends GObject.Object {
            static $gtype: GObject.GType<TlsInteraction>;

            constructor(properties?: Partial<TlsInteraction.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TlsInteraction.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Run synchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             */
            ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
            /**
             * Run asynchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             *
             * Certain implementations may not support immediate cancellation.
             */
            ask_password_async(password: TlsPassword, cancellable?: Cancellable | null): Promise<TlsInteractionResult>;
            /**
             * Run asynchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             *
             * Certain implementations may not support immediate cancellation.
             */
            ask_password_async(
                password: TlsPassword,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Run asynchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             *
             * Certain implementations may not support immediate cancellation.
             */
            ask_password_async(
                password: TlsPassword,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsInteractionResult> | void;
            /**
             * Complete an ask password user interaction request. This should be once
             * the g_tls_interaction_ask_password_async() completion callback is called.
             *
             * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
             * to g_tls_interaction_ask_password() will have its password filled in.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code.
             */
            ask_password_finish(result: AsyncResult): TlsInteractionResult;
            /**
             * Invoke the interaction to ask the user for a password. It invokes this
             * interaction in the main loop, specifically the #GMainContext returned by
             * g_main_context_get_thread_default() when the interaction is created. This
             * is called by called by #GTlsConnection or #GTlsDatabase to ask the user
             * for a password.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * The implementation can either be a synchronous (eg: modal dialog) or an
             * asynchronous one (eg: modeless dialog). This function will take care of
             * calling which ever one correctly.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             */
            invoke_ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
            /**
             * Invoke the interaction to ask the user to choose a certificate to
             * use with the connection. It invokes this interaction in the main
             * loop, specifically the #GMainContext returned by
             * g_main_context_get_thread_default() when the interaction is
             * created. This is called by called by #GTlsConnection when the peer
             * requests a certificate during the handshake.
             *
             * Derived subclasses usually implement a certificate selector,
             * although they may also choose to provide a certificate from
             * elsewhere. Alternatively the user may abort this certificate
             * request, which may or may not abort the TLS connection.
             *
             * The implementation can either be a synchronous (eg: modal dialog) or an
             * asynchronous one (eg: modeless dialog). This function will take care of
             * calling which ever one correctly.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             */
            invoke_request_certificate(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null
            ): TlsInteractionResult;
            /**
             * Run synchronous interaction to ask the user to choose a certificate to use
             * with the connection. In general, g_tls_interaction_invoke_request_certificate()
             * should be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. Alternatively the user may
             * abort this certificate request, which will usually abort the TLS connection.
             *
             * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
             * passed to g_tls_interaction_request_certificate() will have had its
             * #GTlsConnection:certificate filled in.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             */
            request_certificate(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null
            ): TlsInteractionResult;
            /**
             * Run asynchronous interaction to ask the user for a certificate to use with
             * the connection. In general, g_tls_interaction_invoke_request_certificate() should
             * be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. `callback `will be called
             * when the operation completes. Alternatively the user may abort this certificate
             * request, which will usually abort the TLS connection.
             */
            request_certificate_async(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsInteractionResult>;
            /**
             * Run asynchronous interaction to ask the user for a certificate to use with
             * the connection. In general, g_tls_interaction_invoke_request_certificate() should
             * be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. `callback `will be called
             * when the operation completes. Alternatively the user may abort this certificate
             * request, which will usually abort the TLS connection.
             */
            request_certificate_async(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Run asynchronous interaction to ask the user for a certificate to use with
             * the connection. In general, g_tls_interaction_invoke_request_certificate() should
             * be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. `callback `will be called
             * when the operation completes. Alternatively the user may abort this certificate
             * request, which will usually abort the TLS connection.
             */
            request_certificate_async(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsInteractionResult> | void;
            /**
             * Complete a request certificate user interaction request. This should be once
             * the g_tls_interaction_request_certificate_async() completion callback is called.
             *
             * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
             * passed to g_tls_interaction_request_certificate_async() will have had its
             * #GTlsConnection:certificate filled in.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code.
             */
            request_certificate_finish(result: AsyncResult): TlsInteractionResult;
            /**
             * Run synchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             */
            vfunc_ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
            /**
             * Run asynchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             *
             * Certain implementations may not support immediate cancellation.
             */
            vfunc_ask_password_async(
                password: TlsPassword,
                cancellable?: Cancellable | null
            ): Promise<TlsInteractionResult>;
            /**
             * Run asynchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             *
             * Certain implementations may not support immediate cancellation.
             */
            vfunc_ask_password_async(
                password: TlsPassword,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Run asynchronous interaction to ask the user for a password. In general,
             * g_tls_interaction_invoke_ask_password() should be used instead of this
             * function.
             *
             * Derived subclasses usually implement a password prompt, although they may
             * also choose to provide a password from elsewhere. The `password `value will
             * be filled in and then `callback `will be called. Alternatively the user may
             * abort this password request, which will usually abort the TLS connection.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             *
             * Certain implementations may not support immediate cancellation.
             */
            vfunc_ask_password_async(
                password: TlsPassword,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsInteractionResult> | void;
            /**
             * Complete an ask password user interaction request. This should be once
             * the g_tls_interaction_ask_password_async() completion callback is called.
             *
             * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
             * to g_tls_interaction_ask_password() will have its password filled in.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code.
             */
            vfunc_ask_password_finish(result: AsyncResult): TlsInteractionResult;
            /**
             * Run synchronous interaction to ask the user to choose a certificate to use
             * with the connection. In general, g_tls_interaction_invoke_request_certificate()
             * should be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. Alternatively the user may
             * abort this certificate request, which will usually abort the TLS connection.
             *
             * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
             * passed to g_tls_interaction_request_certificate() will have had its
             * #GTlsConnection:certificate filled in.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
             * not support immediate cancellation.
             */
            vfunc_request_certificate(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null
            ): TlsInteractionResult;
            /**
             * Run asynchronous interaction to ask the user for a certificate to use with
             * the connection. In general, g_tls_interaction_invoke_request_certificate() should
             * be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. `callback `will be called
             * when the operation completes. Alternatively the user may abort this certificate
             * request, which will usually abort the TLS connection.
             */
            vfunc_request_certificate_async(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null
            ): Promise<TlsInteractionResult>;
            /**
             * Run asynchronous interaction to ask the user for a certificate to use with
             * the connection. In general, g_tls_interaction_invoke_request_certificate() should
             * be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. `callback `will be called
             * when the operation completes. Alternatively the user may abort this certificate
             * request, which will usually abort the TLS connection.
             */
            vfunc_request_certificate_async(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Run asynchronous interaction to ask the user for a certificate to use with
             * the connection. In general, g_tls_interaction_invoke_request_certificate() should
             * be used instead of this function.
             *
             * Derived subclasses usually implement a certificate selector, although they may
             * also choose to provide a certificate from elsewhere. `callback `will be called
             * when the operation completes. Alternatively the user may abort this certificate
             * request, which will usually abort the TLS connection.
             */
            vfunc_request_certificate_async(
                connection: TlsConnection,
                flags: TlsCertificateRequestFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<TlsInteractionResult> | void;
            /**
             * Complete a request certificate user interaction request. This should be once
             * the g_tls_interaction_request_certificate_async() completion callback is called.
             *
             * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
             * passed to g_tls_interaction_request_certificate_async() will have had its
             * #GTlsConnection:certificate filled in.
             *
             * If the interaction is cancelled by the cancellation object, or by the
             * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
             * contains a %G_IO_ERROR_CANCELLED error code.
             */
            vfunc_request_certificate_finish(result: AsyncResult): TlsInteractionResult;
        }
        export module TlsPassword {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                description: string;
                flags: TlsPasswordFlags;
                warning: string;
            }
        }
        export class TlsPassword extends GObject.Object {
            static $gtype: GObject.GType<TlsPassword>;

            constructor(properties?: Partial<TlsPassword.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<TlsPassword.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get description(): string;
            set description(val: string);
            get flags(): TlsPasswordFlags;
            set flags(val: TlsPasswordFlags);
            get warning(): string;
            set warning(val: string);

            // Constructors

            static ["new"](flags: TlsPasswordFlags, description: string): TlsPassword;

            // Members

            /**
             * Get a description string about what the password will be used for.
             */
            get_description(): string;
            /**
             * Get flags about the password.
             */
            get_flags(): TlsPasswordFlags;
            /**
             * Get the password value. If `length `is not %NULL then it will be
             * filled in with the length of the password value. (Note that the
             * password value is not nul-terminated, so you can only pass %NULL
             * for `length `in contexts where you know the password will have a
             * certain fixed length.)
             */
            get_value(): Uint8Array;
            /**
             * Get a user readable translated warning. Usually this warning is a
             * representation of the password flags returned from
             * g_tls_password_get_flags().
             */
            get_warning(): string;
            /**
             * Set a description string about what the password will be used for.
             */
            set_description(description: string): void;
            /**
             * Set flags about the password.
             */
            set_flags(flags: TlsPasswordFlags): void;
            /**
             * Set the value for this password. The `value `will be copied by the password
             * object.
             *
             * Specify the length, for a non-nul-terminated password. Pass -1 as
             * `length `if using a nul-terminated password, and `length `will be
             * calculated automatically. (Note that the terminating nul is not
             * considered part of the password in this case.)
             */
            set_value(value: Uint8Array | string): void;
            /**
             * Provide the value for this password.
             *
             * The `value `will be owned by the password object, and later freed using
             * the `destroy `function callback.
             *
             * Specify the length, for a non-nul-terminated password. Pass -1 as
             * `length `if using a nul-terminated password, and `length `will be
             * calculated automatically. (Note that the terminating nul is not
             * considered part of the password in this case.)
             */
            set_value_full(value: Uint8Array | string, destroy?: GLib.DestroyNotify | null): void;
            /**
             * Set a user readable translated warning. Usually this warning is a
             * representation of the password flags returned from
             * g_tls_password_get_flags().
             */
            set_warning(warning: string): void;
            vfunc_get_default_warning(): string;
            /**
             * Get the password value. If `length `is not %NULL then it will be
             * filled in with the length of the password value. (Note that the
             * password value is not nul-terminated, so you can only pass %NULL
             * for `length `in contexts where you know the password will have a
             * certain fixed length.)
             */
            vfunc_get_value(): Uint8Array;
            /**
             * Provide the value for this password.
             *
             * The `value `will be owned by the password object, and later freed using
             * the `destroy `function callback.
             *
             * Specify the length, for a non-nul-terminated password. Pass -1 as
             * `length `if using a nul-terminated password, and `length `will be
             * calculated automatically. (Note that the terminating nul is not
             * considered part of the password in this case.)
             */
            vfunc_set_value(value: Uint8Array | string, destroy?: GLib.DestroyNotify | null): void;
        }
        export module UnixConnection {
            export interface ConstructorProperties extends SocketConnection.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class UnixConnection extends SocketConnection {
            static $gtype: GObject.GType<UnixConnection>;

            constructor(properties?: Partial<UnixConnection.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixConnection.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Receives credentials from the sending end of the connection.  The
             * sending end has to call g_unix_connection_send_credentials() (or
             * similar) for this to work.
             *
             * As well as reading the credentials this also reads (and discards) a
             * single byte from the stream, as this is required for credentials
             * passing to work on some implementations.
             *
             * This method can be expected to be available on the following platforms:
             *
             * - Linux since GLib 2.26
             * - FreeBSD since GLib 2.26
             * - GNU/kFreeBSD since GLib 2.36
             * - Solaris, Illumos and OpenSolaris since GLib 2.40
             * - GNU/Hurd since GLib 2.40
             *
             * Other ways to exchange credentials with a foreign peer includes the
             * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
             */
            receive_credentials(cancellable?: Cancellable | null): Credentials;
            /**
             * Asynchronously receive credentials.
             *
             * For more details, see g_unix_connection_receive_credentials() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_unix_connection_receive_credentials_finish() to get the result of the operation.
             */
            receive_credentials_async(cancellable?: Cancellable | null): Promise<Credentials>;
            /**
             * Asynchronously receive credentials.
             *
             * For more details, see g_unix_connection_receive_credentials() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_unix_connection_receive_credentials_finish() to get the result of the operation.
             */
            receive_credentials_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously receive credentials.
             *
             * For more details, see g_unix_connection_receive_credentials() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_unix_connection_receive_credentials_finish() to get the result of the operation.
             */
            receive_credentials_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<Credentials> | void;
            /**
             * Finishes an asynchronous receive credentials operation started with
             * g_unix_connection_receive_credentials_async().
             */
            receive_credentials_finish(result: AsyncResult): Credentials;
            /**
             * Receives a file descriptor from the sending end of the connection.
             * The sending end has to call g_unix_connection_send_fd() for this
             * to work.
             *
             * As well as reading the fd this also reads a single byte from the
             * stream, as this is required for fd passing to work on some
             * implementations.
             */
            receive_fd(cancellable?: Cancellable | null): number;
            /**
             * Passes the credentials of the current user the receiving side
             * of the connection. The receiving end has to call
             * g_unix_connection_receive_credentials() (or similar) to accept the
             * credentials.
             *
             * As well as sending the credentials this also writes a single NUL
             * byte to the stream, as this is required for credentials passing to
             * work on some implementations.
             *
             * This method can be expected to be available on the following platforms:
             *
             * - Linux since GLib 2.26
             * - FreeBSD since GLib 2.26
             * - GNU/kFreeBSD since GLib 2.36
             * - Solaris, Illumos and OpenSolaris since GLib 2.40
             * - GNU/Hurd since GLib 2.40
             *
             * Other ways to exchange credentials with a foreign peer includes the
             * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
             */
            send_credentials(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously send credentials.
             *
             * For more details, see g_unix_connection_send_credentials() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_unix_connection_send_credentials_finish() to get the result of the operation.
             */
            send_credentials_async(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously send credentials.
             *
             * For more details, see g_unix_connection_send_credentials() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_unix_connection_send_credentials_finish() to get the result of the operation.
             */
            send_credentials_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously send credentials.
             *
             * For more details, see g_unix_connection_send_credentials() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_unix_connection_send_credentials_finish() to get the result of the operation.
             */
            send_credentials_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous send credentials operation started with
             * g_unix_connection_send_credentials_async().
             */
            send_credentials_finish(result: AsyncResult): boolean;
            /**
             * Passes a file descriptor to the receiving side of the
             * connection. The receiving end has to call g_unix_connection_receive_fd()
             * to accept the file descriptor.
             *
             * As well as sending the fd this also writes a single byte to the
             * stream, as this is required for fd passing to work on some
             * implementations.
             */
            send_fd(fd: number, cancellable?: Cancellable | null): boolean;
        }
        export module UnixCredentialsMessage {
            export interface ConstructorProperties extends SocketControlMessage.ConstructorProperties {
                [key: string]: any;
                credentials: Credentials;
            }
        }
        export class UnixCredentialsMessage extends SocketControlMessage {
            static $gtype: GObject.GType<UnixCredentialsMessage>;

            constructor(properties?: Partial<UnixCredentialsMessage.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixCredentialsMessage.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get credentials(): Credentials;

            // Constructors

            static ["new"](): UnixCredentialsMessage;
            static new_with_credentials(credentials: Credentials): UnixCredentialsMessage;

            // Members

            /**
             * Gets the credentials stored in `message.`
             */
            get_credentials(): Credentials;
            /**
             * Checks if passing #GCredentials on a #GSocket is supported on this platform.
             */
            static is_supported(): boolean;
        }
        export module UnixFDList {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class UnixFDList extends GObject.Object {
            static $gtype: GObject.GType<UnixFDList>;

            constructor(properties?: Partial<UnixFDList.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixFDList.ConstructorProperties>, ...args: any[]): void;

            // Constructors

            static ["new"](): UnixFDList;
            static new_from_array(fds: number[]): UnixFDList;

            // Members

            /**
             * Adds a file descriptor to `list.`
             *
             * The file descriptor is duplicated using dup(). You keep your copy
             * of the descriptor and the copy contained in `list `will be closed
             * when `list `is finalized.
             *
             * A possible cause of failure is exceeding the per-process or
             * system-wide file descriptor limit.
             *
             * The index of the file descriptor in the list is returned.  If you use
             * this index with g_unix_fd_list_get() then you will receive back a
             * duplicated copy of the same file descriptor.
             */
            append(fd: number): number;
            /**
             * Gets a file descriptor out of `list.`
             *
             * `index_ `specifies the index of the file descriptor to get.  It is a
             * programmer error for `index_ `to be out of range; see
             * g_unix_fd_list_get_length().
             *
             * The file descriptor is duplicated using dup() and set as
             * close-on-exec before being returned.  You must call close() on it
             * when you are done.
             *
             * A possible cause of failure is exceeding the per-process or
             * system-wide file descriptor limit.
             */
            get(index_: number): number;
            /**
             * Gets the length of `list `(ie: the number of file descriptors
             * contained within).
             */
            get_length(): number;
            /**
             * Returns the array of file descriptors that is contained in this
             * object.
             *
             * After this call, the descriptors remain the property of `list.`  The
             * caller must not close them and must not free the array.  The array is
             * valid only until `list `is changed in any way.
             *
             * If `length `is non-%NULL then it is set to the number of file
             * descriptors in the returned array. The returned array is also
             * terminated with -1.
             *
             * This function never returns %NULL. In case there are no file
             * descriptors contained in list, an empty array is returned.
             */
            peek_fds(): number[];
            /**
             * Returns the array of file descriptors that is contained in this
             * object.
             *
             * After this call, the descriptors are no longer contained in
             * `list.` Further calls will return an empty list (unless more
             * descriptors have been added).
             *
             * The return result of this function must be freed with g_free().
             * The caller is also responsible for closing all of the file
             * descriptors.  The file descriptors in the array are set to
             * close-on-exec.
             *
             * If `length `is non-%NULL then it is set to the number of file
             * descriptors in the returned array. The returned array is also
             * terminated with -1.
             *
             * This function never returns %NULL. In case there are no file
             * descriptors contained in list, an empty array is returned.
             */
            steal_fds(): number[];
        }
        export module UnixFDMessage {
            export interface ConstructorProperties extends SocketControlMessage.ConstructorProperties {
                [key: string]: any;
                fd_list: UnixFDList;
                fdList: UnixFDList;
            }
        }
        export class UnixFDMessage extends SocketControlMessage {
            static $gtype: GObject.GType<UnixFDMessage>;

            constructor(properties?: Partial<UnixFDMessage.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixFDMessage.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get fd_list(): UnixFDList;
            get fdList(): UnixFDList;

            // Constructors

            static ["new"](): UnixFDMessage;
            static new_with_fd_list(fd_list: UnixFDList): UnixFDMessage;

            // Members

            /**
             * Adds a file descriptor to `message.`
             *
             * The file descriptor is duplicated using dup(). You keep your copy
             * of the descriptor and the copy contained in `message `will be closed
             * when `message `is finalized.
             *
             * A possible cause of failure is exceeding the per-process or
             * system-wide file descriptor limit.
             */
            append_fd(fd: number): boolean;
            /**
             * Gets the #GUnixFDList contained in `message.`  This function does not
             * return a reference to the caller, but the returned list is valid for
             * the lifetime of `message.`
             */
            get_fd_list(): UnixFDList;
            /**
             * Returns the array of file descriptors that is contained in this
             * object.
             *
             * After this call, the descriptors are no longer contained in
             * `message.` Further calls will return an empty list (unless more
             * descriptors have been added).
             *
             * The return result of this function must be freed with g_free().
             * The caller is also responsible for closing all of the file
             * descriptors.
             *
             * If `length `is non-%NULL then it is set to the number of file
             * descriptors in the returned array. The returned array is also
             * terminated with -1.
             *
             * This function never returns %NULL. In case there are no file
             * descriptors contained in message, an empty array is returned.
             */
            steal_fds(): number[];
        }
        export module UnixInputStream {
            export interface ConstructorProperties extends InputStream.ConstructorProperties {
                [key: string]: any;
                close_fd: boolean;
                closeFd: boolean;
                fd: number;
            }
        }
        export class UnixInputStream extends InputStream implements FileDescriptorBased, PollableInputStream {
            static $gtype: GObject.GType<UnixInputStream>;

            constructor(properties?: Partial<UnixInputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixInputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get close_fd(): boolean;
            set close_fd(val: boolean);
            get closeFd(): boolean;
            set closeFd(val: boolean);
            get fd(): number;

            // Constructors

            static ["new"](fd: number, close_fd: boolean): UnixInputStream;

            // Members

            /**
             * Returns whether the file descriptor of `stream `will be
             * closed when the stream is closed.
             */
            get_close_fd(): boolean;
            /**
             * Return the UNIX file descriptor that the stream reads from.
             */
            get_fd(): number;
            /**
             * Sets whether the file descriptor of `stream `shall be closed
             * when the stream is closed.
             */
            set_close_fd(close_fd: boolean): void;

            // Implemented Members

            /**
             * Gets the underlying file descriptor.
             */
            vfunc_get_fd(): number;
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            vfunc_read_nonblocking(): [number, Uint8Array | null];
        }
        export module UnixMountMonitor {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class UnixMountMonitor extends GObject.Object {
            static $gtype: GObject.GType<UnixMountMonitor>;

            constructor(properties?: Partial<UnixMountMonitor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixMountMonitor.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "mountpoints-changed", callback: (_source: this) => void): number;
            connect_after(signal: "mountpoints-changed", callback: (_source: this) => void): number;
            emit(signal: "mountpoints-changed"): void;
            connect(signal: "mounts-changed", callback: (_source: this) => void): number;
            connect_after(signal: "mounts-changed", callback: (_source: this) => void): number;
            emit(signal: "mounts-changed"): void;

            // Constructors

            static ["new"](): UnixMountMonitor;

            // Members

            /**
             * This function does nothing.
             *
             * Before 2.44, this was a partially-effective way of controlling the
             * rate at which events would be reported under some uncommon
             * circumstances.  Since `mount_monitor `is a singleton, it also meant
             * that calling this function would have side effects for other users of
             * the monitor.
             */
            set_rate_limit(limit_msec: number): void;
            /**
             * Gets the #GUnixMountMonitor for the current thread-default main
             * context.
             *
             * The mount monitor can be used to monitor for changes to the list of
             * mounted filesystems as well as the list of mount points (ie: fstab
             * entries).
             *
             * You must only call g_object_unref() on the return value from under
             * the same main context as you called this function.
             */
            static get(): UnixMountMonitor;
        }
        export module UnixOutputStream {
            export interface ConstructorProperties extends OutputStream.ConstructorProperties {
                [key: string]: any;
                close_fd: boolean;
                closeFd: boolean;
                fd: number;
            }
        }
        export class UnixOutputStream extends OutputStream implements FileDescriptorBased, PollableOutputStream {
            static $gtype: GObject.GType<UnixOutputStream>;

            constructor(properties?: Partial<UnixOutputStream.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixOutputStream.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get close_fd(): boolean;
            set close_fd(val: boolean);
            get closeFd(): boolean;
            set closeFd(val: boolean);
            get fd(): number;

            // Constructors

            static ["new"](fd: number, close_fd: boolean): UnixOutputStream;

            // Members

            /**
             * Returns whether the file descriptor of `stream `will be
             * closed when the stream is closed.
             */
            get_close_fd(): boolean;
            /**
             * Return the UNIX file descriptor that the stream writes to.
             */
            get_fd(): number;
            /**
             * Sets whether the file descriptor of `stream `shall be closed
             * when the stream is closed.
             */
            set_close_fd(close_fd: boolean): void;

            // Implemented Members

            /**
             * Gets the underlying file descriptor.
             */
            vfunc_get_fd(): number;
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
        }
        export module UnixSocketAddress {
            export interface ConstructorProperties extends SocketAddress.ConstructorProperties {
                [key: string]: any;
                abstract: boolean;
                address_type: UnixSocketAddressType;
                addressType: UnixSocketAddressType;
                path: string;
                path_as_array: Uint8Array;
                pathAsArray: Uint8Array;
            }
        }
        export class UnixSocketAddress extends SocketAddress implements SocketConnectable {
            static $gtype: GObject.GType<UnixSocketAddress>;

            constructor(properties?: Partial<UnixSocketAddress.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<UnixSocketAddress.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get abstract(): boolean;
            get address_type(): UnixSocketAddressType;
            get addressType(): UnixSocketAddressType;
            get path(): string;
            get path_as_array(): Uint8Array;
            get pathAsArray(): Uint8Array;

            // Constructors

            static ["new"](path: string): UnixSocketAddress;
            static new_abstract(path: number[]): UnixSocketAddress;
            static new_with_type(path: number[], type: UnixSocketAddressType): UnixSocketAddress;

            // Members

            /**
             * Gets address's type.
             */
            get_address_type(): UnixSocketAddressType;
            /**
             * Tests if `address `is abstract.
             */
            get_is_abstract(): boolean;
            /**
             * Gets address's path, or for abstract sockets the "name".
             *
             * Guaranteed to be zero-terminated, but an abstract socket
             * may contain embedded zeros, and thus you should use
             * g_unix_socket_address_get_path_len() to get the true length
             * of this string.
             */
            get_path(): string;
            /**
             * Gets the length of address's path.
             *
             * For details, see g_unix_socket_address_get_path().
             */
            get_path_len(): number;
            /**
             * Checks if abstract UNIX domain socket names are supported.
             */
            static abstract_names_supported(): boolean;

            // Implemented Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }
        export module Vfs {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class Vfs extends GObject.Object {
            static $gtype: GObject.GType<Vfs>;

            constructor(properties?: Partial<Vfs.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<Vfs.ConstructorProperties>, ...args: any[]): void;

            // Members

            /**
             * Gets a #GFile for `path.`
             */
            get_file_for_path(path: string): File;
            /**
             * Gets a #GFile for `uri.`
             *
             * This operation never fails, but the returned object
             * might not support any I/O operation if the URI
             * is malformed or if the URI scheme is not supported.
             */
            get_file_for_uri(uri: string): File;
            /**
             * Gets a list of URI schemes supported by `vfs.`
             */
            get_supported_uri_schemes(): string[];
            /**
             * Checks if the VFS is active.
             */
            is_active(): boolean;
            /**
             * This operation never fails, but the returned object might
             * not support any I/O operations if the `parse_name `cannot
             * be parsed by the #GVfs module.
             */
            parse_name(parse_name: string): File;
            /**
             * Registers `uri_func `and `parse_name_func `as the #GFile URI and parse name
             * lookup functions for URIs with a scheme matching `scheme.`
             * Note that `scheme `is registered only within the running application, as
             * opposed to desktop-wide as it happens with GVfs backends.
             *
             * When a #GFile is requested with an URI containing `scheme `(e.g. through
             * g_file_new_for_uri()), `uri_func `will be called to allow a custom
             * constructor. The implementation of `uri_func `should not be blocking, and
             * must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
             *
             * When g_file_parse_name() is called with a parse name obtained from such file,
             * `parse_name_func `will be called to allow the #GFile to be created again. In
             * that case, it's responsibility of `parse_name_func `to make sure the parse
             * name matches what the custom #GFile implementation returned when
             * g_file_get_parse_name() was previously called. The implementation of
             * `parse_name_func `should not be blocking, and must not call
             * g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
             *
             * It's an error to call this function twice with the same scheme. To unregister
             * a custom URI scheme, use g_vfs_unregister_uri_scheme().
             */
            register_uri_scheme(
                scheme: string,
                uri_func?: VfsFileLookupFunc | null,
                uri_destroy?: GLib.DestroyNotify | null,
                parse_name_func?: VfsFileLookupFunc | null,
                parse_name_destroy?: GLib.DestroyNotify | null
            ): boolean;
            /**
             * Unregisters the URI handler for `scheme `previously registered with
             * g_vfs_register_uri_scheme().
             */
            unregister_uri_scheme(scheme: string): boolean;
            vfunc_add_writable_namespaces(list: FileAttributeInfoList): void;
            /**
             * Gets a #GFile for `path.`
             */
            vfunc_get_file_for_path(path: string): File;
            /**
             * Gets a #GFile for `uri.`
             *
             * This operation never fails, but the returned object
             * might not support any I/O operation if the URI
             * is malformed or if the URI scheme is not supported.
             */
            vfunc_get_file_for_uri(uri: string): File;
            /**
             * Gets a list of URI schemes supported by `vfs.`
             */
            vfunc_get_supported_uri_schemes(): string[];
            /**
             * Checks if the VFS is active.
             */
            vfunc_is_active(): boolean;
            vfunc_local_file_add_info(
                filename: string,
                device: number,
                attribute_matcher: FileAttributeMatcher,
                info: FileInfo,
                cancellable?: Cancellable | null,
                extra_data?: any | null
            ): void;
            vfunc_local_file_moved(source: string, dest: string): void;
            vfunc_local_file_removed(filename: string): void;
            vfunc_local_file_set_attributes(
                filename: string,
                info: FileInfo,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * This operation never fails, but the returned object might
             * not support any I/O operations if the `parse_name `cannot
             * be parsed by the #GVfs module.
             */
            vfunc_parse_name(parse_name: string): File;
            /**
             * Gets the default #GVfs for the system.
             */
            static get_default(): Vfs;
            /**
             * Gets the local #GVfs for the system.
             */
            static get_local(): Vfs;
        }
        export module VolumeMonitor {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
            }
        }
        export class VolumeMonitor extends GObject.Object {
            static $gtype: GObject.GType<VolumeMonitor>;

            constructor(properties?: Partial<VolumeMonitor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<VolumeMonitor.ConstructorProperties>, ...args: any[]): void;

            // Signals

            connect(id: string, callback: (...args: any[]) => any): number;
            connect_after(id: string, callback: (...args: any[]) => any): number;
            emit(id: string, ...args: any[]): void;
            connect(signal: "drive-changed", callback: (_source: this, drive: Drive) => void): number;
            connect_after(signal: "drive-changed", callback: (_source: this, drive: Drive) => void): number;
            emit(signal: "drive-changed", drive: Drive): void;
            connect(signal: "drive-connected", callback: (_source: this, drive: Drive) => void): number;
            connect_after(signal: "drive-connected", callback: (_source: this, drive: Drive) => void): number;
            emit(signal: "drive-connected", drive: Drive): void;
            connect(signal: "drive-disconnected", callback: (_source: this, drive: Drive) => void): number;
            connect_after(signal: "drive-disconnected", callback: (_source: this, drive: Drive) => void): number;
            emit(signal: "drive-disconnected", drive: Drive): void;
            connect(signal: "drive-eject-button", callback: (_source: this, drive: Drive) => void): number;
            connect_after(signal: "drive-eject-button", callback: (_source: this, drive: Drive) => void): number;
            emit(signal: "drive-eject-button", drive: Drive): void;
            connect(signal: "drive-stop-button", callback: (_source: this, drive: Drive) => void): number;
            connect_after(signal: "drive-stop-button", callback: (_source: this, drive: Drive) => void): number;
            emit(signal: "drive-stop-button", drive: Drive): void;
            connect(signal: "mount-added", callback: (_source: this, mount: Mount) => void): number;
            connect_after(signal: "mount-added", callback: (_source: this, mount: Mount) => void): number;
            emit(signal: "mount-added", mount: Mount): void;
            connect(signal: "mount-changed", callback: (_source: this, mount: Mount) => void): number;
            connect_after(signal: "mount-changed", callback: (_source: this, mount: Mount) => void): number;
            emit(signal: "mount-changed", mount: Mount): void;
            connect(signal: "mount-pre-unmount", callback: (_source: this, mount: Mount) => void): number;
            connect_after(signal: "mount-pre-unmount", callback: (_source: this, mount: Mount) => void): number;
            emit(signal: "mount-pre-unmount", mount: Mount): void;
            connect(signal: "mount-removed", callback: (_source: this, mount: Mount) => void): number;
            connect_after(signal: "mount-removed", callback: (_source: this, mount: Mount) => void): number;
            emit(signal: "mount-removed", mount: Mount): void;
            connect(signal: "volume-added", callback: (_source: this, volume: Volume) => void): number;
            connect_after(signal: "volume-added", callback: (_source: this, volume: Volume) => void): number;
            emit(signal: "volume-added", volume: Volume): void;
            connect(signal: "volume-changed", callback: (_source: this, volume: Volume) => void): number;
            connect_after(signal: "volume-changed", callback: (_source: this, volume: Volume) => void): number;
            emit(signal: "volume-changed", volume: Volume): void;
            connect(signal: "volume-removed", callback: (_source: this, volume: Volume) => void): number;
            connect_after(signal: "volume-removed", callback: (_source: this, volume: Volume) => void): number;
            emit(signal: "volume-removed", volume: Volume): void;

            // Members

            /**
             * Gets a list of drives connected to the system.
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            get_connected_drives(): Drive[];
            /**
             * Finds a #GMount object by its UUID (see g_mount_get_uuid())
             */
            get_mount_for_uuid(uuid: string): Mount | null;
            /**
             * Gets a list of the mounts on the system.
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            get_mounts(): Mount[];
            /**
             * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
             */
            get_volume_for_uuid(uuid: string): Volume | null;
            /**
             * Gets a list of the volumes on the system.
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            get_volumes(): Volume[];
            vfunc_drive_changed(drive: Drive): void;
            vfunc_drive_connected(drive: Drive): void;
            vfunc_drive_disconnected(drive: Drive): void;
            vfunc_drive_eject_button(drive: Drive): void;
            vfunc_drive_stop_button(drive: Drive): void;
            /**
             * Gets a list of drives connected to the system.
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            vfunc_get_connected_drives(): Drive[];
            /**
             * Finds a #GMount object by its UUID (see g_mount_get_uuid())
             */
            vfunc_get_mount_for_uuid(uuid: string): Mount | null;
            /**
             * Gets a list of the mounts on the system.
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            vfunc_get_mounts(): Mount[];
            /**
             * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
             */
            vfunc_get_volume_for_uuid(uuid: string): Volume | null;
            /**
             * Gets a list of the volumes on the system.
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            vfunc_get_volumes(): Volume[];
            vfunc_mount_added(mount: Mount): void;
            vfunc_mount_changed(mount: Mount): void;
            vfunc_mount_pre_unmount(mount: Mount): void;
            vfunc_mount_removed(mount: Mount): void;
            vfunc_volume_added(volume: Volume): void;
            vfunc_volume_changed(volume: Volume): void;
            vfunc_volume_removed(volume: Volume): void;
            /**
             * This function should be called by any #GVolumeMonitor
             * implementation when a new #GMount object is created that is not
             * associated with a #GVolume object. It must be called just before
             * emitting the `mount_added `signal.
             *
             * If the return value is not %NULL, the caller must associate the
             * returned #GVolume object with the #GMount. This involves returning
             * it in its g_mount_get_volume() implementation. The caller must
             * also listen for the "removed" signal on the returned object
             * and give up its reference when handling that signal
             *
             * Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
             * the implementor must take a reference to `mount `and return it in
             * its g_volume_get_mount() implemented. Also, the implementor must
             * listen for the "unmounted" signal on `mount `and give up its
             * reference upon handling that signal.
             *
             * There are two main use cases for this function.
             *
             * One is when implementing a user space file system driver that reads
             * blocks of a block device that is already represented by the native
             * volume monitor (for example a CD Audio file system driver). Such
             * a driver will generate its own #GMount object that needs to be
             * associated with the #GVolume object that represents the volume.
             *
             * The other is for implementing a #GVolumeMonitor whose sole purpose
             * is to return #GVolume objects representing entries in the users
             * "favorite servers" list or similar.
             */
            static adopt_orphan_mount(mount: Mount): Volume;
            /**
             * Gets the volume monitor used by gio.
             */
            static get(): VolumeMonitor;
        }
        export module ZlibCompressor {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                file_info: FileInfo;
                fileInfo: FileInfo;
                format: ZlibCompressorFormat;
                level: number;
            }
        }
        export class ZlibCompressor extends GObject.Object implements Converter {
            static $gtype: GObject.GType<ZlibCompressor>;

            constructor(properties?: Partial<ZlibCompressor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ZlibCompressor.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get file_info(): FileInfo;
            set file_info(val: FileInfo);
            get fileInfo(): FileInfo;
            set fileInfo(val: FileInfo);
            get format(): ZlibCompressorFormat;
            get level(): number;

            // Constructors

            static ["new"](format: ZlibCompressorFormat, level: number): ZlibCompressor;

            // Members

            /**
             * Returns the #GZlibCompressor:file-info property.
             */
            get_file_info(): FileInfo | null;
            /**
             * Sets `file_info `in `compressor.` If non-%NULL, and compressor's
             * #GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
             * it will be used to set the file name and modification time in
             * the GZIP header of the compressed data.
             *
             * Note: it is an error to call this function while a compression is in
             * progress; it may only be called immediately after creation of compressor,
             * or after resetting it with g_converter_reset().
             */
            set_file_info(file_info?: FileInfo | null): void;

            // Implemented Members

            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            convert(
                inbuf: Uint8Array | string,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            reset(): void;
            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            vfunc_convert(
                inbuf: Uint8Array | null,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            vfunc_reset(): void;
        }
        export module ZlibDecompressor {
            export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
                [key: string]: any;
                file_info: FileInfo;
                fileInfo: FileInfo;
                format: ZlibCompressorFormat;
            }
        }
        export class ZlibDecompressor extends GObject.Object implements Converter {
            static $gtype: GObject.GType<ZlibDecompressor>;

            constructor(properties?: Partial<ZlibDecompressor.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<ZlibDecompressor.ConstructorProperties>, ...args: any[]): void;

            // Properties
            get file_info(): FileInfo;
            get fileInfo(): FileInfo;
            get format(): ZlibCompressorFormat;

            // Constructors

            static ["new"](format: ZlibCompressorFormat): ZlibDecompressor;

            // Members

            /**
             * Retrieves the #GFileInfo constructed from the GZIP header data
             * of compressed data processed by compressor, or %NULL if decompressor's
             * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
             * or the header data was not fully processed yet, or it not present in the
             * data stream at all.
             */
            get_file_info(): FileInfo | null;

            // Implemented Members

            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            convert(
                inbuf: Uint8Array | string,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            reset(): void;
            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            vfunc_convert(
                inbuf: Uint8Array | null,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            vfunc_reset(): void;
        }

        /**
         * This struct defines a single action.  It is for use with
         * g_action_map_add_action_entries().
         *
         * The order of the items in the structure are intended to reflect
         * frequency of use.  It is permissible to use an incomplete initialiser
         * in order to leave some of the later values as %NULL.  All values
         * after `name `are optional.  Additional optional fields may be added in
         * the future.
         *
         * See g_action_map_add_action_entries() for an example.
         */
        export class ActionEntry {
            static $gtype: GObject.GType<ActionEntry>;

            constructor(
                properties?: Partial<{
                    name: string;
                    parameter_type: string;
                    state: string;
                }>
            );
            constructor(copy: ActionEntry);

            // Fields
            name: string;
            parameter_type: string;
            state: string;
        }

        export class AppLaunchContextPrivate {
            static $gtype: GObject.GType<AppLaunchContextPrivate>;

            constructor(copy: AppLaunchContextPrivate);
        }

        export class ApplicationCommandLinePrivate {
            static $gtype: GObject.GType<ApplicationCommandLinePrivate>;

            constructor(copy: ApplicationCommandLinePrivate);
        }

        export class ApplicationPrivate {
            static $gtype: GObject.GType<ApplicationPrivate>;

            constructor(copy: ApplicationPrivate);
        }

        export class BufferedInputStreamPrivate {
            static $gtype: GObject.GType<BufferedInputStreamPrivate>;

            constructor(copy: BufferedInputStreamPrivate);
        }

        export class BufferedOutputStreamPrivate {
            static $gtype: GObject.GType<BufferedOutputStreamPrivate>;

            constructor(copy: BufferedOutputStreamPrivate);
        }

        export class CancellablePrivate {
            static $gtype: GObject.GType<CancellablePrivate>;

            constructor(copy: CancellablePrivate);
        }

        export class ConverterInputStreamPrivate {
            static $gtype: GObject.GType<ConverterInputStreamPrivate>;

            constructor(copy: ConverterInputStreamPrivate);
        }

        export class ConverterOutputStreamPrivate {
            static $gtype: GObject.GType<ConverterOutputStreamPrivate>;

            constructor(copy: ConverterOutputStreamPrivate);
        }

        /**
         * Information about an annotation.
         */
        export class DBusAnnotationInfo {
            static $gtype: GObject.GType<DBusAnnotationInfo>;

            constructor(
                properties?: Partial<{
                    ref_count: number;
                    key: string;
                    value: string;
                    annotations: DBusAnnotationInfo[];
                }>
            );
            constructor(copy: DBusAnnotationInfo);

            // Fields
            ref_count: number;
            key: string;
            value: string;
            annotations: DBusAnnotationInfo[];

            // Members
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusAnnotationInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
            /**
             * Looks up the value of an annotation.
             *
             * The cost of this function is O(n) in number of annotations.
             */
            static lookup(annotations: DBusAnnotationInfo[] | null, name: string): string | null;
        }

        /**
         * Information about an argument for a method or a signal.
         */
        export class DBusArgInfo {
            static $gtype: GObject.GType<DBusArgInfo>;

            constructor(
                properties?: Partial<{
                    ref_count: number;
                    name: string;
                    signature: string;
                    annotations: DBusAnnotationInfo[];
                }>
            );
            constructor(copy: DBusArgInfo);

            // Fields
            ref_count: number;
            name: string;
            signature: string;
            annotations: DBusAnnotationInfo[];

            // Members
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusArgInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
        }

        /**
         * Struct used in g_dbus_error_register_error_domain().
         */
        export class DBusErrorEntry {
            static $gtype: GObject.GType<DBusErrorEntry>;

            constructor(
                properties?: Partial<{
                    error_code: number;
                    dbus_error_name: string;
                }>
            );
            constructor(copy: DBusErrorEntry);

            // Fields
            error_code: number;
            dbus_error_name: string;
        }

        /**
         * Information about a D-Bus interface.
         */
        export class DBusInterfaceInfo {
            static $gtype: GObject.GType<DBusInterfaceInfo>;

            constructor(copy: DBusInterfaceInfo);

            // Fields
            ref_count: number;
            name: string;
            methods: DBusMethodInfo[];
            signals: DBusSignalInfo[];
            annotations: DBusAnnotationInfo[];

            // Constructors
            static new_for_xml(info: string): DBusInterfaceInfo;

            // Members
            /**
             * Builds a lookup-cache to speed up
             * g_dbus_interface_info_lookup_method(),
             * g_dbus_interface_info_lookup_signal() and
             * g_dbus_interface_info_lookup_property().
             *
             * If this has already been called with info, the existing cache is
             * used and its use count is increased.
             *
             * Note that `info `cannot be modified until
             * g_dbus_interface_info_cache_release() is called.
             */
            cache_build(): void;
            /**
             * Decrements the usage count for the cache for `info `built by
             * g_dbus_interface_info_cache_build() (if any) and frees the
             * resources used by the cache if the usage count drops to zero.
             */
            cache_release(): void;
            /**
             * Appends an XML representation of `info `(and its children) to `string_builder.`
             *
             * This function is typically used for generating introspection XML
             * documents at run-time for handling the
             * `org.freedesktop.DBus.Introspectable.Introspect`
             * method.
             */
            generate_xml(indent: number, string_builder: GLib.String): void;
            /**
             * Looks up information about a method.
             *
             * The cost of this function is O(n) in number of methods unless
             * g_dbus_interface_info_cache_build() has been used on `info.`
             */
            lookup_method(name: string): DBusMethodInfo | null;
            /**
             * Looks up information about a property.
             *
             * The cost of this function is O(n) in number of properties unless
             * g_dbus_interface_info_cache_build() has been used on `info.`
             */
            lookup_property(name: string): DBusPropertyInfo | null;
            /**
             * Looks up information about a signal.
             *
             * The cost of this function is O(n) in number of signals unless
             * g_dbus_interface_info_cache_build() has been used on `info.`
             */
            lookup_signal(name: string): DBusSignalInfo | null;
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusInterfaceInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
        }

        export class DBusInterfaceSkeletonPrivate {
            static $gtype: GObject.GType<DBusInterfaceSkeletonPrivate>;

            constructor(copy: DBusInterfaceSkeletonPrivate);
        }

        /**
         * Virtual table for handling properties and method calls for a D-Bus
         * interface.
         *
         * Since 2.38, if you want to handle getting/setting D-Bus properties
         * asynchronously, give %NULL as your get_property() or set_property()
         * function. The D-Bus call will be directed to your `method_call `function,
         * with the provided `interface_name `set to "org.freedesktop.DBus.Properties".
         *
         * Ownership of the #GDBusMethodInvocation object passed to the
         * method_call() function is transferred to your handler; you must
         * call one of the methods of #GDBusMethodInvocation to return a reply
         * (possibly empty), or an error. These functions also take ownership
         * of the passed-in invocation object, so unless the invocation
         * object has otherwise been referenced, it will be then be freed.
         * Calling one of these functions may be done within your
         * method_call() implementation but it also can be done at a later
         * point to handle the method asynchronously.
         *
         * The usual checks on the validity of the calls is performed. For
         * `Get` calls, an error is automatically returned if the property does
         * not exist or the permissions do not allow access. The same checks are
         * performed for `Set` calls, and the provided value is also checked for
         * being the correct type.
         *
         * For both `Get` and `Set` calls, the #GDBusMethodInvocation
         * passed to the `method_call `handler can be queried with
         * g_dbus_method_invocation_get_property_info() to get a pointer
         * to the #GDBusPropertyInfo of the property.
         *
         * If you have readable properties specified in your interface info,
         * you must ensure that you either provide a non-%NULL get_property()
         * function or provide implementations of both the `Get` and `GetAll`
         * methods on org.freedesktop.DBus.Properties interface in your method_call
         * function. Note that the required return type of the `Get` call is
         * `(v)`, not the type of the property. `GetAll` expects a return value
         * of type `a{sv}`.
         *
         * If you have writable properties specified in your interface info,
         * you must ensure that you either provide a non-%NULL set_property()
         * function or provide an implementation of the `Set` call. If implementing
         * the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
         */
        export class DBusInterfaceVTable {
            static $gtype: GObject.GType<DBusInterfaceVTable>;

            constructor(copy: DBusInterfaceVTable);

            // Fields
            method_call: DBusInterfaceMethodCallFunc;
            get_property: DBusInterfaceGetPropertyFunc;
            set_property: DBusInterfaceSetPropertyFunc;
        }

        /**
         * Information about a method on an D-Bus interface.
         */
        export class DBusMethodInfo {
            static $gtype: GObject.GType<DBusMethodInfo>;

            constructor(
                properties?: Partial<{
                    ref_count: number;
                    name: string;
                    in_args: DBusArgInfo[];
                    out_args: DBusArgInfo[];
                    annotations: DBusAnnotationInfo[];
                }>
            );
            constructor(copy: DBusMethodInfo);

            // Fields
            ref_count: number;
            name: string;
            in_args: DBusArgInfo[];
            out_args: DBusArgInfo[];
            annotations: DBusAnnotationInfo[];

            // Members
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusMethodInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
        }

        /**
         * Information about nodes in a remote object hierarchy.
         */
        export class DBusNodeInfo {
            static $gtype: GObject.GType<DBusNodeInfo>;

            constructor(xml_data: string);
            constructor(copy: DBusNodeInfo);

            // Fields
            ref_count: number;
            path: string;
            annotations: DBusAnnotationInfo[];

            // Constructors
            static new_for_xml(xml_data: string): DBusNodeInfo;
            static new_for_xml(info: string): DBusNodeInfo;

            // Members
            /**
             * Appends an XML representation of `info `(and its children) to `string_builder.`
             *
             * This function is typically used for generating introspection XML documents at run-time for
             * handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
             */
            generate_xml(indent: number, string_builder: GLib.String): void;
            /**
             * Looks up information about an interface.
             *
             * The cost of this function is O(n) in number of interfaces.
             */
            lookup_interface(name: string): DBusInterfaceInfo | null;
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusNodeInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
        }

        export class DBusObjectManagerClientPrivate {
            static $gtype: GObject.GType<DBusObjectManagerClientPrivate>;

            constructor(copy: DBusObjectManagerClientPrivate);
        }

        export class DBusObjectManagerServerPrivate {
            static $gtype: GObject.GType<DBusObjectManagerServerPrivate>;

            constructor(copy: DBusObjectManagerServerPrivate);
        }

        export class DBusObjectProxyPrivate {
            static $gtype: GObject.GType<DBusObjectProxyPrivate>;

            constructor(copy: DBusObjectProxyPrivate);
        }

        export class DBusObjectSkeletonPrivate {
            static $gtype: GObject.GType<DBusObjectSkeletonPrivate>;

            constructor(copy: DBusObjectSkeletonPrivate);
        }

        /**
         * Information about a D-Bus property on a D-Bus interface.
         */
        export class DBusPropertyInfo {
            static $gtype: GObject.GType<DBusPropertyInfo>;

            constructor(copy: DBusPropertyInfo);

            // Fields
            ref_count: number;
            name: string;
            signature: string;
            flags: DBusPropertyInfoFlags;
            annotations: DBusAnnotationInfo[];

            // Members
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusPropertyInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
        }

        export class DBusProxyPrivate {
            static $gtype: GObject.GType<DBusProxyPrivate>;

            constructor(copy: DBusProxyPrivate);
        }

        /**
         * Information about a signal on a D-Bus interface.
         */
        export class DBusSignalInfo {
            static $gtype: GObject.GType<DBusSignalInfo>;

            constructor(
                properties?: Partial<{
                    ref_count: number;
                    name: string;
                    args: DBusArgInfo[];
                    annotations: DBusAnnotationInfo[];
                }>
            );
            constructor(copy: DBusSignalInfo);

            // Fields
            ref_count: number;
            name: string;
            args: DBusArgInfo[];
            annotations: DBusAnnotationInfo[];

            // Members
            /**
             * If `info `is statically allocated does nothing. Otherwise increases
             * the reference count.
             */
            ref(): DBusSignalInfo;
            /**
             * If `info `is statically allocated, does nothing. Otherwise decreases
             * the reference count of `info.` When its reference count drops to 0,
             * the memory used is freed.
             */
            unref(): void;
        }

        /**
         * Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
         */
        export class DBusSubtreeVTable {
            static $gtype: GObject.GType<DBusSubtreeVTable>;

            constructor(copy: DBusSubtreeVTable);

            // Fields
            enumerate: DBusSubtreeEnumerateFunc;
            introspect: DBusSubtreeIntrospectFunc;
            dispatch: DBusSubtreeDispatchFunc;
        }

        export class DataInputStreamPrivate {
            static $gtype: GObject.GType<DataInputStreamPrivate>;

            constructor(copy: DataInputStreamPrivate);
        }

        export class DataOutputStreamPrivate {
            static $gtype: GObject.GType<DataOutputStreamPrivate>;

            constructor(copy: DataOutputStreamPrivate);
        }

        export class EmblemedIconPrivate {
            static $gtype: GObject.GType<EmblemedIconPrivate>;

            constructor(copy: EmblemedIconPrivate);
        }

        /**
         * Information about a specific attribute.
         */
        export class FileAttributeInfo {
            static $gtype: GObject.GType<FileAttributeInfo>;

            constructor(copy: FileAttributeInfo);

            // Fields
            name: string;
            type: FileAttributeType;
            flags: FileAttributeInfoFlags;
        }

        /**
         * Acts as a lightweight registry for possible valid file attributes.
         * The registry stores Key-Value pair formats as #GFileAttributeInfos.
         */
        export class FileAttributeInfoList {
            static $gtype: GObject.GType<FileAttributeInfoList>;

            constructor(
                properties?: Partial<{
                    n_infos: number;
                }>
            );
            constructor(copy: FileAttributeInfoList);

            // Fields
            n_infos: number;

            // Constructors
            static ["new"](): FileAttributeInfoList;

            // Members
            /**
             * Adds a new attribute with `name `to the list, setting
             * its `type `and `flags.`
             */
            add(name: string, type: FileAttributeType, flags: FileAttributeInfoFlags): void;
            /**
             * Makes a duplicate of a file attribute info list.
             */
            dup(): FileAttributeInfoList;
            /**
             * Gets the file attribute with the name `name `from `list.`
             */
            lookup(name: string): FileAttributeInfo;
            /**
             * References a file attribute info list.
             */
            ref(): FileAttributeInfoList;
            /**
             * Removes a reference from the given `list.` If the reference count
             * falls to zero, the `list `is deleted.
             */
            unref(): void;
        }

        /**
         * Determines if a string matches a file attribute.
         */
        export class FileAttributeMatcher {
            static $gtype: GObject.GType<FileAttributeMatcher>;

            constructor(attributes: string);
            constructor(copy: FileAttributeMatcher);

            // Constructors
            static ["new"](attributes: string): FileAttributeMatcher;

            // Members
            /**
             * Checks if the matcher will match all of the keys in a given namespace.
             * This will always return %TRUE if a wildcard character is in use (e.g. if
             * matcher was created with "standard::*" and `ns `is "standard", or if matcher was created
             * using "*" and namespace is anything.)
             *
             * TODO: this is awkwardly worded.
             */
            enumerate_namespace(ns: string): boolean;
            /**
             * Gets the next matched attribute from a #GFileAttributeMatcher.
             */
            enumerate_next(): string | null;
            /**
             * Checks if an attribute will be matched by an attribute matcher. If
             * the matcher was created with the "*" matching string, this function
             * will always return %TRUE.
             */
            matches(attribute: string): boolean;
            /**
             * Checks if an attribute matcher only matches a given attribute. Always
             * returns %FALSE if "*" was used when creating the matcher.
             */
            matches_only(attribute: string): boolean;
            /**
             * References a file attribute matcher.
             */
            ref(): FileAttributeMatcher;
            /**
             * Subtracts all attributes of `subtract `from `matcher `and returns
             * a matcher that supports those attributes.
             *
             * Note that currently it is not possible to remove a single
             * attribute when the `matcher `matches the whole namespace - or remove
             * a namespace or attribute when the matcher matches everything. This
             * is a limitation of the current implementation, but may be fixed
             * in the future.
             */
            subtract(subtract?: FileAttributeMatcher | null): FileAttributeMatcher | null;
            /**
             * Prints what the matcher is matching against. The format will be
             * equal to the format passed to g_file_attribute_matcher_new().
             * The output however, might not be identical, as the matcher may
             * decide to use a different order or omit needless parts.
             */
            to_string(): string;
            /**
             * Unreferences `matcher.` If the reference count falls below 1,
             * the `matcher `is automatically freed.
             */
            unref(): void;
        }

        export class FileEnumeratorPrivate {
            static $gtype: GObject.GType<FileEnumeratorPrivate>;

            constructor(copy: FileEnumeratorPrivate);
        }

        export class FileIOStreamPrivate {
            static $gtype: GObject.GType<FileIOStreamPrivate>;

            constructor(copy: FileIOStreamPrivate);
        }

        export class FileInputStreamPrivate {
            static $gtype: GObject.GType<FileInputStreamPrivate>;

            constructor(copy: FileInputStreamPrivate);
        }

        export class FileMonitorPrivate {
            static $gtype: GObject.GType<FileMonitorPrivate>;

            constructor(copy: FileMonitorPrivate);
        }

        export class FileOutputStreamPrivate {
            static $gtype: GObject.GType<FileOutputStreamPrivate>;

            constructor(copy: FileOutputStreamPrivate);
        }

        /**
         * #GIOExtension is an opaque data structure and can only be accessed
         * using the following functions.
         */
        export class IOExtension {
            static $gtype: GObject.GType<IOExtension>;

            constructor(copy: IOExtension);

            // Members
            /**
             * Gets the name under which `extension `was registered.
             *
             * Note that the same type may be registered as extension
             * for multiple extension points, under different names.
             */
            get_name(): string;
            /**
             * Gets the priority with which `extension `was registered.
             */
            get_priority(): number;
            /**
             * Gets the type associated with `extension.`
             */
            get_type(): GObject.GType;
        }

        /**
         * #GIOExtensionPoint is an opaque data structure and can only be accessed
         * using the following functions.
         */
        export class IOExtensionPoint {
            static $gtype: GObject.GType<IOExtensionPoint>;

            constructor(copy: IOExtensionPoint);

            // Members
            /**
             * Finds a #GIOExtension for an extension point by name.
             */
            get_extension_by_name(name: string): IOExtension;
            /**
             * Gets a list of all extensions that implement this extension point.
             * The list is sorted by priority, beginning with the highest priority.
             */
            get_extensions(): IOExtension[];
            /**
             * Gets the required type for `extension_point.`
             */
            get_required_type(): GObject.GType;
            /**
             * Sets the required type for `extension_point `to `type.`
             * All implementations must henceforth have this type.
             */
            set_required_type(type: GObject.GType): void;
            /**
             * Registers `type `as extension for the extension point with name
             * `extension_point_name.`
             *
             * If `type `has already been registered as an extension for this
             * extension point, the existing #GIOExtension object is returned.
             */
            static implement(
                extension_point_name: string,
                type: GObject.GType,
                extension_name: string,
                priority: number
            ): IOExtension;
            /**
             * Looks up an existing extension point.
             */
            static lookup(name: string): IOExtensionPoint;
            /**
             * Registers an extension point.
             */
            static register(name: string): IOExtensionPoint;
        }

        /**
         * Represents a scope for loading IO modules. A scope can be used for blocking
         * duplicate modules, or blocking a module you don't want to load.
         *
         * The scope can be used with g_io_modules_load_all_in_directory_with_scope()
         * or g_io_modules_scan_all_in_directory_with_scope().
         */
        export class IOModuleScope {
            static $gtype: GObject.GType<IOModuleScope>;

            constructor(copy: IOModuleScope);

            // Members
            /**
             * Block modules with the given `basename `from being loaded when
             * this scope is used with g_io_modules_scan_all_in_directory_with_scope()
             * or g_io_modules_load_all_in_directory_with_scope().
             */
            block(basename: string): void;
            /**
             * Free a module scope.
             */
            free(): void;
        }

        /**
         * Opaque class for defining and scheduling IO jobs.
         */
        export class IOSchedulerJob {
            static $gtype: GObject.GType<IOSchedulerJob>;

            constructor(copy: IOSchedulerJob);

            // Members
            /**
             * Used from an I/O job to send a callback to be run in the thread
             * that the job was started from, waiting for the result (and thus
             * blocking the I/O job).
             */
            send_to_mainloop(func: GLib.SourceFunc, notify?: GLib.DestroyNotify | null): boolean;
            /**
             * Used from an I/O job to send a callback to be run asynchronously in
             * the thread that the job was started from. The callback will be run
             * when the main loop is available, but at that time the I/O job might
             * have finished. The return value from the callback is ignored.
             *
             * Note that if you are passing the `user_data `from g_io_scheduler_push_job()
             * on to this function you have to ensure that it is not freed before
             * `func `is called, either by passing %NULL as `notify `to
             * g_io_scheduler_push_job() or by using refcounting for `user_data.`
             */
            send_to_mainloop_async(func: GLib.SourceFunc, notify?: GLib.DestroyNotify | null): void;
        }

        export class IOStreamAdapter {
            static $gtype: GObject.GType<IOStreamAdapter>;

            constructor(copy: IOStreamAdapter);
        }

        export class IOStreamPrivate {
            static $gtype: GObject.GType<IOStreamPrivate>;

            constructor(copy: IOStreamPrivate);
        }

        export class InetAddressMaskPrivate {
            static $gtype: GObject.GType<InetAddressMaskPrivate>;

            constructor(copy: InetAddressMaskPrivate);
        }

        export class InetAddressPrivate {
            static $gtype: GObject.GType<InetAddressPrivate>;

            constructor(copy: InetAddressPrivate);
        }

        export class InetSocketAddressPrivate {
            static $gtype: GObject.GType<InetSocketAddressPrivate>;

            constructor(copy: InetSocketAddressPrivate);
        }

        /**
         * Structure used for scatter/gather data input when receiving multiple
         * messages or packets in one go. You generally pass in an array of empty
         * #GInputVectors and the operation will use all the buffers as if they
         * were one buffer, and will set `bytes_received `to the total number of bytes
         * received across all #GInputVectors.
         *
         * This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
         * the POSIX sockets API (see `man 2 recvmmsg`).
         *
         * If `address `is non-%NULL then it is set to the source address the message
         * was received from, and the caller must free it afterwards.
         *
         * If `control_messages `is non-%NULL then it is set to an array of control
         * messages received with the message (if any), and the caller must free it
         * afterwards. `num_control_messages `is set to the number of elements in
         * this array, which may be zero.
         *
         * Flags relevant to this message will be returned in `flags.` For example,
         * `MSG_EOR` or `MSG_TRUNC`.
         */
        export class InputMessage {
            static $gtype: GObject.GType<InputMessage>;

            constructor(copy: InputMessage);

            // Fields
            address: SocketAddress;
            vectors: InputVector[];
            num_vectors: number;
            bytes_received: number;
            flags: number;
            control_messages: SocketControlMessage[];
            num_control_messages: number;
        }

        export class InputStreamPrivate {
            static $gtype: GObject.GType<InputStreamPrivate>;

            constructor(copy: InputStreamPrivate);
        }

        /**
         * Structure used for scatter/gather data input.
         * You generally pass in an array of #GInputVectors
         * and the operation will store the read data starting in the
         * first buffer, switching to the next as needed.
         */
        export class InputVector {
            static $gtype: GObject.GType<InputVector>;

            constructor(
                properties?: Partial<{
                    buffer: any;
                    size: number;
                }>
            );
            constructor(copy: InputVector);

            // Fields
            buffer: any;
            size: number;
        }

        export class MemoryInputStreamPrivate {
            static $gtype: GObject.GType<MemoryInputStreamPrivate>;

            constructor(copy: MemoryInputStreamPrivate);
        }

        export class MemoryOutputStreamPrivate {
            static $gtype: GObject.GType<MemoryOutputStreamPrivate>;

            constructor(copy: MemoryOutputStreamPrivate);
        }

        export class MenuAttributeIterPrivate {
            static $gtype: GObject.GType<MenuAttributeIterPrivate>;

            constructor(copy: MenuAttributeIterPrivate);
        }

        export class MenuLinkIterPrivate {
            static $gtype: GObject.GType<MenuLinkIterPrivate>;

            constructor(copy: MenuLinkIterPrivate);
        }

        export class MenuModelPrivate {
            static $gtype: GObject.GType<MenuModelPrivate>;

            constructor(copy: MenuModelPrivate);
        }

        export class MountOperationPrivate {
            static $gtype: GObject.GType<MountOperationPrivate>;

            constructor(copy: MountOperationPrivate);
        }

        export class NativeSocketAddressPrivate {
            static $gtype: GObject.GType<NativeSocketAddressPrivate>;

            constructor(copy: NativeSocketAddressPrivate);
        }

        export class NetworkAddressPrivate {
            static $gtype: GObject.GType<NetworkAddressPrivate>;

            constructor(copy: NetworkAddressPrivate);
        }

        export class NetworkServicePrivate {
            static $gtype: GObject.GType<NetworkServicePrivate>;

            constructor(copy: NetworkServicePrivate);
        }

        /**
         * Structure used for scatter/gather data output when sending multiple
         * messages or packets in one go. You generally pass in an array of
         * #GOutputVectors and the operation will use all the buffers as if they
         * were one buffer.
         *
         * If `address `is %NULL then the message is sent to the default receiver
         * (as previously set by g_socket_connect()).
         */
        export class OutputMessage {
            static $gtype: GObject.GType<OutputMessage>;

            constructor(copy: OutputMessage);

            // Fields
            address: SocketAddress;
            vectors: OutputVector;
            num_vectors: number;
            bytes_sent: number;
            control_messages: SocketControlMessage[];
            num_control_messages: number;
        }

        export class OutputStreamPrivate {
            static $gtype: GObject.GType<OutputStreamPrivate>;

            constructor(copy: OutputStreamPrivate);
        }

        /**
         * Structure used for scatter/gather data output.
         * You generally pass in an array of #GOutputVectors
         * and the operation will use all the buffers as if they were
         * one buffer.
         */
        export class OutputVector {
            static $gtype: GObject.GType<OutputVector>;

            constructor(
                properties?: Partial<{
                    buffer: any;
                    size: number;
                }>
            );
            constructor(copy: OutputVector);

            // Fields
            buffer: any;
            size: number;
        }

        export class PermissionPrivate {
            static $gtype: GObject.GType<PermissionPrivate>;

            constructor(copy: PermissionPrivate);
        }

        export class ProxyAddressEnumeratorPrivate {
            static $gtype: GObject.GType<ProxyAddressEnumeratorPrivate>;

            constructor(copy: ProxyAddressEnumeratorPrivate);
        }

        export class ProxyAddressPrivate {
            static $gtype: GObject.GType<ProxyAddressPrivate>;

            constructor(copy: ProxyAddressPrivate);
        }

        export class ResolverPrivate {
            static $gtype: GObject.GType<ResolverPrivate>;

            constructor(copy: ResolverPrivate);
        }

        /**
         * Applications and libraries often contain binary or textual data that is
         * really part of the application, rather than user data. For instance
         * #GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
         * icons, etc. These are often shipped as files in `$datadir/appname`, or
         * manually included as literal strings in the code.
         *
         * The #GResource API and the [glib-compile-resources][glib-compile-resources] program
         * provide a convenient and efficient alternative to this which has some nice properties. You
         * maintain the files as normal files, so its easy to edit them, but during the build the files
         * are combined into a binary bundle that is linked into the executable. This means that loading
         * the resource files are efficient (as they are already in memory, shared with other instances) and
         * simple (no need to check for things like I/O errors or locate the files in the filesystem). It
         * also makes it easier to create relocatable applications.
         *
         * Resource files can also be marked as compressed. Such files will be included in the resource bundle
         * in a compressed form, but will be automatically uncompressed when the resource is used. This
         * is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.
         *
         * Resource files can also be marked to be preprocessed, by setting the value of the
         * `preprocess` attribute to a comma-separated list of preprocessing options.
         * The only options currently supported are:
         *
         * `xml-stripblanks` which will use the xmllint command
         * to strip ignorable whitespace from the XML file. For this to work,
         * the `XMLLINT` environment variable must be set to the full path to
         * the xmllint executable, or xmllint must be in the `PATH`; otherwise
         * the preprocessing step is skipped.
         *
         * `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
         * `gdk-pixbuf-pixdata` command to convert images to the #GdkPixdata format,
         * which allows you to create pixbufs directly using the data inside the
         * resource file, rather than an (uncompressed) copy of it. For this, the
         * `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
         * `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
         * `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
         * `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
         * supports embedding modern image formats just as well. Instead of using it,
         * embed a PNG or SVG file in your #GResource.
         *
         * `json-stripblanks` which will use the `json-glib-format` command to strip
         * ignorable whitespace from the JSON file. For this to work, the
         * `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
         * `json-glib-format` executable, or it must be in the `PATH`;
         * otherwise the preprocessing step is skipped. In addition, at least version
         * 1.6 of `json-glib-format` is required.
         *
         * Resource files will be exported in the GResource namespace using the
         * combination of the given `prefix` and the filename from the `file` element.
         * The `alias` attribute can be used to alter the filename to expose them at a
         * different location in the resource namespace. Typically, this is used to
         * include files from a different source directory without exposing the source
         * directory in the resource namespace, as in the example below.
         *
         * Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
         * which takes an XML file that describes the bundle, and a set of files that the XML references. These
         * are combined into a binary resource bundle.
         *
         * An example resource description:
         * |[
         * &lt;?xml version="1.0" encoding="UTF-8"?&gt;
         * &lt;gresources&gt;
         * &lt;gresource prefix="/org/gtk/Example"&gt;
         * &lt;file&gt;data/splashscreen.png&lt;/file&gt;
         * &lt;file compressed="true"&gt;dialog.ui&lt;/file&gt;
         * &lt;file preprocess="xml-stripblanks"&gt;menumarkup.xml&lt;/file&gt;
         * &lt;file alias="example.css"&gt;data/example.css&lt;/file&gt;
         * &lt;/gresource&gt;
         * &lt;/gresources&gt;
         * ]|
         *
         * This will create a resource bundle with the following files:
         * |[
         * /org/gtk/Example/data/splashscreen.png
         * /org/gtk/Example/dialog.ui
         * /org/gtk/Example/menumarkup.xml
         * /org/gtk/Example/example.css
         * ]|
         *
         * Note that all resources in the process share the same namespace, so use Java-style
         * path prefixes (like in the above example) to avoid conflicts.
         *
         * You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
         * binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
         * --generate-header arguments to create a source file and header to link directly into your application.
         * This will generate `get_resource()`, `register_resource()` and
         * `unregister_resource()` functions, prefixed by the `--c-name` argument passed
         * to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
         * the generated #GResource object. The register and unregister functions
         * register the resource so its files can be accessed using
         * g_resources_lookup_data().
         *
         * Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
         * using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
         * to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
         * the resource data.
         *
         * Some higher-level APIs, such as #GtkApplication, will automatically load
         * resources from certain well-known paths in the resource namespace as a
         * convenience. See the documentation for those APIs for details.
         *
         * There are two forms of the generated source, the default version uses the compiler support for constructor
         * and destructor functions (where available) to automatically create and register the #GResource on startup
         * or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
         * instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
         * even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
         *
         * Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
         * during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
         * when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
         * are for your own resources, and resource data is often used once, during parsing, and then released.
         *
         * When debugging a program or testing a change to an installed version, it is often useful to be able to
         * replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
         * purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
         * resources with replacements from the filesystem.  It is a %G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
         * during resource lookups. It is ignored when running in a setuid process.
         *
         * A substitution has the form
         *
         * |[
         * /org/gtk/libgtk=/home/desrt/gtk-overlay
         * ]|
         *
         * The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
         * filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
         * equivalent names.
         *
         * In the example above, if an application tried to load a resource with the resource path
         * `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
         * `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
         * overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
         * version will be used instead.  Whiteouts are not currently supported.
         *
         * Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
         * the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
         * location of a single resource with an individual file.
         */
        export class Resource {
            static $gtype: GObject.GType<Resource>;

            constructor(data: GLib.Bytes | Uint8Array);
            constructor(copy: Resource);

            // Constructors
            static new_from_data(data: GLib.Bytes | Uint8Array): Resource;

            // Members
            /**
             * Registers the resource with the process-global set of resources.
             * Once a resource is registered the files in it can be accessed
             * with the global resource lookup functions like g_resources_lookup_data().
             */
            _register(): void;
            /**
             * Unregisters the resource from the process-global set of resources.
             */
            _unregister(): void;
            /**
             * Returns all the names of children at the specified `path `in the resource.
             * The return result is a %NULL terminated list of strings which should
             * be released with g_strfreev().
             *
             * If `path `is invalid or does not exist in the #GResource,
             * %G_RESOURCE_ERROR_NOT_FOUND will be returned.
             *
             * `lookup_flags `controls the behaviour of the lookup.
             */
            enumerate_children(path: string, lookup_flags: ResourceLookupFlags): string[];
            /**
             * Looks for a file at the specified `path `in the resource and
             * if found returns information about it.
             *
             * `lookup_flags `controls the behaviour of the lookup.
             */
            get_info(path: string, lookup_flags: ResourceLookupFlags): [boolean, number, number];
            /**
             * Looks for a file at the specified `path `in the resource and
             * returns a #GBytes that lets you directly access the data in
             * memory.
             *
             * The data is always followed by a zero byte, so you
             * can safely use the data as a C string. However, that byte
             * is not included in the size of the GBytes.
             *
             * For uncompressed resource files this is a pointer directly into
             * the resource bundle, which is typically in some readonly data section
             * in the program binary. For compressed files we allocate memory on
             * the heap and automatically uncompress the data.
             *
             * `lookup_flags `controls the behaviour of the lookup.
             */
            lookup_data(path: string, lookup_flags: ResourceLookupFlags): GLib.Bytes;
            /**
             * Looks for a file at the specified `path `in the resource and
             * returns a #GInputStream that lets you read the data.
             *
             * `lookup_flags `controls the behaviour of the lookup.
             */
            open_stream(path: string, lookup_flags: ResourceLookupFlags): InputStream;
            /**
             * Atomically increments the reference count of `resource `by one. This
             * function is MT-safe and may be called from any thread.
             */
            ref(): Resource;
            /**
             * Atomically decrements the reference count of `resource `by one. If the
             * reference count drops to 0, all memory allocated by the resource is
             * released. This function is MT-safe and may be called from any
             * thread.
             */
            unref(): void;
            /**
             * Loads a binary resource bundle and creates a #GResource representation of it, allowing
             * you to query it for data.
             *
             * If you want to use this resource in the global resource namespace you need
             * to register it with g_resources_register().
             *
             * If `filename `is empty or the data in it is corrupt,
             * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename `doesn’t exist, or
             * there is an error in reading it, an error from g_mapped_file_new() will be
             * returned.
             */
            static load(filename: string): Resource;
        }

        export class SettingsBackendPrivate {
            static $gtype: GObject.GType<SettingsBackendPrivate>;

            constructor(copy: SettingsBackendPrivate);
        }

        export class SettingsPrivate {
            static $gtype: GObject.GType<SettingsPrivate>;

            constructor(copy: SettingsPrivate);
        }

        /**
         * The #GSettingsSchemaSource and #GSettingsSchema APIs provide a
         * mechanism for advanced control over the loading of schemas and a
         * mechanism for introspecting their content.
         *
         * Plugin loading systems that wish to provide plugins a way to access
         * settings face the problem of how to make the schemas for these
         * settings visible to GSettings.  Typically, a plugin will want to ship
         * the schema along with itself and it won't be installed into the
         * standard system directories for schemas.
         *
         * #GSettingsSchemaSource provides a mechanism for dealing with this by
         * allowing the creation of a new 'schema source' from which schemas can
         * be acquired.  This schema source can then become part of the metadata
         * associated with the plugin and queried whenever the plugin requires
         * access to some settings.
         *
         * Consider the following example:
         *
         * |[&lt;!-- language="C" --&gt;
         * typedef struct
         * {
         * ...
         * GSettingsSchemaSource *schema_source;
         * ...
         * } Plugin;
         *
         * Plugin *
         * initialise_plugin (const gchar *dir)
         * {
         * Plugin *plugin;
         *
         * ...
         *
         * plugin-&gt;schema_source =
         * g_settings_schema_source_new_from_directory (dir,
         * g_settings_schema_source_get_default (), FALSE, NULL);
         *
         * ...
         *
         * return plugin;
         * }
         *
         * ...
         *
         * GSettings *
         * plugin_get_settings (Plugin      *plugin,
         * const gchar *schema_id)
         * {
         * GSettingsSchema *schema;
         *
         * if (schema_id == NULL)
         * schema_id = plugin-&gt;identifier;
         *
         * schema = g_settings_schema_source_lookup (plugin-&gt;schema_source,
         * schema_id, FALSE);
         *
         * if (schema == NULL)
         * {
         * ... disable the plugin or abort, etc ...
         * }
         *
         * return g_settings_new_full (schema, NULL, NULL);
         * }
         * ]|
         *
         * The code above shows how hooks should be added to the code that
         * initialises (or enables) the plugin to create the schema source and
         * how an API can be added to the plugin system to provide a convenient
         * way for the plugin to access its settings, using the schemas that it
         * ships.
         *
         * From the standpoint of the plugin, it would need to ensure that it
         * ships a gschemas.compiled file as part of itself, and then simply do
         * the following:
         *
         * |[&lt;!-- language="C" --&gt;
         * {
         * GSettings *settings;
         * gint some_value;
         *
         * settings = plugin_get_settings (self, NULL);
         * some_value = g_settings_get_int (settings, "some-value");
         * ...
         * }
         * ]|
         *
         * It's also possible that the plugin system expects the schema source
         * files (ie: .gschema.xml files) instead of a gschemas.compiled file.
         * In that case, the plugin loading system must compile the schemas for
         * itself before attempting to create the settings source.
         */
        export class SettingsSchema {
            static $gtype: GObject.GType<SettingsSchema>;

            constructor(copy: SettingsSchema);

            // Fields
            _realGetKey: typeof SettingsSchema.prototype.get_key;

            // Members
            /**
             * Get the ID of `schema.`
             */
            get_id(): string;
            /**
             * Gets the key named `name `from `schema.`
             *
             * It is a programmer error to request a key that does not exist.  See
             * g_settings_schema_list_keys().
             */
            get_key(name: string): SettingsSchemaKey;
            /**
             * Gets the path associated with schema, or %NULL.
             *
             * Schemas may be single-instance or relocatable.  Single-instance
             * schemas correspond to exactly one set of keys in the backend
             * database: those located at the path returned by this function.
             *
             * Relocatable schemas can be referenced by other schemas and can
             * therefore describe multiple sets of keys at different locations.  For
             * relocatable schemas, this function will return %NULL.
             */
            get_path(): string | null;
            /**
             * Checks if `schema `has a key named `name.`
             */
            has_key(name: string): boolean;
            /**
             * Gets the list of children in `schema.`
             *
             * You should free the return value with g_strfreev() when you are done
             * with it.
             */
            list_children(): string[];
            /**
             * Introspects the list of keys on `schema.`
             *
             * You should probably not be calling this function from "normal" code
             * (since you should already know what keys are in your schema).  This
             * function is intended for introspection reasons.
             */
            list_keys(): string[];
            /**
             * Increase the reference count of schema, returning a new reference.
             */
            ref(): SettingsSchema;
            /**
             * Decrease the reference count of schema, possibly freeing it.
             */
            unref(): void;
        }

        /**
         * #GSettingsSchemaKey is an opaque data structure and can only be accessed
         * using the following functions.
         */
        export class SettingsSchemaKey {
            static $gtype: GObject.GType<SettingsSchemaKey>;

            constructor(copy: SettingsSchemaKey);

            // Members
            /**
             * Gets the default value for `key.`
             *
             * Note that this is the default value according to the schema.  System
             * administrator defaults and lockdown are not visible via this API.
             */
            get_default_value(): GLib.Variant;
            /**
             * Gets the description for `key.`
             *
             * If no description has been provided in the schema for key, returns
             * %NULL.
             *
             * The description can be one sentence to several paragraphs in length.
             * Paragraphs are delimited with a double newline.  Descriptions can be
             * translated and the value returned from this function is is the
             * current locale.
             *
             * This function is slow.  The summary and description information for
             * the schemas is not stored in the compiled schema database so this
             * function has to parse all of the source XML files in the schema
             * directory.
             */
            get_description(): string | null;
            /**
             * Gets the name of `key.`
             */
            get_name(): string;
            /**
             * Queries the range of a key.
             *
             * This function will return a #GVariant that fully describes the range
             * of values that are valid for `key.`
             *
             * The type of #GVariant returned is `(sv)`. The string describes
             * the type of range restriction in effect. The type and meaning of
             * the value contained in the variant depends on the string.
             *
             * If the string is `'type'` then the variant contains an empty array.
             * The element type of that empty array is the expected type of value
             * and all values of that type are valid.
             *
             * If the string is `'enum'` then the variant contains an array
             * enumerating the possible values. Each item in the array is
             * a possible valid value and no other values are valid.
             *
             * If the string is `'flags'` then the variant contains an array. Each
             * item in the array is a value that may appear zero or one times in an
             * array to be used as the value for this key. For example, if the
             * variant contained the array `['x', 'y']` then the valid values for
             * the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
             * `['y', 'x']`.
             *
             * Finally, if the string is `'range'` then the variant contains a pair
             * of like-typed values -- the minimum and maximum permissible values
             * for this key.
             *
             * This information should not be used by normal programs.  It is
             * considered to be a hint for introspection purposes.  Normal programs
             * should already know what is permitted by their own schema.  The
             * format may change in any way in the future -- but particularly, new
             * forms may be added to the possibilities described above.
             *
             * You should free the returned value with g_variant_unref() when it is
             * no longer needed.
             */
            get_range(): GLib.Variant;
            /**
             * Gets the summary for `key.`
             *
             * If no summary has been provided in the schema for key, returns
             * %NULL.
             *
             * The summary is a short description of the purpose of the key; usually
             * one short sentence.  Summaries can be translated and the value
             * returned from this function is is the current locale.
             *
             * This function is slow.  The summary and description information for
             * the schemas is not stored in the compiled schema database so this
             * function has to parse all of the source XML files in the schema
             * directory.
             */
            get_summary(): string | null;
            /**
             * Gets the #GVariantType of `key.`
             */
            get_value_type(): GLib.VariantType;
            /**
             * Checks if the given `value `is within the
             * permitted range for `key.`
             *
             * It is a programmer error if `value `is not of the correct type — you
             * must check for this first.
             */
            range_check(value: GLib.Variant): boolean;
            /**
             * Increase the reference count of key, returning a new reference.
             */
            ref(): SettingsSchemaKey;
            /**
             * Decrease the reference count of key, possibly freeing it.
             */
            unref(): void;
        }

        /**
         * This is an opaque structure type.  You may not access it directly.
         */
        export class SettingsSchemaSource {
            static $gtype: GObject.GType<SettingsSchemaSource>;

            constructor(directory: string, parent: SettingsSchemaSource | null, trusted: boolean);
            constructor(copy: SettingsSchemaSource);

            // Constructors
            static new_from_directory(
                directory: string,
                parent: SettingsSchemaSource | null,
                trusted: boolean
            ): SettingsSchemaSource;

            // Members
            /**
             * Lists the schemas in a given source.
             *
             * If `recursive `is %TRUE then include parent sources.  If %FALSE then
             * only include the schemas from one source (ie: one directory).  You
             * probably want %TRUE.
             *
             * Non-relocatable schemas are those for which you can call
             * g_settings_new().  Relocatable schemas are those for which you must
             * use g_settings_new_with_path().
             *
             * Do not call this function from normal programs.  This is designed for
             * use by database editors, commandline tools, etc.
             */
            list_schemas(recursive: boolean): [string[], string[]];
            /**
             * Looks up a schema with the identifier `schema_id `in `source.`
             *
             * This function is not required for normal uses of #GSettings but it
             * may be useful to authors of plugin management systems or to those who
             * want to introspect the content of schemas.
             *
             * If the schema isn't found directly in `source `and `recursive `is %TRUE
             * then the parent sources will also be checked.
             *
             * If the schema isn't found, %NULL is returned.
             */
            lookup(schema_id: string, recursive: boolean): SettingsSchema | null;
            /**
             * Increase the reference count of source, returning a new reference.
             */
            ref(): SettingsSchemaSource;
            /**
             * Decrease the reference count of source, possibly freeing it.
             */
            unref(): void;
            /**
             * Gets the default system schema source.
             *
             * This function is not required for normal uses of #GSettings but it
             * may be useful to authors of plugin management systems or to those who
             * want to introspect the content of schemas.
             *
             * If no schemas are installed, %NULL will be returned.
             *
             * The returned source may actually consist of multiple schema sources
             * from different directories, depending on which directories were given
             * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
             * lookups performed against the default source should probably be done
             * recursively.
             */
            static get_default(): SettingsSchemaSource | null;
        }

        export class SimpleActionGroupPrivate {
            static $gtype: GObject.GType<SimpleActionGroupPrivate>;

            constructor(copy: SimpleActionGroupPrivate);
        }

        export class SimpleProxyResolverPrivate {
            static $gtype: GObject.GType<SimpleProxyResolverPrivate>;

            constructor(copy: SimpleProxyResolverPrivate);
        }

        export class SocketClientPrivate {
            static $gtype: GObject.GType<SocketClientPrivate>;

            constructor(copy: SocketClientPrivate);
        }

        export class SocketConnectionPrivate {
            static $gtype: GObject.GType<SocketConnectionPrivate>;

            constructor(copy: SocketConnectionPrivate);
        }

        export class SocketControlMessagePrivate {
            static $gtype: GObject.GType<SocketControlMessagePrivate>;

            constructor(copy: SocketControlMessagePrivate);
        }

        export class SocketListenerPrivate {
            static $gtype: GObject.GType<SocketListenerPrivate>;

            constructor(copy: SocketListenerPrivate);
        }

        export class SocketPrivate {
            static $gtype: GObject.GType<SocketPrivate>;

            constructor(copy: SocketPrivate);
        }

        export class SocketServicePrivate {
            static $gtype: GObject.GType<SocketServicePrivate>;

            constructor(copy: SocketServicePrivate);
        }

        /**
         * SRV (service) records are used by some network protocols to provide
         * service-specific aliasing and load-balancing. For example, XMPP
         * (Jabber) uses SRV records to locate the XMPP server for a domain;
         * rather than connecting directly to "example.com" or assuming a
         * specific server hostname like "xmpp.example.com", an XMPP client
         * would look up the "xmpp-client" SRV record for "example.com", and
         * then connect to whatever host was pointed to by that record.
         *
         * You can use g_resolver_lookup_service() or
         * g_resolver_lookup_service_async() to find the #GSrvTargets
         * for a given service. However, if you are simply planning to connect
         * to the remote service, you can use #GNetworkService's
         * #GSocketConnectable interface and not need to worry about
         * #GSrvTarget at all.
         */
        export class SrvTarget {
            static $gtype: GObject.GType<SrvTarget>;

            constructor(hostname: string, port: number, priority: number, weight: number);
            constructor(copy: SrvTarget);

            // Constructors
            static ["new"](hostname: string, port: number, priority: number, weight: number): SrvTarget;

            // Members
            /**
             * Copies target
             */
            copy(): SrvTarget;
            /**
             * Frees target
             */
            free(): void;
            /**
             * Gets target's hostname (in ASCII form; if you are going to present
             * this to the user, you should use g_hostname_is_ascii_encoded() to
             * check if it contains encoded Unicode segments, and use
             * g_hostname_to_unicode() to convert it if it does.)
             */
            get_hostname(): string;
            /**
             * Gets target's port
             */
            get_port(): number;
            /**
             * Gets target's priority. You should not need to look at this;
             * #GResolver already sorts the targets according to the algorithm in
             * RFC 2782.
             */
            get_priority(): number;
            /**
             * Gets target's weight. You should not need to look at this;
             * #GResolver already sorts the targets according to the algorithm in
             * RFC 2782.
             */
            get_weight(): number;
        }

        /**
         * #GStaticResource is an opaque data structure and can only be accessed
         * using the following functions.
         */
        export class StaticResource {
            static $gtype: GObject.GType<StaticResource>;

            constructor(copy: StaticResource);

            // Members
            /**
             * Finalized a GResource initialized by g_static_resource_init().
             *
             * This is normally used by code generated by
             * [glib-compile-resources][glib-compile-resources]
             * and is not typically used by other code.
             */
            fini(): void;
            /**
             * Gets the GResource that was registered by a call to g_static_resource_init().
             *
             * This is normally used by code generated by
             * [glib-compile-resources][glib-compile-resources]
             * and is not typically used by other code.
             */
            get_resource(): Resource;
            /**
             * Initializes a GResource from static data using a
             * GStaticResource.
             *
             * This is normally used by code generated by
             * [glib-compile-resources][glib-compile-resources]
             * and is not typically used by other code.
             */
            init(): void;
        }

        export class TcpConnectionPrivate {
            static $gtype: GObject.GType<TcpConnectionPrivate>;

            constructor(copy: TcpConnectionPrivate);
        }

        export class TcpWrapperConnectionPrivate {
            static $gtype: GObject.GType<TcpWrapperConnectionPrivate>;

            constructor(copy: TcpWrapperConnectionPrivate);
        }

        export class ThreadedSocketServicePrivate {
            static $gtype: GObject.GType<ThreadedSocketServicePrivate>;

            constructor(copy: ThreadedSocketServicePrivate);
        }

        export class TlsCertificatePrivate {
            static $gtype: GObject.GType<TlsCertificatePrivate>;

            constructor(copy: TlsCertificatePrivate);
        }

        export class TlsConnectionPrivate {
            static $gtype: GObject.GType<TlsConnectionPrivate>;

            constructor(copy: TlsConnectionPrivate);
        }

        export class TlsDatabasePrivate {
            static $gtype: GObject.GType<TlsDatabasePrivate>;

            constructor(copy: TlsDatabasePrivate);
        }

        export class TlsInteractionPrivate {
            static $gtype: GObject.GType<TlsInteractionPrivate>;

            constructor(copy: TlsInteractionPrivate);
        }

        export class TlsPasswordPrivate {
            static $gtype: GObject.GType<TlsPasswordPrivate>;

            constructor(copy: TlsPasswordPrivate);
        }

        export class UnixConnectionPrivate {
            static $gtype: GObject.GType<UnixConnectionPrivate>;

            constructor(copy: UnixConnectionPrivate);
        }

        export class UnixCredentialsMessagePrivate {
            static $gtype: GObject.GType<UnixCredentialsMessagePrivate>;

            constructor(copy: UnixCredentialsMessagePrivate);
        }

        export class UnixFDListPrivate {
            static $gtype: GObject.GType<UnixFDListPrivate>;

            constructor(copy: UnixFDListPrivate);
        }

        export class UnixFDMessagePrivate {
            static $gtype: GObject.GType<UnixFDMessagePrivate>;

            constructor(copy: UnixFDMessagePrivate);
        }

        export class UnixInputStreamPrivate {
            static $gtype: GObject.GType<UnixInputStreamPrivate>;

            constructor(copy: UnixInputStreamPrivate);
        }

        /**
         * Defines a Unix mount entry (e.g. &lt;filename&gt;/media/cdrom&lt;/filename&gt;).
         * This corresponds roughly to a mtab entry.
         */
        export class UnixMountEntry {
            static $gtype: GObject.GType<UnixMountEntry>;

            constructor(copy: UnixMountEntry);
        }

        /**
         * Defines a Unix mount point (e.g. &lt;filename&gt;/dev&lt;/filename&gt;).
         * This corresponds roughly to a fstab entry.
         */
        export class UnixMountPoint {
            static $gtype: GObject.GType<UnixMountPoint>;

            constructor(copy: UnixMountPoint);

            // Members
            /**
             * Compares two unix mount points.
             */
            compare(mount2: UnixMountPoint): number;
            /**
             * Makes a copy of `mount_point.`
             */
            copy(): UnixMountPoint;
            /**
             * Frees a unix mount point.
             */
            free(): void;
            /**
             * Gets the device path for a unix mount point.
             */
            get_device_path(): string;
            /**
             * Gets the file system type for the mount point.
             */
            get_fs_type(): string;
            /**
             * Gets the mount path for a unix mount point.
             */
            get_mount_path(): string;
            /**
             * Gets the options for the mount point.
             */
            get_options(): string | null;
            /**
             * Guesses whether a Unix mount point can be ejected.
             */
            guess_can_eject(): boolean;
            /**
             * Guesses the icon of a Unix mount point.
             */
            guess_icon(): Icon;
            /**
             * Guesses the name of a Unix mount point.
             * The result is a translated string.
             */
            guess_name(): string;
            /**
             * Guesses the symbolic icon of a Unix mount point.
             */
            guess_symbolic_icon(): Icon;
            /**
             * Checks if a unix mount point is a loopback device.
             */
            is_loopback(): boolean;
            /**
             * Checks if a unix mount point is read only.
             */
            is_readonly(): boolean;
            /**
             * Checks if a unix mount point is mountable by the user.
             */
            is_user_mountable(): boolean;
            /**
             * Gets a #GUnixMountPoint for a given mount path. If `time_read `is set, it
             * will be filled with a unix timestamp for checking if the mount points have
             * changed since with g_unix_mount_points_changed_since().
             *
             * If more mount points have the same mount path, the last matching mount point
             * is returned.
             */
            static at(mount_path: string): [UnixMountPoint | null, number];
        }

        export class UnixOutputStreamPrivate {
            static $gtype: GObject.GType<UnixOutputStreamPrivate>;

            constructor(copy: UnixOutputStreamPrivate);
        }

        export class UnixSocketAddressPrivate {
            static $gtype: GObject.GType<UnixSocketAddressPrivate>;

            constructor(copy: UnixSocketAddressPrivate);
        }

        /**
         * #GAction represents a single named action.
         *
         * The main interface to an action is that it can be activated with
         * g_action_activate().  This results in the 'activate' signal being
         * emitted.  An activation has a #GVariant parameter (which may be
         * %NULL).  The correct type for the parameter is determined by a static
         * parameter type (which is given at construction time).
         *
         * An action may optionally have a state, in which case the state may be
         * set with g_action_change_state().  This call takes a #GVariant.  The
         * correct type for the state is determined by a static state type
         * (which is given at construction time).
         *
         * The state may have a hint associated with it, specifying its valid
         * range.
         *
         * #GAction is merely the interface to the concept of an action, as
         * described above.  Various implementations of actions exist, including
         * #GSimpleAction.
         *
         * In all cases, the implementing class is responsible for storing the
         * name of the action, the parameter type, the enabled state, the
         * optional state type and the state and emitting the appropriate
         * signals when these change.  The implementor is responsible for filtering
         * calls to g_action_activate() and g_action_change_state() for type
         * safety and for the state being enabled.
         *
         * Probably the only useful thing to do with a #GAction is to put it
         * inside of a #GSimpleActionGroup.
         */
        export interface ActionNamespace {
            $gtype: GObject.GType<Action>;
            prototype: ActionPrototype;

            /**
             * Checks if `action_name `is valid.
             *
             * `action_name `is valid if it consists only of alphanumeric characters,
             * plus '-' and '.'.  The empty string is not a valid action name.
             *
             * It is an error to call this function with a non-utf8 `action_name.`
             * `action_name `must not be %NULL.
             */
            name_is_valid(action_name: string): boolean;
            /**
             * Parses a detailed action name into its separate name and target
             * components.
             *
             * Detailed action names can have three formats.
             *
             * The first format is used to represent an action name with no target
             * value and consists of just an action name containing no whitespace
             * nor the characters `:`, `(` or `)`.  For example: `app.action`.
             *
             * The second format is used to represent an action with a target value
             * that is a non-empty string consisting only of alphanumerics, plus `-`
             * and `.`.  In that case, the action name and target value are
             * separated by a double colon (`::`).  For example:
             * `app.action::target`.
             *
             * The third format is used to represent an action with any type of
             * target value, including strings.  The target value follows the action
             * name, surrounded in parens.  For example: `app.action(42)`.  The
             * target value is parsed using g_variant_parse().  If a tuple-typed
             * value is desired, it must be specified in the same way, resulting in
             * two sets of parens, for example: `app.action((1,2,3))`.  A string
             * target can be specified this way as well: `app.action('target')`.
             * For strings, this third format must be used if target value is
             * empty or contains characters other than alphanumerics, `-` and `.`.
             *
             * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
             * in `action_name `(if a pointer is passed in). A %NULL value may still be
             * returned in target_value, as the `detailed_name `may not contain a target.
             *
             * If returned, the #GVariant in `target_value `is guaranteed to not be floating.
             */
            parse_detailed_name(detailed_name: string): [boolean, string, GLib.Variant | null];
            /**
             * Formats a detailed action name from `action_name `and `target_value.`
             *
             * It is an error to call this function with an invalid action name.
             *
             * This function is the opposite of g_action_parse_detailed_name().
             * It will produce a string that can be parsed back to the action_name
             * and `target_value `by that function.
             *
             * See that function for the types of strings that will be printed by
             * this function.
             */
            print_detailed_name(action_name: string, target_value?: GLib.Variant | null): string;
        }
        export type Action = ActionPrototype;
        export interface ActionPrototype extends GObject.Object {
            // Properties
            readonly enabled: boolean;
            readonly name: string;
            readonly parameter_type: GLib.VariantType;
            readonly parameterType: GLib.VariantType;
            readonly state: GLib.Variant;
            readonly state_type: GLib.VariantType;
            readonly stateType: GLib.VariantType;

            // Members

            /**
             * Activates the action.
             *
             * `parameter `must be the correct type of parameter for the action (ie:
             * the parameter type given at construction time).  If the parameter
             * type was %NULL then `parameter `must also be %NULL.
             *
             * If the `parameter `GVariant is floating, it is consumed.
             */
            activate(parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of `action `to be changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_get_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_get_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_state(value: GLib.Variant): void;
            /**
             * Checks if `action `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_enabled(): boolean;
            /**
             * Queries the name of `action.`
             */
            get_name(): string;
            /**
             * Queries the type of the parameter that must be given when activating
             * `action.`
             *
             * When activating the action using g_action_activate(), the #GVariant
             * given to that function must be of the type returned by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             */
            get_parameter_type(): GLib.VariantType | null;
            /**
             * Queries the current state of `action.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_get_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_state(): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of
             * `action.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_state_hint(): GLib.Variant | null;
            /**
             * Queries the type of the state of `action.`
             *
             * If the action is stateful (e.g. created with
             * g_simple_action_new_stateful()) then this function returns the
             * #GVariantType of the state.  This is the type of the initial value
             * given as the state. All calls to g_action_change_state() must give a
             * #GVariant of this type and g_action_get_state() will return a
             * #GVariant of the same type.
             *
             * If the action is not stateful (e.g. created with g_simple_action_new())
             * then this function will return %NULL. In that case, g_action_get_state()
             * will return %NULL and you must not call g_action_change_state().
             */
            get_state_type(): GLib.VariantType | null;
            /**
             * Activates the action.
             *
             * `parameter `must be the correct type of parameter for the action (ie:
             * the parameter type given at construction time).  If the parameter
             * type was %NULL then `parameter `must also be %NULL.
             *
             * If the `parameter `GVariant is floating, it is consumed.
             */
            vfunc_activate(parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of `action `to be changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_get_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_get_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_state(value: GLib.Variant): void;
            /**
             * Checks if `action `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_enabled(): boolean;
            /**
             * Queries the name of `action.`
             */
            vfunc_get_name(): string;
            /**
             * Queries the type of the parameter that must be given when activating
             * `action.`
             *
             * When activating the action using g_action_activate(), the #GVariant
             * given to that function must be of the type returned by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             */
            vfunc_get_parameter_type(): GLib.VariantType | null;
            /**
             * Queries the current state of `action.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_get_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_state(): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of
             * `action.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_state_hint(): GLib.Variant | null;
            /**
             * Queries the type of the state of `action.`
             *
             * If the action is stateful (e.g. created with
             * g_simple_action_new_stateful()) then this function returns the
             * #GVariantType of the state.  This is the type of the initial value
             * given as the state. All calls to g_action_change_state() must give a
             * #GVariant of this type and g_action_get_state() will return a
             * #GVariant of the same type.
             *
             * If the action is not stateful (e.g. created with g_simple_action_new())
             * then this function will return %NULL. In that case, g_action_get_state()
             * will return %NULL and you must not call g_action_change_state().
             */
            vfunc_get_state_type(): GLib.VariantType | null;
        }

        export const Action: ActionNamespace;

        /**
         * #GActionGroup represents a group of actions. Actions can be used to
         * expose functionality in a structured way, either from one part of a
         * program to another, or to the outside world. Action groups are often
         * used together with a #GMenuModel that provides additional
         * representation data for displaying the actions to the user, e.g. in
         * a menu.
         *
         * The main way to interact with the actions in a GActionGroup is to
         * activate them with g_action_group_activate_action(). Activating an
         * action may require a #GVariant parameter. The required type of the
         * parameter can be inquired with g_action_group_get_action_parameter_type().
         * Actions may be disabled, see g_action_group_get_action_enabled().
         * Activating a disabled action has no effect.
         *
         * Actions may optionally have a state in the form of a #GVariant. The
         * current state of an action can be inquired with
         * g_action_group_get_action_state(). Activating a stateful action may
         * change its state, but it is also possible to set the state by calling
         * g_action_group_change_action_state().
         *
         * As typical example, consider a text editing application which has an
         * option to change the current font to 'bold'. A good way to represent
         * this would be a stateful action, with a boolean state. Activating the
         * action would toggle the state.
         *
         * Each action in the group has a unique name (which is a string).  All
         * method calls, except g_action_group_list_actions() take the name of
         * an action as an argument.
         *
         * The #GActionGroup API is meant to be the 'public' API to the action
         * group.  The calls here are exactly the interaction that 'external
         * forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
         * with actions.  'Internal' APIs (ie: ones meant only to be accessed by
         * the action group implementation) are found on subclasses.  This is
         * why you will find - for example - g_action_group_get_action_enabled()
         * but not an equivalent set() call.
         *
         * Signals are emitted on the action group in response to state changes
         * on individual actions.
         *
         * Implementations of #GActionGroup should provide implementations for
         * the virtual functions g_action_group_list_actions() and
         * g_action_group_query_action().  The other virtual functions should
         * not be implemented - their "wrappers" are actually implemented with
         * calls to g_action_group_query_action().
         */
        export interface ActionGroupNamespace {
            $gtype: GObject.GType<ActionGroup>;
            prototype: ActionGroupPrototype;
        }
        export type ActionGroup = ActionGroupPrototype;
        export interface ActionGroupPrototype extends GObject.Object {
            // Members

            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
            /**
             * Emits the #GActionGroup::action-added signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_added(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-enabled-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
            /**
             * Emits the #GActionGroup::action-removed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_removed(action_name: string): void;
            /**
             * Emits the #GActionGroup::action-state-changed signal on `action_group.`
             *
             * This function should only be called by #GActionGroup implementations.
             */
            vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
            /**
             * Activate the named action within `action_group.`
             *
             * If the action is expecting a parameter, then the correct type of
             * parameter must be given as `parameter.`  If the action is expecting no
             * parameters then `parameter `must be %NULL.  See
             * g_action_group_get_action_parameter_type().
             *
             * If the #GActionGroup implementation supports asynchronous remote
             * activation over D-Bus, this call may return before the relevant
             * D-Bus traffic has been sent, or any replies have been received. In
             * order to block on such asynchronous activation calls,
             * g_dbus_connection_flush() should be called prior to the code, which
             * depends on the result of the action activation. Without flushing
             * the D-Bus connection, there is no guarantee that the action would
             * have been activated.
             *
             * The following code which runs in a remote app instance, shows an
             * example of a "quit" action being activated on the primary app
             * instance over D-Bus. Here g_dbus_connection_flush() is called
             * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
             * may fail to be activated on the primary instance.
             *
             * |[&lt;!-- language="C" --&gt;
             * // call "quit" action on primary instance
             * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
             *
             * // make sure the action is activated now
             * g_dbus_connection_flush (...);
             *
             * g_debug ("application has been terminated. exiting.");
             *
             * exit (0);
             * ]|
             */
            vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
            /**
             * Request for the state of the named action within `action_group `to be
             * changed to `value.`
             *
             * The action must be stateful and `value `must be of the correct type.
             * See g_action_group_get_action_state_type().
             *
             * This call merely requests a change.  The action may refuse to change
             * its state or may change its state to something other than `value.`
             * See g_action_group_get_action_state_hint().
             *
             * If the `value `GVariant is floating, it is consumed.
             */
            vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
            /**
             * Checks if the named action within `action_group `is currently enabled.
             *
             * An action must be enabled in order to be activated or in order to
             * have its state changed from outside callers.
             */
            vfunc_get_action_enabled(action_name: string): boolean;
            /**
             * Queries the type of the parameter that must be given when activating
             * the named action within `action_group.`
             *
             * When activating the action using g_action_group_activate_action(),
             * the #GVariant given to that function must be of the type returned
             * by this function.
             *
             * In the case that this function returns %NULL, you must not give any
             * #GVariant, but %NULL instead.
             *
             * The parameter type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different parameter type.
             */
            vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
            /**
             * Queries the current state of the named action within `action_group.`
             *
             * If the action is not stateful then %NULL will be returned.  If the
             * action is stateful then the type of the return value is the type
             * given by g_action_group_get_action_state_type().
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state(action_name: string): GLib.Variant | null;
            /**
             * Requests a hint about the valid range of values for the state of the
             * named action within `action_group.`
             *
             * If %NULL is returned it either means that the action is not stateful
             * or that there is no hint about the valid range of values for the
             * state of the action.
             *
             * If a #GVariant array is returned then each item in the array is a
             * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
             * returned then the tuple specifies the inclusive lower and upper bound
             * of valid values for the state.
             *
             * In any case, the information is merely a hint.  It may be possible to
             * have a state value outside of the hinted range and setting a value
             * within the range may fail.
             *
             * The return value (if non-%NULL) should be freed with
             * g_variant_unref() when it is no longer required.
             */
            vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
            /**
             * Queries the type of the state of the named action within
             * `action_group.`
             *
             * If the action is stateful then this function returns the
             * #GVariantType of the state.  All calls to
             * g_action_group_change_action_state() must give a #GVariant of this
             * type and g_action_group_get_action_state() will return a #GVariant
             * of the same type.
             *
             * If the action is not stateful then this function will return %NULL.
             * In that case, g_action_group_get_action_state() will return %NULL
             * and you must not call g_action_group_change_action_state().
             *
             * The state type of a particular action will never change but it is
             * possible for an action to be removed and for a new action to be added
             * with the same name but a different state type.
             */
            vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
            /**
             * Checks if the named action exists within `action_group.`
             */
            vfunc_has_action(action_name: string): boolean;
            /**
             * Lists the actions contained within `action_group.`
             *
             * The caller is responsible for freeing the list with g_strfreev() when
             * it is no longer required.
             */
            vfunc_list_actions(): string[];
            /**
             * Queries all aspects of the named action within an `action_group.`
             *
             * This function acquires the information available from
             * g_action_group_has_action(), g_action_group_get_action_enabled(),
             * g_action_group_get_action_parameter_type(),
             * g_action_group_get_action_state_type(),
             * g_action_group_get_action_state_hint() and
             * g_action_group_get_action_state() with a single function call.
             *
             * This provides two main benefits.
             *
             * The first is the improvement in efficiency that comes with not having
             * to perform repeated lookups of the action in order to discover
             * different things about it.  The second is that implementing
             * #GActionGroup can now be done by only overriding this one virtual
             * function.
             *
             * The interface provides a default implementation of this function that
             * calls the individual functions, as required, to fetch the
             * information.  The interface also provides default implementations of
             * those functions that call this function.  All implementations,
             * therefore, must override either this function or all of the others.
             *
             * If the action exists, %TRUE is returned and any of the requested
             * fields (as indicated by having a non-%NULL reference passed in) are
             * filled.  If the action doesn't exist, %FALSE is returned and the
             * fields may or may not have been modified.
             */
            vfunc_query_action(
                action_name: string
            ): [
                boolean,
                boolean,
                GLib.VariantType | null,
                GLib.VariantType | null,
                GLib.Variant | null,
                GLib.Variant | null
            ];
        }

        export const ActionGroup: ActionGroupNamespace;

        /**
         * The GActionMap interface is implemented by #GActionGroup
         * implementations that operate by containing a number of
         * named #GAction instances, such as #GSimpleActionGroup.
         *
         * One useful application of this interface is to map the
         * names of actions from various action groups to unique,
         * prefixed names (e.g. by prepending "app." or "win.").
         * This is the motivation for the 'Map' part of the interface
         * name.
         */
        export interface ActionMapNamespace {
            $gtype: GObject.GType<ActionMap>;
            prototype: ActionMapPrototype;
        }
        export type ActionMap = ActionMapPrototype;
        export interface ActionMapPrototype extends GObject.Object {
            // Members

            /**
             * Adds an action to the `action_map.`
             *
             * If the action map already contains an action with the same name
             * as `action `then the old action is dropped from the action map.
             *
             * The action map takes its own reference on `action.`
             */
            add_action(action: Action): void;
            /**
             * A convenience function for creating multiple #GSimpleAction instances
             * and adding them to a #GActionMap.
             *
             * Each action is constructed as per one #GActionEntry.
             *
             * |[&lt;!-- language="C" --&gt;
             * static void
             * activate_quit (GSimpleAction *simple,
             * GVariant      *parameter,
             * gpointer       user_data)
             * {
             * exit (0);
             * }
             *
             * static void
             * activate_print_string (GSimpleAction *simple,
             * GVariant      *parameter,
             * gpointer       user_data)
             * {
             * g_print ("%s\n", g_variant_get_string (parameter, NULL));
             * }
             *
             * static GActionGroup *
             * create_action_group (void)
             * {
             * const GActionEntry entries[] = {
             * { "quit",         activate_quit              },
             * { "print-string", activate_print_string, "s" }
             * };
             * GSimpleActionGroup *group;
             *
             * group = g_simple_action_group_new ();
             * g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
             *
             * return G_ACTION_GROUP (group);
             * }
             * ]|
             */
            add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
            /**
             * Looks up the action with the name `action_name `in `action_map.`
             *
             * If no such action exists, returns %NULL.
             */
            lookup_action(action_name: string): Action | null;
            /**
             * Removes the named action from the action map.
             *
             * If no action of this name is in the map then nothing happens.
             */
            remove_action(action_name: string): void;
            /**
             * Adds an action to the `action_map.`
             *
             * If the action map already contains an action with the same name
             * as `action `then the old action is dropped from the action map.
             *
             * The action map takes its own reference on `action.`
             */
            vfunc_add_action(action: Action): void;
            /**
             * Looks up the action with the name `action_name `in `action_map.`
             *
             * If no such action exists, returns %NULL.
             */
            vfunc_lookup_action(action_name: string): Action | null;
            /**
             * Removes the named action from the action map.
             *
             * If no action of this name is in the map then nothing happens.
             */
            vfunc_remove_action(action_name: string): void;
        }

        export const ActionMap: ActionMapNamespace;

        /**
         * #GAppInfo and #GAppLaunchContext are used for describing and launching
         * applications installed on the system.
         *
         * As of GLib 2.20, URIs will always be converted to POSIX paths
         * (using g_file_get_path()) when using g_app_info_launch() even if
         * the application requested an URI and not a POSIX path. For example
         * for a desktop-file based application with Exec key `totem
         * %U` and a single URI, `sftp://foo/file.avi`, then
         * `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will
         * only work if a set of suitable GIO extensions (such as gvfs 2.26
         * compiled with FUSE support), is available and operational; if this
         * is not the case, the URI will be passed unmodified to the application.
         * Some URIs, such as `mailto:`, of course cannot be mapped to a POSIX
         * path (in gvfs there's no FUSE mount for it); such URIs will be
         * passed unmodified to the application.
         *
         * Specifically for gvfs 2.26 and later, the POSIX URI will be mapped
         * back to the GIO URI in the #GFile constructors (since gvfs
         * implements the #GVfs extension point). As such, if the application
         * needs to examine the URI, it needs to use g_file_get_uri() or
         * similar on #GFile. In other words, an application cannot assume
         * that the URI passed to e.g. g_file_new_for_commandline_arg() is
         * equal to the result of g_file_get_uri(). The following snippet
         * illustrates this:
         *
         * |[
         * GFile *f;
         * char *uri;
         *
         * file = g_file_new_for_commandline_arg (uri_from_commandline);
         *
         * uri = g_file_get_uri (file);
         * strcmp (uri, uri_from_commandline) == 0;
         * g_free (uri);
         *
         * if (g_file_has_uri_scheme (file, "cdda"))
         * {
         * // do something special with uri
         * }
         * g_object_unref (file);
         * ]|
         *
         * This code will work when both `cdda://sr0/Track 1.wav` and
         * `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
         * application. It should be noted that it's generally not safe
         * for applications to rely on the format of a particular URIs.
         * Different launcher applications (e.g. file managers) may have
         * different ideas of what a given URI means.
         */
        export interface AppInfoNamespace {
            $gtype: GObject.GType<AppInfo>;
            prototype: AppInfoPrototype;

            /**
             * Creates a new #GAppInfo from the given information.
             *
             * Note that for commandline, the quoting rules of the Exec key of the
             * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
             * are applied. For example, if the `commandline `contains
             * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
             * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
             */
            create_from_commandline(
                commandline: string,
                application_name: string | null,
                flags: AppInfoCreateFlags
            ): AppInfo;
            /**
             * Gets a list of all of the applications currently registered
             * on this system.
             *
             * For desktop files, this includes applications that have
             * `NoDisplay=true` set or are excluded from display by means
             * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
             * The returned list does not include applications which have
             * the `Hidden` key set.
             */
            get_all(): AppInfo[];
            /**
             * Gets a list of all #GAppInfos for a given content type,
             * including the recommended and fallback #GAppInfos. See
             * g_app_info_get_recommended_for_type() and
             * g_app_info_get_fallback_for_type().
             */
            get_all_for_type(content_type: string): AppInfo[];
            /**
             * Gets the default #GAppInfo for a given content type.
             */
            get_default_for_type(content_type: string, must_support_uris: boolean): AppInfo | null;
            /**
             * Asynchronously gets the default #GAppInfo for a given content type.
             */
            get_default_for_type_async(
                content_type: string,
                must_support_uris: boolean,
                cancellable?: Cancellable | null
            ): Promise<AppInfo>;
            /**
             * Asynchronously gets the default #GAppInfo for a given content type.
             */
            get_default_for_type_async(
                content_type: string,
                must_support_uris: boolean,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<AppInfo> | null
            ): void;
            /**
             * Asynchronously gets the default #GAppInfo for a given content type.
             */
            get_default_for_type_async(
                content_type: string,
                must_support_uris: boolean,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<AppInfo> | null
            ): Promise<AppInfo> | void;
            /**
             * Finishes a default #GAppInfo lookup started by
             * g_app_info_get_default_for_type_async().
             *
             * If no #GAppInfo is found, then `error `will be set to %G_IO_ERROR_NOT_FOUND.
             */
            get_default_for_type_finish(result: AsyncResult): AppInfo;
            /**
             * Gets the default application for handling URIs with
             * the given URI scheme. A URI scheme is the initial part
             * of the URI, up to but not including the ':', e.g. "http",
             * "ftp" or "sip".
             */
            get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
            /**
             * Asynchronously gets the default application for handling URIs with
             * the given URI scheme. A URI scheme is the initial part
             * of the URI, up to but not including the ':', e.g. "http",
             * "ftp" or "sip".
             */
            get_default_for_uri_scheme_async(uri_scheme: string, cancellable?: Cancellable | null): Promise<AppInfo>;
            /**
             * Asynchronously gets the default application for handling URIs with
             * the given URI scheme. A URI scheme is the initial part
             * of the URI, up to but not including the ':', e.g. "http",
             * "ftp" or "sip".
             */
            get_default_for_uri_scheme_async(
                uri_scheme: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<AppInfo> | null
            ): void;
            /**
             * Asynchronously gets the default application for handling URIs with
             * the given URI scheme. A URI scheme is the initial part
             * of the URI, up to but not including the ':', e.g. "http",
             * "ftp" or "sip".
             */
            get_default_for_uri_scheme_async(
                uri_scheme: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<AppInfo> | null
            ): Promise<AppInfo> | void;
            /**
             * Finishes a default #GAppInfo lookup started by
             * g_app_info_get_default_for_uri_scheme_async().
             *
             * If no #GAppInfo is found, then `error `will be set to %G_IO_ERROR_NOT_FOUND.
             */
            get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo;
            /**
             * Gets a list of fallback #GAppInfos for a given content type, i.e.
             * those applications which claim to support the given content type
             * by MIME type subclassing and not directly.
             */
            get_fallback_for_type(content_type: string): AppInfo[];
            /**
             * Gets a list of recommended #GAppInfos for a given content type, i.e.
             * those applications which claim to support the given content type exactly,
             * and not by MIME type subclassing.
             * Note that the first application of the list is the last used one, i.e.
             * the last one for which g_app_info_set_as_last_used_for_type() has been
             * called.
             */
            get_recommended_for_type(content_type: string): AppInfo[];
            /**
             * Utility function that launches the default application
             * registered to handle the specified uri. Synchronous I/O
             * is done on the uri to detect the type of the file if
             * required.
             *
             * The D-Bus–activated applications don't have to be started if your application
             * terminates too soon after this function. To prevent this, use
             * g_app_info_launch_default_for_uri_async() instead.
             */
            launch_default_for_uri(uri: string, context?: AppLaunchContext | null): boolean;
            /**
             * Async version of g_app_info_launch_default_for_uri().
             *
             * This version is useful if you are interested in receiving
             * error information in the case where the application is
             * sandboxed and the portal may present an application chooser
             * dialog to the user.
             *
             * This is also useful if you want to be sure that the D-Bus–activated
             * applications are really started before termination and if you are interested
             * in receiving error information from their activation.
             */
            launch_default_for_uri_async(
                uri: string,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Async version of g_app_info_launch_default_for_uri().
             *
             * This version is useful if you are interested in receiving
             * error information in the case where the application is
             * sandboxed and the portal may present an application chooser
             * dialog to the user.
             *
             * This is also useful if you want to be sure that the D-Bus–activated
             * applications are really started before termination and if you are interested
             * in receiving error information from their activation.
             */
            launch_default_for_uri_async(
                uri: string,
                context: AppLaunchContext | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<AppInfo> | null
            ): void;
            /**
             * Async version of g_app_info_launch_default_for_uri().
             *
             * This version is useful if you are interested in receiving
             * error information in the case where the application is
             * sandboxed and the portal may present an application chooser
             * dialog to the user.
             *
             * This is also useful if you want to be sure that the D-Bus–activated
             * applications are really started before termination and if you are interested
             * in receiving error information from their activation.
             */
            launch_default_for_uri_async(
                uri: string,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<AppInfo> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous launch-default-for-uri operation.
             */
            launch_default_for_uri_finish(result: AsyncResult): boolean;
            /**
             * Removes all changes to the type associations done by
             * g_app_info_set_as_default_for_type(),
             * g_app_info_set_as_default_for_extension(),
             * g_app_info_add_supports_type() or
             * g_app_info_remove_supports_type().
             */
            reset_type_associations(content_type: string): void;
        }
        export type AppInfo = AppInfoPrototype;
        export interface AppInfoPrototype extends GObject.Object {
            // Members

            /**
             * Adds a content type to the application information to indicate the
             * application is capable of opening files with the given content type.
             */
            add_supports_type(content_type: string): boolean;
            /**
             * Obtains the information whether the #GAppInfo can be deleted.
             * See g_app_info_delete().
             */
            can_delete(): boolean;
            /**
             * Checks if a supported content type can be removed from an application.
             */
            can_remove_supports_type(): boolean;
            /**
             * Tries to delete a #GAppInfo.
             *
             * On some platforms, there may be a difference between user-defined
             * #GAppInfos which can be deleted, and system-wide ones which cannot.
             * See g_app_info_can_delete().
             */
            ["delete"](): boolean;
            /**
             * Creates a duplicate of a #GAppInfo.
             */
            dup(): AppInfo;
            /**
             * Checks if two #GAppInfos are equal.
             *
             * Note that the check *may not* compare each individual
             * field, and only does an identity check. In case detecting changes in the
             * contents is needed, program code must additionally compare relevant fields.
             */
            equal(appinfo2: AppInfo): boolean;
            /**
             * Gets the commandline with which the application will be
             * started.
             */
            get_commandline(): string | null;
            /**
             * Gets a human-readable description of an installed application.
             */
            get_description(): string | null;
            /**
             * Gets the display name of the application. The display name is often more
             * descriptive to the user than the name itself.
             */
            get_display_name(): string;
            /**
             * Gets the executable's name for the installed application.
             *
             * This is intended to be used for debugging or labelling what program is going
             * to be run. To launch the executable, use g_app_info_launch() and related
             * functions, rather than spawning the return value from this function.
             */
            get_executable(): string;
            /**
             * Gets the icon for the application.
             */
            get_icon(): Icon | null;
            /**
             * Gets the ID of an application. An id is a string that
             * identifies the application. The exact format of the id is
             * platform dependent. For instance, on Unix this is the
             * desktop file id from the xdg menu specification.
             *
             * Note that the returned ID may be %NULL, depending on how
             * the `appinfo `has been constructed.
             */
            get_id(): string | null;
            /**
             * Gets the installed name of the application.
             */
            get_name(): string;
            /**
             * Retrieves the list of content types that `app_info `claims to support.
             * If this information is not provided by the environment, this function
             * will return %NULL.
             * This function does not take in consideration associations added with
             * g_app_info_add_supports_type(), but only those exported directly by
             * the application.
             */
            get_supported_types(): string[];
            /**
             * Launches the application. Passes `files `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly.
             *
             * To launch the application without arguments pass a %NULL `files `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             *
             * Some URIs can be changed when passed through a GFile (for instance
             * unsupported URIs with strange formats like mailto:), so if you have
             * a textual URI you want to pass in as argument, consider using
             * g_app_info_launch_uris() instead.
             *
             * The launched application inherits the environment of the launching
             * process, but it can be modified with g_app_launch_context_setenv()
             * and g_app_launch_context_unsetenv().
             *
             * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
             * environment variable with the path of the launched desktop file and
             * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
             * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
             * should it be inherited by further processes. The `DISPLAY`,
             * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
             * variables are also set, based on information provided in `context.`
             */
            launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Launches the application. This passes the `uris `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly. If the application only supports
             * one URI per invocation as part of their command-line, multiple instances
             * of the application will be spawned.
             *
             * To launch the application without arguments pass a %NULL `uris `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             */
            launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            launch_uris_async(
                uris: string[] | null,
                context: AppLaunchContext | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a g_app_info_launch_uris_async() operation.
             */
            launch_uris_finish(result: AsyncResult): boolean;
            /**
             * Removes a supported type from an application, if possible.
             */
            remove_supports_type(content_type: string): boolean;
            /**
             * Sets the application as the default handler for the given file extension.
             */
            set_as_default_for_extension(extension: string): boolean;
            /**
             * Sets the application as the default handler for a given type.
             */
            set_as_default_for_type(content_type: string): boolean;
            /**
             * Sets the application as the last used application for a given type.
             * This will make the application appear as first in the list returned
             * by g_app_info_get_recommended_for_type(), regardless of the default
             * application for that content type.
             */
            set_as_last_used_for_type(content_type: string): boolean;
            /**
             * Checks if the application info should be shown in menus that
             * list available applications.
             */
            should_show(): boolean;
            /**
             * Checks if the application accepts files as arguments.
             */
            supports_files(): boolean;
            /**
             * Checks if the application supports reading files and directories from URIs.
             */
            supports_uris(): boolean;
            /**
             * Adds a content type to the application information to indicate the
             * application is capable of opening files with the given content type.
             */
            vfunc_add_supports_type(content_type: string): boolean;
            /**
             * Obtains the information whether the #GAppInfo can be deleted.
             * See g_app_info_delete().
             */
            vfunc_can_delete(): boolean;
            /**
             * Checks if a supported content type can be removed from an application.
             */
            vfunc_can_remove_supports_type(): boolean;
            /**
             * Tries to delete a #GAppInfo.
             *
             * On some platforms, there may be a difference between user-defined
             * #GAppInfos which can be deleted, and system-wide ones which cannot.
             * See g_app_info_can_delete().
             */
            vfunc_do_delete(): boolean;
            /**
             * Creates a duplicate of a #GAppInfo.
             */
            vfunc_dup(): AppInfo;
            /**
             * Checks if two #GAppInfos are equal.
             *
             * Note that the check *may not* compare each individual
             * field, and only does an identity check. In case detecting changes in the
             * contents is needed, program code must additionally compare relevant fields.
             */
            vfunc_equal(appinfo2: AppInfo): boolean;
            /**
             * Gets the commandline with which the application will be
             * started.
             */
            vfunc_get_commandline(): string | null;
            /**
             * Gets a human-readable description of an installed application.
             */
            vfunc_get_description(): string | null;
            /**
             * Gets the display name of the application. The display name is often more
             * descriptive to the user than the name itself.
             */
            vfunc_get_display_name(): string;
            /**
             * Gets the executable's name for the installed application.
             *
             * This is intended to be used for debugging or labelling what program is going
             * to be run. To launch the executable, use g_app_info_launch() and related
             * functions, rather than spawning the return value from this function.
             */
            vfunc_get_executable(): string;
            /**
             * Gets the icon for the application.
             */
            vfunc_get_icon(): Icon | null;
            /**
             * Gets the ID of an application. An id is a string that
             * identifies the application. The exact format of the id is
             * platform dependent. For instance, on Unix this is the
             * desktop file id from the xdg menu specification.
             *
             * Note that the returned ID may be %NULL, depending on how
             * the `appinfo `has been constructed.
             */
            vfunc_get_id(): string | null;
            /**
             * Gets the installed name of the application.
             */
            vfunc_get_name(): string;
            /**
             * Retrieves the list of content types that `app_info `claims to support.
             * If this information is not provided by the environment, this function
             * will return %NULL.
             * This function does not take in consideration associations added with
             * g_app_info_add_supports_type(), but only those exported directly by
             * the application.
             */
            vfunc_get_supported_types(): string[];
            /**
             * Launches the application. Passes `files `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly.
             *
             * To launch the application without arguments pass a %NULL `files `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             *
             * Some URIs can be changed when passed through a GFile (for instance
             * unsupported URIs with strange formats like mailto:), so if you have
             * a textual URI you want to pass in as argument, consider using
             * g_app_info_launch_uris() instead.
             *
             * The launched application inherits the environment of the launching
             * process, but it can be modified with g_app_launch_context_setenv()
             * and g_app_launch_context_unsetenv().
             *
             * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
             * environment variable with the path of the launched desktop file and
             * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
             * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
             * should it be inherited by further processes. The `DISPLAY`,
             * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
             * variables are also set, based on information provided in `context.`
             */
            vfunc_launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Launches the application. This passes the `uris `to the launched application
             * as arguments, using the optional `context `to get information
             * about the details of the launcher (like what screen it is on).
             * On error, `error `will be set accordingly. If the application only supports
             * one URI per invocation as part of their command-line, multiple instances
             * of the application will be spawned.
             *
             * To launch the application without arguments pass a %NULL `uris `list.
             *
             * Note that even if the launch is successful the application launched
             * can fail to start if it runs into problems during startup. There is
             * no way to detect this.
             */
            vfunc_launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            vfunc_launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            vfunc_launch_uris_async(
                uris: string[] | null,
                context: AppLaunchContext | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Async version of g_app_info_launch_uris().
             *
             * The `callback `is invoked immediately after the application launch, but it
             * waits for activation in case of D-Bus–activated applications and also provides
             * extended error information for sandboxed applications, see notes for
             * g_app_info_launch_default_for_uri_async().
             */
            vfunc_launch_uris_async(
                uris?: string[] | null,
                context?: AppLaunchContext | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a g_app_info_launch_uris_async() operation.
             */
            vfunc_launch_uris_finish(result: AsyncResult): boolean;
            /**
             * Removes a supported type from an application, if possible.
             */
            vfunc_remove_supports_type(content_type: string): boolean;
            /**
             * Sets the application as the default handler for the given file extension.
             */
            vfunc_set_as_default_for_extension(extension: string): boolean;
            /**
             * Sets the application as the default handler for a given type.
             */
            vfunc_set_as_default_for_type(content_type: string): boolean;
            /**
             * Sets the application as the last used application for a given type.
             * This will make the application appear as first in the list returned
             * by g_app_info_get_recommended_for_type(), regardless of the default
             * application for that content type.
             */
            vfunc_set_as_last_used_for_type(content_type: string): boolean;
            /**
             * Checks if the application info should be shown in menus that
             * list available applications.
             */
            vfunc_should_show(): boolean;
            /**
             * Checks if the application accepts files as arguments.
             */
            vfunc_supports_files(): boolean;
            /**
             * Checks if the application supports reading files and directories from URIs.
             */
            vfunc_supports_uris(): boolean;
        }

        export const AppInfo: AppInfoNamespace;

        /**
         * This is the asynchronous version of #GInitable; it behaves the same
         * in all ways except that initialization is asynchronous. For more details
         * see the descriptions on #GInitable.
         *
         * A class may implement both the #GInitable and #GAsyncInitable interfaces.
         *
         * Users of objects implementing this are not intended to use the interface
         * method directly; instead it will be used automatically in various ways.
         * For C applications you generally just call g_async_initable_new_async()
         * directly, or indirectly via a foo_thing_new_async() wrapper. This will call
         * g_async_initable_init_async() under the cover, calling back with %NULL and
         * a set %GError on failure.
         *
         * A typical implementation might look something like this:
         *
         * |[&lt;!-- language="C" --&gt;
         * enum {
         * NOT_INITIALIZED,
         * INITIALIZING,
         * INITIALIZED
         * };
         *
         * static void
         * _foo_ready_cb (Foo *self)
         * {
         * GList *l;
         *
         * self-&gt;priv-&gt;state = INITIALIZED;
         *
         * for (l = self-&gt;priv-&gt;init_results; l != NULL; l = l-&gt;next)
         * {
         * GTask *task = l-&gt;data;
         *
         * if (self-&gt;priv-&gt;success)
         * g_task_return_boolean (task, TRUE);
         * else
         * g_task_return_new_error (task, ...);
         * g_object_unref (task);
         * }
         *
         * g_list_free (self-&gt;priv-&gt;init_results);
         * self-&gt;priv-&gt;init_results = NULL;
         * }
         *
         * static void
         * foo_init_async (GAsyncInitable       *initable,
         * int                   io_priority,
         * GCancellable         *cancellable,
         * GAsyncReadyCallback   callback,
         * gpointer              user_data)
         * {
         * Foo *self = FOO (initable);
         * GTask *task;
         *
         * task = g_task_new (initable, cancellable, callback, user_data);
         * g_task_set_name (task, G_STRFUNC);
         *
         * switch (self-&gt;priv-&gt;state)
         * {
         * case NOT_INITIALIZED:
         * _foo_get_ready (self);
         * self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
         * task);
         * self-&gt;priv-&gt;state = INITIALIZING;
         * break;
         * case INITIALIZING:
         * self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
         * task);
         * break;
         * case INITIALIZED:
         * if (!self-&gt;priv-&gt;success)
         * g_task_return_new_error (task, ...);
         * else
         * g_task_return_boolean (task, TRUE);
         * g_object_unref (task);
         * break;
         * }
         * }
         *
         * static gboolean
         * foo_init_finish (GAsyncInitable       *initable,
         * GAsyncResult         *result,
         * GError              **error)
         * {
         * g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
         *
         * return g_task_propagate_boolean (G_TASK (result), error);
         * }
         *
         * static void
         * foo_async_initable_iface_init (gpointer g_iface,
         * gpointer data)
         * {
         * GAsyncInitableIface *iface = g_iface;
         *
         * iface-&gt;init_async = foo_init_async;
         * iface-&gt;init_finish = foo_init_finish;
         * }
         * ]|
         */
        export interface AsyncInitableNamespace {
            $gtype: GObject.GType<AsyncInitable>;
            prototype: AsyncInitablePrototype;

            /**
             * Helper function for constructing #GAsyncInitable object. This is
             * similar to g_object_newv() but also initializes the object asynchronously.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_new_finish() to get the new object and check
             * for any errors.
             */
            newv_async(
                object_type: GObject.GType,
                n_parameters: number,
                parameters: GObject.Parameter,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<AsyncInitable> | null
            ): void;
        }
        export type AsyncInitable<A extends GObject.Object = GObject.Object> = AsyncInitablePrototype<A>;
        export interface AsyncInitablePrototype<A extends GObject.Object = GObject.Object> extends GObject.Object {
            // Members

            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            init_finish(res: AsyncResult): boolean;
            /**
             * Finishes the async construction for the various g_async_initable_new
             * calls, returning the created object or %NULL on error.
             */
            new_finish(res: AsyncResult): A;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts asynchronous initialization of the object implementing the
             * interface. This must be done before any real use of the object after
             * initial construction. If the object also implements #GInitable you can
             * optionally call g_initable_init() instead.
             *
             * This method is intended for language bindings. If writing in C,
             * g_async_initable_new_async() should typically be used instead.
             *
             * When the initialization is finished, `callback `will be called. You can
             * then call g_async_initable_init_finish() to get the result of the
             * initialization.
             *
             * Implementations may also support cancellation. If `cancellable `is not
             * %NULL, then initialization can be cancelled by triggering the cancellable
             * object from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL, and
             * the object doesn't support cancellable initialization, the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * As with #GInitable, if the object is not initialized, or initialization
             * returns with an error, then all operations on the object except
             * g_object_ref() and g_object_unref() are considered to be invalid, and
             * have undefined behaviour. They will often fail with g_critical() or
             * g_warning(), but this must not be relied on.
             *
             * Callers should not assume that a class which implements #GAsyncInitable can
             * be initialized multiple times; for more information, see g_initable_init().
             * If a class explicitly supports being initialized multiple times,
             * implementation requires yielding all subsequent calls to init_async() on the
             * results of the first call.
             *
             * For classes that also support the #GInitable interface, the default
             * implementation of this method will run the g_initable_init() function
             * in a thread, so if you want to support asynchronous initialization via
             * threads, just implement the #GAsyncInitable interface without overriding
             * any interface methods.
             */
            vfunc_init_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes asynchronous initialization and returns the result.
             * See g_async_initable_init_async().
             */
            vfunc_init_finish(res: AsyncResult): boolean;
        }

        export const AsyncInitable: AsyncInitableNamespace;

        /**
         * Provides a base class for implementing asynchronous function results.
         *
         * Asynchronous operations are broken up into two separate operations
         * which are chained together by a #GAsyncReadyCallback. To begin
         * an asynchronous operation, provide a #GAsyncReadyCallback to the
         * asynchronous function. This callback will be triggered when the
         * operation has completed, and must be run in a later iteration of
         * the [thread-default main context][g-main-context-push-thread-default]
         * from where the operation was initiated. It will be passed a
         * #GAsyncResult instance filled with the details of the operation's
         * success or failure, the object the asynchronous function was
         * started for and any error codes returned. The asynchronous callback
         * function is then expected to call the corresponding "_finish()"
         * function, passing the object the function was called for, the
         * #GAsyncResult instance, and (optionally) an `error `to grab any
         * error conditions that may have occurred.
         *
         * The "_finish()" function for an operation takes the generic result
         * (of type #GAsyncResult) and returns the specific result that the
         * operation in question yields (e.g. a #GFileEnumerator for a
         * "enumerate children" operation). If the result or error status of the
         * operation is not needed, there is no need to call the "_finish()"
         * function; GIO will take care of cleaning up the result and error
         * information after the #GAsyncReadyCallback returns. You can pass
         * %NULL for the #GAsyncReadyCallback if you don't need to take any
         * action at all after the operation completes. Applications may also
         * take a reference to the #GAsyncResult and call "_finish()" later;
         * however, the "_finish()" function may be called at most once.
         *
         * Example of a typical asynchronous operation flow:
         * |[&lt;!-- language="C" --&gt;
         * void _theoretical_frobnitz_async (Theoretical         *t,
         * GCancellable        *c,
         * GAsyncReadyCallback  cb,
         * gpointer             u);
         *
         * gboolean _theoretical_frobnitz_finish (Theoretical   *t,
         * GAsyncResult  *res,
         * GError       **e);
         *
         * static void
         * frobnitz_result_func (GObject      *source_object,
         * GAsyncResult *res,
         * gpointer      user_data)
         * {
         * gboolean success = FALSE;
         *
         * success = _theoretical_frobnitz_finish (source_object, res, NULL);
         *
         * if (success)
         * g_printf ("Hurray!\n");
         * else
         * g_printf ("Uh oh!\n");
         *
         * ...
         *
         * }
         *
         * int main (int argc, void *argv[])
         * {
         * ...
         *
         * _theoretical_frobnitz_async (theoretical_data,
         * NULL,
         * frobnitz_result_func,
         * NULL);
         *
         * ...
         * }
         * ]|
         *
         * The callback for an asynchronous operation is called only once, and is
         * always called, even in the case of a cancelled operation. On cancellation
         * the result is a %G_IO_ERROR_CANCELLED error.
         *
         * ## I/O Priority # {#io-priority}
         *
         * Many I/O-related asynchronous operations have a priority parameter,
         * which is used in certain cases to determine the order in which
         * operations are executed. They are not used to determine system-wide
         * I/O scheduling. Priorities are integers, with lower numbers indicating
         * higher priority. It is recommended to choose priorities between
         * %G_PRIORITY_LOW and %G_PRIORITY_HIGH, with %G_PRIORITY_DEFAULT
         * as a default.
         */
        export interface AsyncResultNamespace {
            $gtype: GObject.GType<AsyncResult>;
            prototype: AsyncResultPrototype;
        }
        export type AsyncResult = AsyncResultPrototype;
        export interface AsyncResultPrototype extends GObject.Object {
            // Members

            /**
             * Gets the source object from a #GAsyncResult.
             */
            get_source_object<T = GObject.Object>(): T;
            /**
             * Gets the user data from a #GAsyncResult.
             */
            get_user_data(): any | null;
            /**
             * Checks if `res `has the given `source_tag `(generally a function
             * pointer indicating the function `res `was created by).
             */
            is_tagged(source_tag?: any | null): boolean;
            /**
             * If `res `is a #GSimpleAsyncResult, this is equivalent to
             * g_simple_async_result_propagate_error(). Otherwise it returns
             * %FALSE.
             *
             * This can be used for legacy error handling in async *_finish()
             * wrapper functions that traditionally handled #GSimpleAsyncResult
             * error returns themselves rather than calling into the virtual method.
             * This should not be used in new code; #GAsyncResult errors that are
             * set by virtual methods should also be extracted by virtual methods,
             * to enable subclasses to chain up correctly.
             */
            legacy_propagate_error(): boolean;
            /**
             * Gets the source object from a #GAsyncResult.
             */
            vfunc_get_source_object<T = GObject.Object>(): T;
            /**
             * Gets the user data from a #GAsyncResult.
             */
            vfunc_get_user_data(): any | null;
            /**
             * Checks if `res `has the given `source_tag `(generally a function
             * pointer indicating the function `res `was created by).
             */
            vfunc_is_tagged(source_tag?: any | null): boolean;
        }

        export const AsyncResult: AsyncResultNamespace;

        /**
         * #GConverter is implemented by objects that convert
         * binary data in various ways. The conversion can be
         * stateful and may fail at any place.
         *
         * Some example conversions are: character set conversion,
         * compression, decompression and regular expression
         * replace.
         */
        export interface ConverterNamespace {
            $gtype: GObject.GType<Converter>;
            prototype: ConverterPrototype;
        }
        export type Converter = ConverterPrototype;
        export interface ConverterPrototype extends GObject.Object {
            // Members

            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            convert(
                inbuf: Uint8Array | string,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            reset(): void;
            /**
             * This is the main operation used when converting data. It is to be called
             * multiple times in a loop, and each time it will do some work, i.e.
             * producing some output (in outbuf) or consuming some input (from inbuf) or
             * both. If its not possible to do any work an error is returned.
             *
             * Note that a single call may not consume all input (or any input at all).
             * Also a call may produce output even if given no input, due to state stored
             * in the converter producing output.
             *
             * If any data was either produced or consumed, and then an error happens, then
             * only the successful conversion is reported and the error is returned on the
             * next call.
             *
             * A full conversion loop involves calling this method repeatedly, each time
             * giving it new input and space output space. When there is no more input
             * data after the data in inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
             * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
             * each time until all data is consumed and all output is produced, then
             * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
             * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
             * in a decompression converter where the end of data is detectable from the
             * data (and there might even be other data after the end of the compressed data).
             *
             * When some data has successfully been converted `bytes_read `and is set to
             * the number of bytes read from inbuf, and `bytes_written `is set to indicate
             * how many bytes was written to `outbuf.` If there are more data to output
             * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
             * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
             * then %G_CONVERTER_FINISHED is returned.
             *
             * On error %G_CONVERTER_ERROR is returned and `error `is set accordingly.
             * Some errors need special handling:
             *
             * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
             * to write the resulting converted data, the application should
             * call the function again with a larger `outbuf `to continue.
             *
             * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
             * input to fully determine what the conversion should produce,
             * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
             * example with an incomplete multibyte sequence when converting text,
             * or when a regexp matches up to the end of the input (and may match
             * further input). It may also happen when `inbuf_size `is zero and
             * there is no more data to produce.
             *
             * When this happens the application should read more input and then
             * call the function again. If further input shows that there is no
             * more data call the function again with the same data but with
             * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
             * to finish as e.g. in the regexp match case (or, to fail again with
             * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
             * input is actually partial).
             *
             * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
             * converter object is in an invalid state where its not allowed
             * to call g_converter_convert() anymore. At this time you can only
             * free the object or call g_converter_reset() to reset it to the
             * initial state.
             *
             * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
             * to try to write out all internal state to the output. The application
             * has to call the function multiple times with the flag set, and when
             * the available input has been consumed and all internal state has
             * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
             * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
             * This is somewhat similar to what happens at the end of the input stream,
             * but done in the middle of the data.
             *
             * This has different meanings for different conversions. For instance
             * in a compression converter it would mean that we flush all the
             * compression state into output such that if you uncompress the
             * compressed data you get back all the input data. Doing this may
             * make the final file larger due to padding though. Another example
             * is a regexp conversion, where if you at the end of the flushed data
             * have a match, but there is also a potential longer match. In the
             * non-flushed case we would ask for more input, but when flushing we
             * treat this as the end of input and do the match.
             *
             * Flushing is not always possible (like if a charset converter flushes
             * at a partial multibyte sequence). Converters are supposed to try
             * to produce as much output as possible and then return an error
             * (typically %G_IO_ERROR_PARTIAL_INPUT).
             */
            vfunc_convert(
                inbuf: Uint8Array | null,
                outbuf: Uint8Array | string,
                flags: ConverterFlags
            ): [ConverterResult, number, number];
            /**
             * Resets all internal state in the converter, making it behave
             * as if it was just created. If the converter has any internal
             * state that would produce output then that output is lost.
             */
            vfunc_reset(): void;
        }

        export const Converter: ConverterNamespace;

        /**
         * The #GDBusInterface type is the base type for D-Bus interfaces both
         * on the service side (see #GDBusInterfaceSkeleton) and client side
         * (see #GDBusProxy).
         */
        export interface DBusInterfaceNamespace {
            $gtype: GObject.GType<DBusInterface>;
            prototype: DBusInterfacePrototype;
        }
        export type DBusInterface = DBusInterfacePrototype;
        export interface DBusInterfacePrototype extends GObject.Object {
            // Members

            /**
             * Gets the #GDBusObject that `interface_ `belongs to, if any.
             */
            get_object(): DBusObject | null;
            /**
             * Gets D-Bus introspection information for the D-Bus interface
             * implemented by `interface_.`
             */
            get_info(): DBusInterfaceInfo;
            /**
             * Sets the #GDBusObject for `interface_ `to `object.`
             *
             * Note that `interface_ `will hold a weak reference to `object.`
             */
            set_object(object?: DBusObject | null): void;
            /**
             * Gets the #GDBusObject that `interface_ `belongs to, if any.
             */
            vfunc_dup_object(): DBusObject | null;
            /**
             * Gets D-Bus introspection information for the D-Bus interface
             * implemented by `interface_.`
             */
            vfunc_get_info(): DBusInterfaceInfo;
            /**
             * Sets the #GDBusObject for `interface_ `to `object.`
             *
             * Note that `interface_ `will hold a weak reference to `object.`
             */
            vfunc_set_object(object?: DBusObject | null): void;
        }

        export const DBusInterface: DBusInterfaceNamespace;

        /**
         * The #GDBusObject type is the base type for D-Bus objects on both
         * the service side (see #GDBusObjectSkeleton) and the client side
         * (see #GDBusObjectProxy). It is essentially just a container of
         * interfaces.
         */
        export interface DBusObjectNamespace {
            $gtype: GObject.GType<DBusObject>;
            prototype: DBusObjectPrototype;
        }
        export type DBusObject = DBusObjectPrototype;
        export interface DBusObjectPrototype extends GObject.Object {
            // Members

            /**
             * Gets the D-Bus interface with name `interface_name `associated with
             * object, if any.
             */
            get_interface(interface_name: string): DBusInterface | null;
            /**
             * Gets the D-Bus interfaces associated with `object.`
             */
            get_interfaces(): DBusInterface[];
            /**
             * Gets the object path for `object.`
             */
            get_object_path(): string;
            /**
             * Gets the D-Bus interface with name `interface_name `associated with
             * object, if any.
             */
            vfunc_get_interface(interface_name: string): DBusInterface | null;
            /**
             * Gets the D-Bus interfaces associated with `object.`
             */
            vfunc_get_interfaces(): DBusInterface[];
            /**
             * Gets the object path for `object.`
             */
            vfunc_get_object_path(): string;
            vfunc_interface_added(interface_: DBusInterface): void;
            vfunc_interface_removed(interface_: DBusInterface): void;
        }

        export const DBusObject: DBusObjectNamespace;

        /**
         * The #GDBusObjectManager type is the base type for service- and
         * client-side implementations of the standardized
         * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
         * interface.
         *
         * See #GDBusObjectManagerClient for the client-side implementation
         * and #GDBusObjectManagerServer for the service-side implementation.
         */
        export interface DBusObjectManagerNamespace {
            $gtype: GObject.GType<DBusObjectManager>;
            prototype: DBusObjectManagerPrototype;
        }
        export type DBusObjectManager = DBusObjectManagerPrototype;
        export interface DBusObjectManagerPrototype extends GObject.Object {
            // Members

            /**
             * Gets the interface proxy for `interface_name `at object_path, if
             * any.
             */
            get_interface(object_path: string, interface_name: string): DBusInterface | null;
            /**
             * Gets the #GDBusObject at object_path, if any.
             */
            get_object(object_path: string): DBusObject | null;
            /**
             * Gets the object path that `manager `is for.
             */
            get_object_path(): string;
            /**
             * Gets all #GDBusObject objects known to `manager.`
             */
            get_objects(): DBusObject[];
            /**
             * Gets the interface proxy for `interface_name `at object_path, if
             * any.
             */
            vfunc_get_interface(object_path: string, interface_name: string): DBusInterface | null;
            /**
             * Gets the #GDBusObject at object_path, if any.
             */
            vfunc_get_object(object_path: string): DBusObject | null;
            /**
             * Gets the object path that `manager `is for.
             */
            vfunc_get_object_path(): string;
            /**
             * Gets all #GDBusObject objects known to `manager.`
             */
            vfunc_get_objects(): DBusObject[];
            vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void;
            vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void;
            vfunc_object_added(object: DBusObject): void;
            vfunc_object_removed(object: DBusObject): void;
        }

        export const DBusObjectManager: DBusObjectManagerNamespace;

        /**
         * A #GDatagramBased is a networking interface for representing datagram-based
         * communications. It is a more or less direct mapping of the core parts of the
         * BSD socket API in a portable GObject interface. It is implemented by
         * #GSocket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
         *
         * #GDatagramBased is entirely platform independent, and is intended to be used
         * alongside higher-level networking APIs such as #GIOStream.
         *
         * It uses vectored scatter/gather I/O by default, allowing for many messages
         * to be sent or received in a single call. Where possible, implementations of
         * the interface should take advantage of vectored I/O to minimise processing
         * or system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
         * possible. Callers should take advantage of scatter/gather I/O (the use of
         * multiple buffers per message) to avoid unnecessary copying of data to
         * assemble or disassemble a message.
         *
         * Each #GDatagramBased operation has a timeout parameter which may be negative
         * for blocking behaviour, zero for non-blocking behaviour, or positive for
         * timeout behaviour. A blocking operation blocks until finished or there is an
         * error. A non-blocking operation will return immediately with a
         * %G_IO_ERROR_WOULD_BLOCK error if it cannot make progress. A timeout operation
         * will block until the operation is complete or the timeout expires; if the
         * timeout expires it will return what progress it made, or
         * %G_IO_ERROR_TIMED_OUT if no progress was made. To know when a call would
         * successfully run you can call g_datagram_based_condition_check() or
         * g_datagram_based_condition_wait(). You can also use
         * g_datagram_based_create_source() and attach it to a #GMainContext to get
         * callbacks when I/O is possible.
         *
         * When running a non-blocking operation applications should always be able to
         * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other function
         * said that I/O was possible. This can easily happen in case of a race
         * condition in the application, but it can also happen for other reasons. For
         * instance, on Windows a socket is always seen as writable until a write
         * returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * As with #GSocket, #GDatagramBaseds can be either connection oriented (for
         * example, SCTP) or connectionless (for example, UDP). #GDatagramBaseds must be
         * datagram-based, not stream-based. The interface does not cover connection
         * establishment — use methods on the underlying type to establish a connection
         * before sending and receiving data through the #GDatagramBased API. For
         * connectionless socket types the target/source address is specified or
         * received in each I/O operation.
         *
         * Like most other APIs in GLib, #GDatagramBased is not inherently thread safe.
         * To use a #GDatagramBased concurrently from multiple threads, you must
         * implement your own locking.
         */
        export interface DatagramBasedNamespace {
            $gtype: GObject.GType<DatagramBased>;
            prototype: DatagramBasedPrototype;
        }
        export type DatagramBased = DatagramBasedPrototype;
        export interface DatagramBasedPrototype extends GObject.Object {
            // Members

            /**
             * Checks on the readiness of `datagram_based `to perform operations. The
             * operations specified in `condition `are checked for and masked against the
             * currently-satisfied conditions on `datagram_based.` The result is returned.
             *
             * %G_IO_IN will be set in the return value if data is available to read with
             * g_datagram_based_receive_messages(), or if the connection is closed remotely
             * (EOS); and if the datagram_based has not been closed locally using some
             * implementation-specific method (such as g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket).
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * %G_IO_OUT will be set if it is expected that at least one byte can be sent
             * using g_datagram_based_send_messages() without blocking. It will not be set
             * if the datagram_based has been closed locally.
             *
             * %G_IO_HUP will be set if the connection has been closed locally.
             *
             * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
             * previously enqueued using g_datagram_based_send_messages().
             *
             * Note that on Windows, it is possible for an operation to return
             * %G_IO_ERROR_WOULD_BLOCK even immediately after
             * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
             * ready for writing. Rather than calling g_datagram_based_condition_check() and
             * then writing to the #GDatagramBased if it succeeds, it is generally better to
             * simply try writing right away, and try again later if the initial attempt
             * returns %G_IO_ERROR_WOULD_BLOCK.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be set in the output if they are true. Apart from
             * these flags, the output is guaranteed to be masked by `condition.`
             *
             * This call never blocks.
             */
            condition_check(condition: GLib.IOCondition): GLib.IOCondition;
            /**
             * Waits for up to `timeout `microseconds for condition to become true on
             * `datagram_based.` If the condition is met, %TRUE is returned.
             *
             * If `cancellable `is cancelled before the condition is met, or if `timeout `is
             * reached before the condition is met, then %FALSE is returned and `error `is
             * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
             */
            condition_wait(condition: GLib.IOCondition, timeout: number, cancellable?: Cancellable | null): boolean;
            /**
             * Creates a #GSource that can be attached to a #GMainContext to monitor for
             * the availability of the specified `condition `on the #GDatagramBased. The
             * #GSource keeps a reference to the `datagram_based.`
             *
             * The callback on the source is of the #GDatagramBasedSourceFunc type.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be reported in the callback if they are true.
             *
             * If non-%NULL, `cancellable `can be used to cancel the source, which will
             * cause the source to trigger, reporting the current condition (which is
             * likely 0 unless cancellation happened at the same time as a condition
             * change). You can check for this in the callback using
             * g_cancellable_is_cancelled().
             */
            create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
            /**
             * Receive one or more data messages from `datagram_based `in one go.
             *
             * `messages `must point to an array of #GInputMessage structs and
             * `num_messages `must be the length of this array. Each #GInputMessage
             * contains a pointer to an array of #GInputVector structs describing the
             * buffers that the data received in each message will be written to.
             *
             * `flags `modify how all messages are received. The commonly available
             * arguments for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too. These
             * flags affect the overall receive operation. Flags affecting individual
             * messages are returned in #GInputMessage.flags.
             *
             * The other members of #GInputMessage are treated as described in its
             * documentation.
             *
             * If `timeout `is negative the call will block until `num_messages `have been
             * received, the connection is closed remotely (EOS), `cancellable `is cancelled,
             * or an error occurs.
             *
             * If `timeout `is 0 the call will return up to `num_messages `without blocking,
             * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
             * to be received.
             *
             * If `timeout `is positive the call will block on the same conditions as if
             * `timeout `were negative. If the timeout is reached
             * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
             * otherwise it will return the number of messages received before timing out.
             * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
             * recvmmsg().)
             *
             * To be notified when messages are available, wait for the %G_IO_IN condition.
             * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
             * g_datagram_based_receive_messages() even if you were previously notified of a
             * %G_IO_IN condition.
             *
             * If the remote peer closes the connection, any messages queued in the
             * underlying receive buffer will be returned, and subsequent calls to
             * g_datagram_based_receive_messages() will return 0 (with no error set).
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be received; otherwise the number of
             * messages successfully received before the error will be returned. If
             * `cancellable `is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
             * other error.
             */
            receive_messages(
                messages: InputMessage[],
                flags: number,
                timeout: number,
                cancellable?: Cancellable | null
            ): number;
            /**
             * Send one or more data messages from `datagram_based `in one go.
             *
             * `messages `must point to an array of #GOutputMessage structs and
             * `num_messages `must be the length of this array. Each #GOutputMessage
             * contains an address to send the data to, and a pointer to an array of
             * #GOutputVector structs to describe the buffers that the data to be sent
             * for each message will be gathered from.
             *
             * `flags `modify how the message is sent. The commonly available arguments
             * for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too.
             *
             * The other members of #GOutputMessage are treated as described in its
             * documentation.
             *
             * If `timeout `is negative the call will block until `num_messages `have been
             * sent, `cancellable `is cancelled, or an error occurs.
             *
             * If `timeout `is 0 the call will send up to `num_messages `without blocking,
             * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
             *
             * If `timeout `is positive the call will block on the same conditions as if
             * `timeout `were negative. If the timeout is reached before any messages are
             * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
             * of messages sent before timing out.
             *
             * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
             * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
             * g_datagram_based_send_messages() even if you were previously notified of a
             * %G_IO_OUT condition. (On Windows in particular, this is very common due to
             * the way the underlying APIs work.)
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_write `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be sent; otherwise the number of messages
             * successfully sent before the error will be returned. If `cancellable `is
             * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
             */
            send_messages(
                messages: OutputMessage[],
                flags: number,
                timeout: number,
                cancellable?: Cancellable | null
            ): number;
            /**
             * Checks on the readiness of `datagram_based `to perform operations. The
             * operations specified in `condition `are checked for and masked against the
             * currently-satisfied conditions on `datagram_based.` The result is returned.
             *
             * %G_IO_IN will be set in the return value if data is available to read with
             * g_datagram_based_receive_messages(), or if the connection is closed remotely
             * (EOS); and if the datagram_based has not been closed locally using some
             * implementation-specific method (such as g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket).
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * %G_IO_OUT will be set if it is expected that at least one byte can be sent
             * using g_datagram_based_send_messages() without blocking. It will not be set
             * if the datagram_based has been closed locally.
             *
             * %G_IO_HUP will be set if the connection has been closed locally.
             *
             * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
             * previously enqueued using g_datagram_based_send_messages().
             *
             * Note that on Windows, it is possible for an operation to return
             * %G_IO_ERROR_WOULD_BLOCK even immediately after
             * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
             * ready for writing. Rather than calling g_datagram_based_condition_check() and
             * then writing to the #GDatagramBased if it succeeds, it is generally better to
             * simply try writing right away, and try again later if the initial attempt
             * returns %G_IO_ERROR_WOULD_BLOCK.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be set in the output if they are true. Apart from
             * these flags, the output is guaranteed to be masked by `condition.`
             *
             * This call never blocks.
             */
            vfunc_condition_check(condition: GLib.IOCondition): GLib.IOCondition;
            /**
             * Waits for up to `timeout `microseconds for condition to become true on
             * `datagram_based.` If the condition is met, %TRUE is returned.
             *
             * If `cancellable `is cancelled before the condition is met, or if `timeout `is
             * reached before the condition is met, then %FALSE is returned and `error `is
             * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
             */
            vfunc_condition_wait(
                condition: GLib.IOCondition,
                timeout: number,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Creates a #GSource that can be attached to a #GMainContext to monitor for
             * the availability of the specified `condition `on the #GDatagramBased. The
             * #GSource keeps a reference to the `datagram_based.`
             *
             * The callback on the source is of the #GDatagramBasedSourceFunc type.
             *
             * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition; these
             * conditions will always be reported in the callback if they are true.
             *
             * If non-%NULL, `cancellable `can be used to cancel the source, which will
             * cause the source to trigger, reporting the current condition (which is
             * likely 0 unless cancellation happened at the same time as a condition
             * change). You can check for this in the callback using
             * g_cancellable_is_cancelled().
             */
            vfunc_create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
            /**
             * Receive one or more data messages from `datagram_based `in one go.
             *
             * `messages `must point to an array of #GInputMessage structs and
             * `num_messages `must be the length of this array. Each #GInputMessage
             * contains a pointer to an array of #GInputVector structs describing the
             * buffers that the data received in each message will be written to.
             *
             * `flags `modify how all messages are received. The commonly available
             * arguments for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too. These
             * flags affect the overall receive operation. Flags affecting individual
             * messages are returned in #GInputMessage.flags.
             *
             * The other members of #GInputMessage are treated as described in its
             * documentation.
             *
             * If `timeout `is negative the call will block until `num_messages `have been
             * received, the connection is closed remotely (EOS), `cancellable `is cancelled,
             * or an error occurs.
             *
             * If `timeout `is 0 the call will return up to `num_messages `without blocking,
             * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
             * to be received.
             *
             * If `timeout `is positive the call will block on the same conditions as if
             * `timeout `were negative. If the timeout is reached
             * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
             * otherwise it will return the number of messages received before timing out.
             * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
             * recvmmsg().)
             *
             * To be notified when messages are available, wait for the %G_IO_IN condition.
             * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
             * g_datagram_based_receive_messages() even if you were previously notified of a
             * %G_IO_IN condition.
             *
             * If the remote peer closes the connection, any messages queued in the
             * underlying receive buffer will be returned, and subsequent calls to
             * g_datagram_based_receive_messages() will return 0 (with no error set).
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_read `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be received; otherwise the number of
             * messages successfully received before the error will be returned. If
             * `cancellable `is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
             * other error.
             */
            vfunc_receive_messages(
                messages: InputMessage[],
                flags: number,
                timeout: number,
                cancellable?: Cancellable | null
            ): number;
            /**
             * Send one or more data messages from `datagram_based `in one go.
             *
             * `messages `must point to an array of #GOutputMessage structs and
             * `num_messages `must be the length of this array. Each #GOutputMessage
             * contains an address to send the data to, and a pointer to an array of
             * #GOutputVector structs to describe the buffers that the data to be sent
             * for each message will be gathered from.
             *
             * `flags `modify how the message is sent. The commonly available arguments
             * for this are available in the #GSocketMsgFlags enum, but the
             * values there are the same as the system values, and the flags
             * are passed in as-is, so you can pass in system-specific flags too.
             *
             * The other members of #GOutputMessage are treated as described in its
             * documentation.
             *
             * If `timeout `is negative the call will block until `num_messages `have been
             * sent, `cancellable `is cancelled, or an error occurs.
             *
             * If `timeout `is 0 the call will send up to `num_messages `without blocking,
             * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
             *
             * If `timeout `is positive the call will block on the same conditions as if
             * `timeout `were negative. If the timeout is reached before any messages are
             * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
             * of messages sent before timing out.
             *
             * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
             * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
             * g_datagram_based_send_messages() even if you were previously notified of a
             * %G_IO_OUT condition. (On Windows in particular, this is very common due to
             * the way the underlying APIs work.)
             *
             * If the connection is shut down or closed (by calling g_socket_close() or
             * g_socket_shutdown() with `shutdown_write `set, if it’s a #GSocket, for
             * example), all calls to this function will return %G_IO_ERROR_CLOSED.
             *
             * On error -1 is returned and `error `is set accordingly. An error will only
             * be returned if zero messages could be sent; otherwise the number of messages
             * successfully sent before the error will be returned. If `cancellable `is
             * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
             */
            vfunc_send_messages(
                messages: OutputMessage[],
                flags: number,
                timeout: number,
                cancellable?: Cancellable | null
            ): number;
        }

        export const DatagramBased: DatagramBasedNamespace;

        /**
         * #GDebugController is an interface to expose control of debugging features and
         * debug output.
         *
         * It is implemented on Linux using #GDebugControllerDBus, which exposes a D-Bus
         * interface to allow authenticated peers to control debug features in this
         * process.
         *
         * Whether debug output is enabled is exposed as
         * #GDebugController:debug-enabled. This controls g_log_set_debug_enabled() by
         * default. Application code may connect to the #GObject::notify signal for it
         * to control other parts of its debug infrastructure as necessary.
         *
         * If your application or service is using the default GLib log writer function,
         * creating one of the built-in implementations of #GDebugController should be
         * all that’s needed to dynamically enable or disable debug output.
         */
        export interface DebugControllerNamespace {
            $gtype: GObject.GType<DebugController>;
            prototype: DebugControllerPrototype;
        }
        export type DebugController = DebugControllerPrototype;
        export interface DebugControllerPrototype extends Initable {
            // Properties
            debug_enabled: boolean;
            debugEnabled: boolean;

            // Members

            /**
             * Get the value of #GDebugController:debug-enabled.
             */
            get_debug_enabled(): boolean;
            /**
             * Set the value of #GDebugController:debug-enabled.
             */
            set_debug_enabled(debug_enabled: boolean): void;
        }

        export const DebugController: DebugControllerNamespace;

        /**
         * #GDesktopAppInfoLookup is an opaque data structure and can only be accessed
         * using the following functions.
         */
        export interface DesktopAppInfoLookupNamespace {
            $gtype: GObject.GType<DesktopAppInfoLookup>;
            prototype: DesktopAppInfoLookupPrototype;
        }
        export type DesktopAppInfoLookup = DesktopAppInfoLookupPrototype;
        export interface DesktopAppInfoLookupPrototype extends GObject.Object {
            // Members

            /**
             * Gets the default application for launching applications
             * using this URI scheme for a particular #GDesktopAppInfoLookup
             * implementation.
             *
             * The #GDesktopAppInfoLookup interface and this function is used
             * to implement g_app_info_get_default_for_uri_scheme() backends
             * in a GIO module. There is no reason for applications to use it
             * directly. Applications should use g_app_info_get_default_for_uri_scheme().
             */
            get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
            /**
             * Gets the default application for launching applications
             * using this URI scheme for a particular #GDesktopAppInfoLookup
             * implementation.
             *
             * The #GDesktopAppInfoLookup interface and this function is used
             * to implement g_app_info_get_default_for_uri_scheme() backends
             * in a GIO module. There is no reason for applications to use it
             * directly. Applications should use g_app_info_get_default_for_uri_scheme().
             */
            vfunc_get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
        }

        export const DesktopAppInfoLookup: DesktopAppInfoLookupNamespace;

        /**
         * #GDrive - this represent a piece of hardware connected to the machine.
         * It's generally only created for removable hardware or hardware with
         * removable media.
         *
         * #GDrive is a container class for #GVolume objects that stem from
         * the same piece of media. As such, #GDrive abstracts a drive with
         * (or without) removable media and provides operations for querying
         * whether media is available, determining whether media change is
         * automatically detected and ejecting the media.
         *
         * If the #GDrive reports that media isn't automatically detected, one
         * can poll for media; typically one should not do this periodically
         * as a poll for media operation is potentially expensive and may
         * spin up the drive creating noise.
         *
         * #GDrive supports starting and stopping drives with authentication
         * support for the former. This can be used to support a diverse set
         * of use cases including connecting/disconnecting iSCSI devices,
         * powering down external disk enclosures and starting/stopping
         * multi-disk devices such as RAID devices. Note that the actual
         * semantics and side-effects of starting/stopping a #GDrive may vary
         * according to implementation. To choose the correct verbs in e.g. a
         * file manager, use g_drive_get_start_stop_type().
         *
         * For porting from GnomeVFS note that there is no equivalent of
         * #GDrive in that API.
         */
        export interface DriveNamespace {
            $gtype: GObject.GType<Drive>;
            prototype: DrivePrototype;
        }
        export type Drive = DrivePrototype;
        export interface DrivePrototype extends GObject.Object {
            // Members

            /**
             * Checks if a drive can be ejected.
             */
            can_eject(): boolean;
            /**
             * Checks if a drive can be polled for media changes.
             */
            can_poll_for_media(): boolean;
            /**
             * Checks if a drive can be started.
             */
            can_start(): boolean;
            /**
             * Checks if a drive can be started degraded.
             */
            can_start_degraded(): boolean;
            /**
             * Checks if a drive can be stopped.
             */
            can_stop(): boolean;
            /**
             * Asynchronously ejects a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_eject_finish() to obtain the
             * result of the operation.
             */
            eject(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously ejects a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_eject_finish() to obtain the
             * result of the operation.
             */
            eject(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously ejects a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_eject_finish() to obtain the
             * result of the operation.
             */
            eject(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a drive.
             */
            eject_finish(result: AsyncResult): boolean;
            /**
             * Ejects a drive. This is an asynchronous operation, and is
             * finished by calling g_drive_eject_with_operation_finish() with the drive
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Ejects a drive. This is an asynchronous operation, and is
             * finished by calling g_drive_eject_with_operation_finish() with the drive
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a drive. This is an asynchronous operation, and is
             * finished by calling g_drive_eject_with_operation_finish() with the drive
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a drive. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            eject_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the kinds of identifiers that `drive `has.
             * Use g_drive_get_identifier() to obtain the identifiers
             * themselves.
             */
            enumerate_identifiers(): string[];
            /**
             * Gets the icon for `drive.`
             */
            get_icon(): Icon;
            /**
             * Gets the identifier of the given kind for `drive.` The only
             * identifier currently available is
             * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
             */
            get_identifier(kind: string): string | null;
            /**
             * Gets the name of `drive.`
             */
            get_name(): string;
            /**
             * Gets the sort key for drive, if any.
             */
            get_sort_key(): string | null;
            /**
             * Gets a hint about how a drive can be started/stopped.
             */
            get_start_stop_type(): DriveStartStopType;
            /**
             * Gets the icon for `drive.`
             */
            get_symbolic_icon(): Icon;
            /**
             * Get a list of mountable volumes for `drive.`
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            get_volumes(): Volume[];
            /**
             * Checks if the `drive `has media. Note that the OS may not be polling
             * the drive for media changes; see g_drive_is_media_check_automatic()
             * for more details.
             */
            has_media(): boolean;
            /**
             * Check if `drive `has any mountable volumes.
             */
            has_volumes(): boolean;
            /**
             * Checks if `drive `is capable of automatically detecting media changes.
             */
            is_media_check_automatic(): boolean;
            /**
             * Checks if the `drive `supports removable media.
             */
            is_media_removable(): boolean;
            /**
             * Checks if the #GDrive and/or its media is considered removable by the user.
             * See g_drive_is_media_removable().
             */
            is_removable(): boolean;
            /**
             * Asynchronously polls `drive `to see if media has been inserted or removed.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_poll_for_media_finish() to obtain the
             * result of the operation.
             */
            poll_for_media(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously polls `drive `to see if media has been inserted or removed.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_poll_for_media_finish() to obtain the
             * result of the operation.
             */
            poll_for_media(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously polls `drive `to see if media has been inserted or removed.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_poll_for_media_finish() to obtain the
             * result of the operation.
             */
            poll_for_media(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an operation started with g_drive_poll_for_media() on a drive.
             */
            poll_for_media_finish(result: AsyncResult): boolean;
            /**
             * Asynchronously starts a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_start_finish() to obtain the
             * result of the operation.
             */
            start(
                flags: DriveStartFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously starts a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_start_finish() to obtain the
             * result of the operation.
             */
            start(
                flags: DriveStartFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously starts a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_start_finish() to obtain the
             * result of the operation.
             */
            start(
                flags: DriveStartFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes starting a drive.
             */
            start_finish(result: AsyncResult): boolean;
            /**
             * Asynchronously stops a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_stop_finish() to obtain the
             * result of the operation.
             */
            stop(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously stops a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_stop_finish() to obtain the
             * result of the operation.
             */
            stop(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously stops a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_stop_finish() to obtain the
             * result of the operation.
             */
            stop(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes stopping a drive.
             */
            stop_finish(result: AsyncResult): boolean;
            /**
             * Checks if a drive can be ejected.
             */
            vfunc_can_eject(): boolean;
            /**
             * Checks if a drive can be polled for media changes.
             */
            vfunc_can_poll_for_media(): boolean;
            /**
             * Checks if a drive can be started.
             */
            vfunc_can_start(): boolean;
            /**
             * Checks if a drive can be started degraded.
             */
            vfunc_can_start_degraded(): boolean;
            /**
             * Checks if a drive can be stopped.
             */
            vfunc_can_stop(): boolean;
            vfunc_changed(): void;
            vfunc_disconnected(): void;
            /**
             * Asynchronously ejects a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_eject_finish() to obtain the
             * result of the operation.
             */
            vfunc_eject(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously ejects a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_eject_finish() to obtain the
             * result of the operation.
             */
            vfunc_eject(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously ejects a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_eject_finish() to obtain the
             * result of the operation.
             */
            vfunc_eject(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            vfunc_eject_button(): void;
            /**
             * Finishes ejecting a drive.
             */
            vfunc_eject_finish(result: AsyncResult): boolean;
            /**
             * Ejects a drive. This is an asynchronous operation, and is
             * finished by calling g_drive_eject_with_operation_finish() with the drive
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Ejects a drive. This is an asynchronous operation, and is
             * finished by calling g_drive_eject_with_operation_finish() with the drive
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a drive. This is an asynchronous operation, and is
             * finished by calling g_drive_eject_with_operation_finish() with the drive
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a drive. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the kinds of identifiers that `drive `has.
             * Use g_drive_get_identifier() to obtain the identifiers
             * themselves.
             */
            vfunc_enumerate_identifiers(): string[];
            /**
             * Gets the icon for `drive.`
             */
            vfunc_get_icon(): Icon;
            /**
             * Gets the identifier of the given kind for `drive.` The only
             * identifier currently available is
             * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
             */
            vfunc_get_identifier(kind: string): string | null;
            /**
             * Gets the name of `drive.`
             */
            vfunc_get_name(): string;
            /**
             * Gets the sort key for drive, if any.
             */
            vfunc_get_sort_key(): string | null;
            /**
             * Gets a hint about how a drive can be started/stopped.
             */
            vfunc_get_start_stop_type(): DriveStartStopType;
            /**
             * Gets the icon for `drive.`
             */
            vfunc_get_symbolic_icon(): Icon;
            /**
             * Get a list of mountable volumes for `drive.`
             *
             * The returned list should be freed with g_list_free(), after
             * its elements have been unreffed with g_object_unref().
             */
            vfunc_get_volumes(): Volume[];
            /**
             * Checks if the `drive `has media. Note that the OS may not be polling
             * the drive for media changes; see g_drive_is_media_check_automatic()
             * for more details.
             */
            vfunc_has_media(): boolean;
            /**
             * Check if `drive `has any mountable volumes.
             */
            vfunc_has_volumes(): boolean;
            /**
             * Checks if `drive `is capable of automatically detecting media changes.
             */
            vfunc_is_media_check_automatic(): boolean;
            /**
             * Checks if the `drive `supports removable media.
             */
            vfunc_is_media_removable(): boolean;
            /**
             * Checks if the #GDrive and/or its media is considered removable by the user.
             * See g_drive_is_media_removable().
             */
            vfunc_is_removable(): boolean;
            /**
             * Asynchronously polls `drive `to see if media has been inserted or removed.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_poll_for_media_finish() to obtain the
             * result of the operation.
             */
            vfunc_poll_for_media(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously polls `drive `to see if media has been inserted or removed.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_poll_for_media_finish() to obtain the
             * result of the operation.
             */
            vfunc_poll_for_media(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously polls `drive `to see if media has been inserted or removed.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_poll_for_media_finish() to obtain the
             * result of the operation.
             */
            vfunc_poll_for_media(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an operation started with g_drive_poll_for_media() on a drive.
             */
            vfunc_poll_for_media_finish(result: AsyncResult): boolean;
            /**
             * Asynchronously starts a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_start_finish() to obtain the
             * result of the operation.
             */
            vfunc_start(
                flags: DriveStartFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously starts a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_start_finish() to obtain the
             * result of the operation.
             */
            vfunc_start(
                flags: DriveStartFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously starts a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_start_finish() to obtain the
             * result of the operation.
             */
            vfunc_start(
                flags: DriveStartFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes starting a drive.
             */
            vfunc_start_finish(result: AsyncResult): boolean;
            /**
             * Asynchronously stops a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_stop_finish() to obtain the
             * result of the operation.
             */
            vfunc_stop(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously stops a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_stop_finish() to obtain the
             * result of the operation.
             */
            vfunc_stop(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously stops a drive.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_drive_stop_finish() to obtain the
             * result of the operation.
             */
            vfunc_stop(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            vfunc_stop_button(): void;
            /**
             * Finishes stopping a drive.
             */
            vfunc_stop_finish(result: AsyncResult): boolean;
        }

        export const Drive: DriveNamespace;

        /**
         * #GDtlsClientConnection is the client-side subclass of
         * #GDtlsConnection, representing a client-side DTLS connection.
         */
        export interface DtlsClientConnectionNamespace {
            $gtype: GObject.GType<DtlsClientConnection>;
            prototype: DtlsClientConnectionPrototype;

            /**
             * Creates a new #GDtlsClientConnection wrapping `base_socket `which is
             * assumed to communicate with the server identified by `server_identity.`
             */
            ["new"](base_socket: DatagramBased, server_identity?: SocketConnectable | null): DtlsClientConnection;
        }
        export type DtlsClientConnection = DtlsClientConnectionPrototype;
        export interface DtlsClientConnectionPrototype extends DatagramBased {
            // Properties
            readonly accepted_cas: any[];
            readonly acceptedCas: any[];
            server_identity: SocketConnectable;
            serverIdentity: SocketConnectable;
            validation_flags: TlsCertificateFlags;
            validationFlags: TlsCertificateFlags;

            // Members

            /**
             * Gets the list of distinguished names of the Certificate Authorities
             * that the server will accept certificates from. This will be set
             * during the TLS handshake if the server requests a certificate.
             * Otherwise, it will be %NULL.
             *
             * Each item in the list is a #GByteArray which contains the complete
             * subject DN of the certificate authority.
             */
            get_accepted_cas(): GLib.List;
            /**
             * Gets conn's expected server identity
             */
            get_server_identity(): SocketConnectable;
            /**
             * Gets conn's validation flags
             *
             * This function does not work as originally designed and is impossible
             * to use correctly. See #GDtlsClientConnection:validation-flags for more
             * information.
             */
            get_validation_flags(): TlsCertificateFlags;
            /**
             * Sets conn's expected server identity, which is used both to tell
             * servers on virtual hosts which certificate to present, and also
             * to let `conn `know what name to look for in the certificate when
             * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
             */
            set_server_identity(identity: SocketConnectable): void;
            /**
             * Sets conn's validation flags, to override the default set of
             * checks performed when validating a server certificate. By default,
             * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
             *
             * This function does not work as originally designed and is impossible
             * to use correctly. See #GDtlsClientConnection:validation-flags for more
             * information.
             */
            set_validation_flags(flags: TlsCertificateFlags): void;
        }

        export const DtlsClientConnection: DtlsClientConnectionNamespace;

        /**
         * #GDtlsConnection is the base DTLS connection class type, which wraps
         * a #GDatagramBased and provides DTLS encryption on top of it. Its
         * subclasses, #GDtlsClientConnection and #GDtlsServerConnection,
         * implement client-side and server-side DTLS, respectively.
         *
         * For TLS support, see #GTlsConnection.
         *
         * As DTLS is datagram based, #GDtlsConnection implements #GDatagramBased,
         * presenting a datagram-socket-like API for the encrypted connection. This
         * operates over a base datagram connection, which is also a #GDatagramBased
         * (#GDtlsConnection:base-socket).
         *
         * To close a DTLS connection, use g_dtls_connection_close().
         *
         * Neither #GDtlsServerConnection or #GDtlsClientConnection set the peer address
         * on their base #GDatagramBased if it is a #GSocket — it is up to the caller to
         * do that if they wish. If they do not, and g_socket_close() is called on the
         * base socket, the #GDtlsConnection will not raise a %G_IO_ERROR_NOT_CONNECTED
         * error on further I/O.
         */
        export interface DtlsConnectionNamespace {
            $gtype: GObject.GType<DtlsConnection>;
            prototype: DtlsConnectionPrototype;
        }
        export type DtlsConnection = DtlsConnectionPrototype;
        export interface DtlsConnectionPrototype extends DatagramBased {
            // Properties
            advertised_protocols: string[];
            advertisedProtocols: string[];
            readonly base_socket: DatagramBased;
            readonly baseSocket: DatagramBased;
            certificate: TlsCertificate;
            readonly ciphersuite_name: string;
            readonly ciphersuiteName: string;
            database: TlsDatabase;
            interaction: TlsInteraction;
            readonly negotiated_protocol: string;
            readonly negotiatedProtocol: string;
            readonly peer_certificate: TlsCertificate;
            readonly peerCertificate: TlsCertificate;
            readonly peer_certificate_errors: TlsCertificateFlags;
            readonly peerCertificateErrors: TlsCertificateFlags;
            readonly protocol_version: TlsProtocolVersion;
            readonly protocolVersion: TlsProtocolVersion;
            rehandshake_mode: TlsRehandshakeMode;
            rehandshakeMode: TlsRehandshakeMode;
            require_close_notify: boolean;
            requireCloseNotify: boolean;

            // Members

            /**
             * Close the DTLS connection. This is equivalent to calling
             * g_dtls_connection_shutdown() to shut down both sides of the connection.
             *
             * Closing a #GDtlsConnection waits for all buffered but untransmitted data to
             * be sent before it completes. It then sends a `close_notify` DTLS alert to the
             * peer and may wait for a `close_notify` to be received from the peer. It does
             * not close the underlying #GDtlsConnection:base-socket; that must be closed
             * separately.
             *
             * Once `conn `is closed, all other operations will return %G_IO_ERROR_CLOSED.
             * Closing a #GDtlsConnection multiple times will not return an error.
             *
             * #GDtlsConnections will be automatically closed when the last reference is
             * dropped, but you might want to call this function to make sure resources are
             * released as early as possible.
             *
             * If `cancellable `is cancelled, the #GDtlsConnection may be left
             * partially-closed and any pending untransmitted data may be lost. Call
             * g_dtls_connection_close() again to complete closing the #GDtlsConnection.
             */
            close(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
             * more information.
             */
            close_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
             * more information.
             */
            close_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
             * more information.
             */
            close_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS close operation. See g_dtls_connection_close()
             * for more information.
             */
            close_finish(result: AsyncResult): boolean;
            /**
             * Used by #GDtlsConnection implementations to emit the
             * #GDtlsConnection::accept-certificate signal.
             */
            emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
            /**
             * Gets conn's certificate, as set by
             * g_dtls_connection_set_certificate().
             */
            get_certificate(): TlsCertificate | null;
            /**
             * Query the TLS backend for TLS channel binding data of `type `for `conn.`
             *
             * This call retrieves TLS channel binding data as specified in RFC
             * [5056](https://tools.ietf.org/html/rfc5056), RFC
             * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
             * binding data is returned in `data.`  The `data `is resized by the callee
             * using #GByteArray buffer management and will be freed when the data
             * is destroyed by g_byte_array_unref(). If `data `is %NULL, it will only
             * check whether TLS backend is able to fetch the data (e.g. whether type
             * is supported by the TLS backend). It does not guarantee that the data
             * will be available though.  That could happen if TLS connection does not
             * support `type `or the binding data is not available yet due to additional
             * negotiation or input required.
             */
            get_channel_binding_data(type: TlsChannelBindingType): [boolean, Uint8Array | null];
            /**
             * Returns the name of the current DTLS ciphersuite, or %NULL if the
             * connection has not handshaked or has been closed. Beware that the TLS
             * backend may use any of multiple different naming conventions, because
             * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
             * are different from each other and different from the standard, IANA-
             * registered ciphersuite names. The ciphersuite name is intended to be
             * displayed to the user for informative purposes only, and parsing it
             * is not recommended.
             */
            get_ciphersuite_name(): string | null;
            /**
             * Gets the certificate database that `conn `uses to verify
             * peer certificates. See g_dtls_connection_set_database().
             */
            get_database(): TlsDatabase | null;
            /**
             * Get the object that will be used to interact with the user. It will be used
             * for things like prompting the user for passwords. If %NULL is returned, then
             * no user interaction will occur for this connection.
             */
            get_interaction(): TlsInteraction | null;
            /**
             * Gets the name of the application-layer protocol negotiated during
             * the handshake.
             *
             * If the peer did not use the ALPN extension, or did not advertise a
             * protocol that matched one of conn's protocols, or the TLS backend
             * does not support ALPN, then this will be %NULL. See
             * g_dtls_connection_set_advertised_protocols().
             */
            get_negotiated_protocol(): string | null;
            /**
             * Gets conn's peer's certificate after the handshake has completed
             * or failed. (It is not set during the emission of
             * #GDtlsConnection::accept-certificate.)
             */
            get_peer_certificate(): TlsCertificate | null;
            /**
             * Gets the errors associated with validating conn's peer's
             * certificate, after the handshake has completed or failed. (It is
             * not set during the emission of #GDtlsConnection::accept-certificate.)
             */
            get_peer_certificate_errors(): TlsCertificateFlags;
            /**
             * Returns the current DTLS protocol version, which may be
             * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
             * has been closed, or if the TLS backend has implemented a protocol version
             * that is not a recognized #GTlsProtocolVersion.
             */
            get_protocol_version(): TlsProtocolVersion;
            /**
             * Gets `conn `rehandshaking mode. See
             * g_dtls_connection_set_rehandshake_mode() for details.
             */
            get_rehandshake_mode(): TlsRehandshakeMode;
            /**
             * Tests whether or not `conn `expects a proper TLS close notification
             * when the connection is closed. See
             * g_dtls_connection_set_require_close_notify() for details.
             */
            get_require_close_notify(): boolean;
            /**
             * Attempts a TLS handshake on `conn.`
             *
             * On the client side, it is never necessary to call this method;
             * although the connection needs to perform a handshake after
             * connecting, #GDtlsConnection will handle this for you automatically
             * when you try to send or receive data on the connection. You can call
             * g_dtls_connection_handshake() manually if you want to know whether
             * the initial handshake succeeded or failed (as opposed to just
             * immediately trying to use `conn `to read or write, in which case,
             * if it fails, it may not be possible to tell if it failed before
             * or after completing the handshake), but beware that servers may reject
             * client authentication after the handshake has completed, so a
             * successful handshake does not indicate the connection will be usable.
             *
             * Likewise, on the server side, although a handshake is necessary at
             * the beginning of the communication, you do not need to call this
             * function explicitly unless you want clearer error reporting.
             *
             * Previously, calling g_dtls_connection_handshake() after the initial
             * handshake would trigger a rehandshake; however, this usage was
             * deprecated in GLib 2.60 because rehandshaking was removed from the
             * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
             * the initial handshake will no longer do anything.
             *
             * #GDtlsConnection::accept_certificate may be emitted during the
             * handshake.
             */
            handshake(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_dtls_connection_handshake() for more information.
             */
            handshake_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_dtls_connection_handshake() for more information.
             */
            handshake_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_dtls_connection_handshake() for more information.
             */
            handshake_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS handshake operation. See
             * g_dtls_connection_handshake() for more information.
             */
            handshake_finish(result: AsyncResult): boolean;
            /**
             * Sets the list of application-layer protocols to advertise that the
             * caller is willing to speak on this connection. The
             * Application-Layer Protocol Negotiation (ALPN) extension will be
             * used to negotiate a compatible protocol with the peer; use
             * g_dtls_connection_get_negotiated_protocol() to find the negotiated
             * protocol after the handshake.  Specifying %NULL for the the value
             * of `protocols `will disable ALPN negotiation.
             *
             * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
             * for a list of registered protocol IDs.
             */
            set_advertised_protocols(protocols?: string[] | null): void;
            /**
             * This sets the certificate that `conn `will present to its peer
             * during the TLS handshake. For a #GDtlsServerConnection, it is
             * mandatory to set this, and that will normally be done at construct
             * time.
             *
             * For a #GDtlsClientConnection, this is optional. If a handshake fails
             * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
             * requires a certificate, and if you try connecting again, you should
             * call this method first. You can call
             * g_dtls_client_connection_get_accepted_cas() on the failed connection
             * to get a list of Certificate Authorities that the server will
             * accept certificates from.
             *
             * (It is also possible that a server will allow the connection with
             * or without a certificate; in that case, if you don't provide a
             * certificate, you can tell that the server requested one by the fact
             * that g_dtls_client_connection_get_accepted_cas() will return
             * non-%NULL.)
             */
            set_certificate(certificate: TlsCertificate): void;
            /**
             * Sets the certificate database that is used to verify peer certificates.
             * This is set to the default database by default. See
             * g_tls_backend_get_default_database(). If set to %NULL, then
             * peer certificate validation will always set the
             * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
             * #GDtlsConnection::accept-certificate will always be emitted on
             * client-side connections, unless that bit is not set in
             * #GDtlsClientConnection:validation-flags).
             *
             * There are nonintuitive security implications when using a non-default
             * database. See #GDtlsConnection:database for details.
             */
            set_database(database?: TlsDatabase | null): void;
            /**
             * Set the object that will be used to interact with the user. It will be used
             * for things like prompting the user for passwords.
             *
             * The `interaction `argument will normally be a derived subclass of
             * #GTlsInteraction. %NULL can also be provided if no user interaction
             * should occur for this connection.
             */
            set_interaction(interaction?: TlsInteraction | null): void;
            /**
             * Since GLib 2.64, changing the rehandshake mode is no longer supported
             * and will have no effect. With TLS 1.3, rehandshaking has been removed from
             * the TLS protocol, replaced by separate post-handshake authentication and
             * rekey operations.
             */
            set_rehandshake_mode(mode: TlsRehandshakeMode): void;
            /**
             * Sets whether or not `conn `expects a proper TLS close notification
             * before the connection is closed. If this is %TRUE (the default),
             * then `conn `will expect to receive a TLS close notification from its
             * peer before the connection is closed, and will return a
             * %G_TLS_ERROR_EOF error if the connection is closed without proper
             * notification (since this may indicate a network error, or
             * man-in-the-middle attack).
             *
             * In some protocols, the application will know whether or not the
             * connection was closed cleanly based on application-level data
             * (because the application-level data includes a length field, or is
             * somehow self-delimiting); in this case, the close notify is
             * redundant and may be omitted. You
             * can use g_dtls_connection_set_require_close_notify() to tell conn
             * to allow an "unannounced" connection close, in which case the close
             * will show up as a 0-length read, as in a non-TLS
             * #GDatagramBased, and it is up to the application to check that
             * the data has been fully received.
             *
             * Note that this only affects the behavior when the peer closes the
             * connection; when the application calls g_dtls_connection_close_async() on
             * `conn `itself, this will send a close notification regardless of the
             * setting of this property. If you explicitly want to do an unclean
             * close, you can close conn's #GDtlsConnection:base-socket rather
             * than closing `conn `itself.
             */
            set_require_close_notify(require_close_notify: boolean): void;
            /**
             * Shut down part or all of a DTLS connection.
             *
             * If `shutdown_read `is %TRUE then the receiving side of the connection is shut
             * down, and further reading is disallowed. Subsequent calls to
             * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
             *
             * If `shutdown_write `is %TRUE then the sending side of the connection is shut
             * down, and further writing is disallowed. Subsequent calls to
             * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
             *
             * It is allowed for both `shutdown_read `and `shutdown_write `to be TRUE — this
             * is equivalent to calling g_dtls_connection_close().
             *
             * If `cancellable `is cancelled, the #GDtlsConnection may be left
             * partially-closed and any pending untransmitted data may be lost. Call
             * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
             */
            shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously shut down part or all of the DTLS connection. See
             * g_dtls_connection_shutdown() for more information.
             */
            shutdown_async(
                shutdown_read: boolean,
                shutdown_write: boolean,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously shut down part or all of the DTLS connection. See
             * g_dtls_connection_shutdown() for more information.
             */
            shutdown_async(
                shutdown_read: boolean,
                shutdown_write: boolean,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously shut down part or all of the DTLS connection. See
             * g_dtls_connection_shutdown() for more information.
             */
            shutdown_async(
                shutdown_read: boolean,
                shutdown_write: boolean,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS shutdown operation. See
             * g_dtls_connection_shutdown() for more information.
             */
            shutdown_finish(result: AsyncResult): boolean;
            vfunc_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
            vfunc_get_binding_data(type: TlsChannelBindingType, data: Uint8Array | string): boolean;
            /**
             * Gets the name of the application-layer protocol negotiated during
             * the handshake.
             *
             * If the peer did not use the ALPN extension, or did not advertise a
             * protocol that matched one of conn's protocols, or the TLS backend
             * does not support ALPN, then this will be %NULL. See
             * g_dtls_connection_set_advertised_protocols().
             */
            vfunc_get_negotiated_protocol(): string | null;
            /**
             * Attempts a TLS handshake on `conn.`
             *
             * On the client side, it is never necessary to call this method;
             * although the connection needs to perform a handshake after
             * connecting, #GDtlsConnection will handle this for you automatically
             * when you try to send or receive data on the connection. You can call
             * g_dtls_connection_handshake() manually if you want to know whether
             * the initial handshake succeeded or failed (as opposed to just
             * immediately trying to use `conn `to read or write, in which case,
             * if it fails, it may not be possible to tell if it failed before
             * or after completing the handshake), but beware that servers may reject
             * client authentication after the handshake has completed, so a
             * successful handshake does not indicate the connection will be usable.
             *
             * Likewise, on the server side, although a handshake is necessary at
             * the beginning of the communication, you do not need to call this
             * function explicitly unless you want clearer error reporting.
             *
             * Previously, calling g_dtls_connection_handshake() after the initial
             * handshake would trigger a rehandshake; however, this usage was
             * deprecated in GLib 2.60 because rehandshaking was removed from the
             * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
             * the initial handshake will no longer do anything.
             *
             * #GDtlsConnection::accept_certificate may be emitted during the
             * handshake.
             */
            vfunc_handshake(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_dtls_connection_handshake() for more information.
             */
            vfunc_handshake_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_dtls_connection_handshake() for more information.
             */
            vfunc_handshake_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously performs a TLS handshake on `conn.` See
             * g_dtls_connection_handshake() for more information.
             */
            vfunc_handshake_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS handshake operation. See
             * g_dtls_connection_handshake() for more information.
             */
            vfunc_handshake_finish(result: AsyncResult): boolean;
            /**
             * Sets the list of application-layer protocols to advertise that the
             * caller is willing to speak on this connection. The
             * Application-Layer Protocol Negotiation (ALPN) extension will be
             * used to negotiate a compatible protocol with the peer; use
             * g_dtls_connection_get_negotiated_protocol() to find the negotiated
             * protocol after the handshake.  Specifying %NULL for the the value
             * of `protocols `will disable ALPN negotiation.
             *
             * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
             * for a list of registered protocol IDs.
             */
            vfunc_set_advertised_protocols(protocols?: string[] | null): void;
            /**
             * Shut down part or all of a DTLS connection.
             *
             * If `shutdown_read `is %TRUE then the receiving side of the connection is shut
             * down, and further reading is disallowed. Subsequent calls to
             * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
             *
             * If `shutdown_write `is %TRUE then the sending side of the connection is shut
             * down, and further writing is disallowed. Subsequent calls to
             * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
             *
             * It is allowed for both `shutdown_read `and `shutdown_write `to be TRUE — this
             * is equivalent to calling g_dtls_connection_close().
             *
             * If `cancellable `is cancelled, the #GDtlsConnection may be left
             * partially-closed and any pending untransmitted data may be lost. Call
             * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
             */
            vfunc_shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously shut down part or all of the DTLS connection. See
             * g_dtls_connection_shutdown() for more information.
             */
            vfunc_shutdown_async(
                shutdown_read: boolean,
                shutdown_write: boolean,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously shut down part or all of the DTLS connection. See
             * g_dtls_connection_shutdown() for more information.
             */
            vfunc_shutdown_async(
                shutdown_read: boolean,
                shutdown_write: boolean,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously shut down part or all of the DTLS connection. See
             * g_dtls_connection_shutdown() for more information.
             */
            vfunc_shutdown_async(
                shutdown_read: boolean,
                shutdown_write: boolean,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finish an asynchronous TLS shutdown operation. See
             * g_dtls_connection_shutdown() for more information.
             */
            vfunc_shutdown_finish(result: AsyncResult): boolean;
        }

        export const DtlsConnection: DtlsConnectionNamespace;

        /**
         * #GDtlsServerConnection is the server-side subclass of #GDtlsConnection,
         * representing a server-side DTLS connection.
         */
        export interface DtlsServerConnectionNamespace {
            $gtype: GObject.GType<DtlsServerConnection>;
            prototype: DtlsServerConnectionPrototype;

            /**
             * Creates a new #GDtlsServerConnection wrapping `base_socket.`
             */
            ["new"](base_socket: DatagramBased, certificate?: TlsCertificate | null): DtlsServerConnection;
        }
        export type DtlsServerConnection = DtlsServerConnectionPrototype;
        export interface DtlsServerConnectionPrototype extends DatagramBased {
            // Properties
            authentication_mode: TlsAuthenticationMode;
            authenticationMode: TlsAuthenticationMode;
        }

        export const DtlsServerConnection: DtlsServerConnectionNamespace;

        /**
         * #GFile is a high level abstraction for manipulating files on a
         * virtual file system. #GFiles are lightweight, immutable objects
         * that do no I/O upon creation. It is necessary to understand that
         * #GFile objects do not represent files, merely an identifier for a
         * file. All file content I/O is implemented as streaming operations
         * (see #GInputStream and #GOutputStream).
         *
         * To construct a #GFile, you can use:
         * - g_file_new_for_path() if you have a path.
         * - g_file_new_for_uri() if you have a URI.
         * - g_file_new_for_commandline_arg() for a command line argument.
         * - g_file_new_tmp() to create a temporary file from a template.
         * - g_file_new_tmp_async() to asynchronously create a temporary file.
         * - g_file_new_tmp_dir_async() to asynchronously create a temporary directory.
         * - g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
         * - g_file_new_build_filename() to create a file from path elements.
         *
         * One way to think of a #GFile is as an abstraction of a pathname. For
         * normal files the system pathname is what is stored internally, but as
         * #GFiles are extensible it could also be something else that corresponds
         * to a pathname in a userspace implementation of a filesystem.
         *
         * #GFiles make up hierarchies of directories and files that correspond to
         * the files on a filesystem. You can move through the file system with
         * #GFile using g_file_get_parent() to get an identifier for the parent
         * directory, g_file_get_child() to get a child within a directory,
         * g_file_resolve_relative_path() to resolve a relative path between two
         * #GFiles. There can be multiple hierarchies, so you may not end up at
         * the same root if you repeatedly call g_file_get_parent() on two different
         * files.
         *
         * All #GFiles have a basename (get with g_file_get_basename()). These names
         * are byte strings that are used to identify the file on the filesystem
         * (relative to its parent directory) and there is no guarantees that they
         * have any particular charset encoding or even make any sense at all. If
         * you want to use filenames in a user interface you should use the display
         * name that you can get by requesting the
         * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
         * This is guaranteed to be in UTF-8 and can be used in a user interface.
         * But always store the real basename or the #GFile to use to actually
         * access the file, because there is no way to go from a display name to
         * the actual name.
         *
         * Using #GFile as an identifier has the same weaknesses as using a path
         * in that there may be multiple aliases for the same file. For instance,
         * hard or soft links may cause two different #GFiles to refer to the same
         * file. Other possible causes for aliases are: case insensitive filesystems,
         * short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
         * check if two #GFiles point to the same file you can query for the
         * %G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
         * canonicalization of pathnames passed in, so that trivial differences in
         * the path string used at creation (duplicated slashes, slash at end of
         * path, "." or ".." path segments, etc) does not create different #GFiles.
         *
         * Many #GFile operations have both synchronous and asynchronous versions
         * to suit your application. Asynchronous versions of synchronous functions
         * simply have _async() appended to their function names. The asynchronous
         * I/O functions call a #GAsyncReadyCallback which is then used to finalize
         * the operation, producing a GAsyncResult which is then passed to the
         * function's matching _finish() operation.
         *
         * It is highly recommended to use asynchronous calls when running within a
         * shared main loop, such as in the main thread of an application. This avoids
         * I/O operations blocking other sources on the main loop from being dispatched.
         * Synchronous I/O operations should be performed from worker threads. See the
         * [introduction to asynchronous programming section][async-programming] for
         * more.
         *
         * Some #GFile operations almost always take a noticeable amount of time, and
         * so do not have synchronous analogs. Notable cases include:
         * - g_file_mount_mountable() to mount a mountable file.
         * - g_file_unmount_mountable_with_operation() to unmount a mountable file.
         * - g_file_eject_mountable_with_operation() to eject a mountable file.
         *
         * ## Entity Tags # {#gfile-etag}
         *
         * One notable feature of #GFiles are entity tags, or "etags" for
         * short. Entity tags are somewhat like a more abstract version of the
         * traditional mtime, and can be used to quickly determine if the file
         * has been modified from the version on the file system. See the
         * HTTP 1.1
         * [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
         * for HTTP Etag headers, which are a very similar concept.
         */
        export interface FileNamespace {
            $gtype: GObject.GType<File>;
            prototype: FilePrototype;

            /**
             * Creates a #GFile with the given argument from the command line.
             * The value of `arg `can be either a URI, an absolute path or a
             * relative path resolved relative to the current working directory.
             * This operation never fails, but the returned object might not
             * support any I/O operation if `arg `points to a malformed path.
             *
             * Note that on Windows, this function expects its argument to be in
             * UTF-8 -- not the system code page.  This means that you
             * should not use this function with string from argv as it is passed
             * to main().  g_win32_get_command_line() will return a UTF-8 version of
             * the commandline.  #GApplication also uses UTF-8 but
             * g_application_command_line_create_file_for_arg() may be more useful
             * for you there.  It is also always possible to use this function with
             * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
             */
            new_for_commandline_arg(arg: string): File;
            /**
             * Creates a #GFile with the given argument from the command line.
             *
             * This function is similar to g_file_new_for_commandline_arg() except
             * that it allows for passing the current working directory as an
             * argument instead of using the current working directory of the
             * process.
             *
             * This is useful if the commandline argument was given in a context
             * other than the invocation of the current process.
             *
             * See also g_application_command_line_create_file_for_arg().
             */
            new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
            /**
             * Constructs a #GFile for a given path. This operation never
             * fails, but the returned object might not support any I/O
             * operation if `path `is malformed.
             */
            new_for_path(path: string): File;
            /**
             * Constructs a #GFile for a given URI. This operation never
             * fails, but the returned object might not support any I/O
             * operation if `uri `is malformed or if the uri type is
             * not supported.
             */
            new_for_uri(uri: string): File;
            /**
             * Opens a file in the preferred directory for temporary files (as
             * returned by g_get_tmp_dir()) and returns a #GFile and
             * #GFileIOStream pointing to it.
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             *
             * Unlike the other #GFile constructors, this will return %NULL if
             * a temporary file could not be created.
             */
            new_tmp(tmpl: string | null): [File, FileIOStream];
            /**
             * Asynchronously opens a file in the preferred directory for temporary files
             * (as returned by g_get_tmp_dir()) as g_file_new_tmp().
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             */
            new_tmp_async(
                tmpl: string | null,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[File, FileIOStream]>;
            /**
             * Asynchronously opens a file in the preferred directory for temporary files
             * (as returned by g_get_tmp_dir()) as g_file_new_tmp().
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             */
            new_tmp_async(
                tmpl: string | null,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<File> | null
            ): void;
            /**
             * Asynchronously opens a file in the preferred directory for temporary files
             * (as returned by g_get_tmp_dir()) as g_file_new_tmp().
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             */
            new_tmp_async(
                tmpl: string | null,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<File> | null
            ): Promise<[File, FileIOStream]> | void;
            /**
             * Asynchronously creates a directory in the preferred directory for
             * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             */
            new_tmp_dir_async(
                tmpl: string | null,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<File>;
            /**
             * Asynchronously creates a directory in the preferred directory for
             * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             */
            new_tmp_dir_async(
                tmpl: string | null,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<File> | null
            ): void;
            /**
             * Asynchronously creates a directory in the preferred directory for
             * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
             *
             * `tmpl `should be a string in the GLib file name encoding
             * containing a sequence of six 'X' characters, and containing no
             * directory components. If it is %NULL, a default template is used.
             */
            new_tmp_dir_async(
                tmpl: string | null,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<File> | null
            ): Promise<File> | void;
            /**
             * Finishes a temporary directory creation started by
             * g_file_new_tmp_dir_async().
             */
            new_tmp_dir_finish(result: AsyncResult): File;
            /**
             * Finishes a temporary file creation started by g_file_new_tmp_async().
             */
            new_tmp_finish(result: AsyncResult): [File, FileIOStream];
            /**
             * Constructs a #GFile with the given `parse_name `(i.e. something
             * given by g_file_get_parse_name()). This operation never fails,
             * but the returned object might not support any I/O operation if
             * the `parse_name `cannot be parsed.
             */
            parse_name(parse_name: string): File;
        }
        export type File = FilePrototype;
        export interface FilePrototype extends GObject.Object {
            // Members

            /**
             * Gets an output stream for appending data to the file.
             * If the file doesn't already exist it is created.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level that
             * is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * Some file systems don't allow all file names, and may return an
             * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
             * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
             * possible too, and depend on what kind of filesystem the file is on.
             */
            append_to(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
            /**
             * Asynchronously opens `file `for appending.
             *
             * For more details, see g_file_append_to() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_append_to_finish() to get the result
             * of the operation.
             */
            append_to_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileOutputStream>;
            /**
             * Asynchronously opens `file `for appending.
             *
             * For more details, see g_file_append_to() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_append_to_finish() to get the result
             * of the operation.
             */
            append_to_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously opens `file `for appending.
             *
             * For more details, see g_file_append_to() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_append_to_finish() to get the result
             * of the operation.
             */
            append_to_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileOutputStream> | void;
            /**
             * Finishes an asynchronous file append operation started with
             * g_file_append_to_async().
             */
            append_to_finish(res: AsyncResult): FileOutputStream;
            /**
             * Prepares the file attribute query string for copying to `file.`
             *
             * This function prepares an attribute query string to be
             * passed to g_file_query_info() to get a list of attributes
             * normally copied with the file (see g_file_copy_attributes()
             * for the detailed description). This function is used by the
             * implementation of g_file_copy_attributes() and is useful
             * when one needs to query and set the attributes in two
             * stages (e.g., for recursive move of a directory).
             */
            build_attribute_list_for_copy(flags: FileCopyFlags, cancellable?: Cancellable | null): string;
            /**
             * Copies the file `source `to the location specified by `destination.`
             * Can not handle recursive copies of directories.
             *
             * If the flag %G_FILE_COPY_OVERWRITE is specified an already
             * existing `destination `file is overwritten.
             *
             * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
             * will be copied as symlinks, otherwise the target of the
             * `source `symlink will be copied.
             *
             * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
             * that is possible to copy is copied, not just the default subset (which,
             * for instance, does not include the owner, see #GFileInfo).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `progress_callback `is not %NULL, then the operation can be monitored
             * by setting this to a #GFileProgressCallback function.
             * `progress_callback_data `will be passed to this function. It is guaranteed
             * that this callback will be called after all data has been transferred with
             * the total number of bytes copied during the operation.
             *
             * If the `source `file does not exist, then the %G_IO_ERROR_NOT_FOUND error
             * is returned, independent on the status of the `destination.`
             *
             * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
             * the error %G_IO_ERROR_EXISTS is returned.
             *
             * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error is returned. If trying to overwrite a directory with a directory the
             * %G_IO_ERROR_WOULD_MERGE error is returned.
             *
             * If the source is a directory and the target does not exist, or
             * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
             * %G_IO_ERROR_WOULD_RECURSE error is returned.
             *
             * If you are interested in copying the #GFile object itself (not the on-disk
             * file), see g_file_dup().
             */
            copy(
                destination: File,
                flags: FileCopyFlags,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null
            ): boolean;
            /**
             * Copies the file `source `to the location specified by destination
             * asynchronously. For details of the behaviour, see g_file_copy().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_copy(). The callback will run in the default main context
             * of the thread calling g_file_copy_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_copy_finish() to get the result of the operation.
             */
            copy_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): void;
            /**
             * Copies the file attributes from `source `to `destination.`
             *
             * Normally only a subset of the file attributes are copied,
             * those that are copies in a normal file copy operation
             * (which for instance does not include e.g. owner). However
             * if %G_FILE_COPY_ALL_METADATA is specified in flags, then
             * all the metadata that is possible to copy is copied. This
             * is useful when implementing move by copy + delete source.
             */
            copy_attributes(destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null): boolean;
            /**
             * Finishes copying the file started with g_file_copy_async().
             */
            copy_finish(res: AsyncResult): boolean;
            /**
             * Creates a new file and returns an output stream for writing to it.
             * The file must not already exist.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level
             * that is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If a file or directory with this name already exists the
             * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
             * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
             * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
             * be returned. Other errors are possible too, and depend on what kind
             * of filesystem the file is on.
             */
            create(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
            /**
             * Asynchronously creates a new file and returns an output stream
             * for writing to it. The file must not already exist.
             *
             * For more details, see g_file_create() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_finish() to get the result
             * of the operation.
             */
            create_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileOutputStream>;
            /**
             * Asynchronously creates a new file and returns an output stream
             * for writing to it. The file must not already exist.
             *
             * For more details, see g_file_create() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_finish() to get the result
             * of the operation.
             */
            create_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a new file and returns an output stream
             * for writing to it. The file must not already exist.
             *
             * For more details, see g_file_create() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_finish() to get the result
             * of the operation.
             */
            create_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileOutputStream> | void;
            /**
             * Finishes an asynchronous file create operation started with
             * g_file_create_async().
             */
            create_finish(res: AsyncResult): FileOutputStream;
            /**
             * Creates a new file and returns a stream for reading and
             * writing to it. The file must not already exist.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level
             * that is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If a file or directory with this name already exists, the
             * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
             * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
             * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
             * will be returned. Other errors are possible too, and depend on what
             * kind of filesystem the file is on.
             *
             * Note that in many non-local file cases read and write streams are
             * not supported, so make sure you really need to do read and write
             * streaming, rather than just opening for reading or writing.
             */
            create_readwrite(flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;
            /**
             * Asynchronously creates a new file and returns a stream
             * for reading and writing to it. The file must not already exist.
             *
             * For more details, see g_file_create_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_readwrite_finish() to get
             * the result of the operation.
             */
            create_readwrite_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileIOStream>;
            /**
             * Asynchronously creates a new file and returns a stream
             * for reading and writing to it. The file must not already exist.
             *
             * For more details, see g_file_create_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_readwrite_finish() to get
             * the result of the operation.
             */
            create_readwrite_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a new file and returns a stream
             * for reading and writing to it. The file must not already exist.
             *
             * For more details, see g_file_create_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_readwrite_finish() to get
             * the result of the operation.
             */
            create_readwrite_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileIOStream> | void;
            /**
             * Finishes an asynchronous file create operation started with
             * g_file_create_readwrite_async().
             */
            create_readwrite_finish(res: AsyncResult): FileIOStream;
            /**
             * Deletes a file. If the `file `is a directory, it will only be
             * deleted if it is empty. This has the same semantics as g_unlink().
             *
             * If `file `doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
             * for deletion to be implemented avoiding
             * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
             * |[
             * g_autoptr(GError) local_error = NULL;
             * if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
             * !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
             * {
             * // deletion failed for some reason other than the file not existing:
             * // so report the error
             * g_warning ("Failed to delete %s: %s",
             * g_file_peek_path (my_file), local_error-&gt;message);
             * }
             * ]|
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            ["delete"](cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously delete a file. If the `file `is a directory, it will
             * only be deleted if it is empty.  This has the same semantics as
             * g_unlink().
             */
            delete_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously delete a file. If the `file `is a directory, it will
             * only be deleted if it is empty.  This has the same semantics as
             * g_unlink().
             */
            delete_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously delete a file. If the `file `is a directory, it will
             * only be deleted if it is empty.  This has the same semantics as
             * g_unlink().
             */
            delete_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes deleting a file started with g_file_delete_async().
             */
            delete_finish(result: AsyncResult): boolean;
            /**
             * Duplicates a #GFile handle. This operation does not duplicate
             * the actual file or directory represented by the #GFile; see
             * g_file_copy() if attempting to copy a file.
             *
             * g_file_dup() is useful when a second handle is needed to the same underlying
             * file, for use in a separate thread (#GFile is not thread-safe). For use
             * within the same thread, use g_object_ref() to increment the existing object’s
             * reference count.
             *
             * This call does no blocking I/O.
             */
            dup(): File;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            eject_mountable(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            eject_mountable(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            eject_mountable(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous eject operation started by
             * g_file_eject_mountable().
             */
            eject_mountable_finish(result: AsyncResult): boolean;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_with_operation_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            eject_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_with_operation_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            eject_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_with_operation_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            eject_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous eject operation started by
             * g_file_eject_mountable_with_operation().
             */
            eject_mountable_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the requested information about the files in a directory.
             * The result is a #GFileEnumerator object that will give out
             * #GFileInfo objects for all the files in the directory.
             *
             * The `attributes `value is a string that specifies the file
             * attributes that should be gathered. It is not an error if
             * it's not possible to read a particular requested attribute
             * from a file - it just won't be set. `attributes `should
             * be a comma-separated list of attributes or attribute wildcards.
             * The wildcard "*" means all attributes, and a wildcard like
             * "standard::*" means all attributes in the standard namespace.
             * An example attribute query be "standard::*,owner::user".
             * The standard attributes are available as defines, like
             * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
             * always be specified if you plan to call g_file_enumerator_get_child() or
             * g_file_enumerator_iterate() on the returned enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
             * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
             * error will be returned. Other errors are possible too.
             */
            enumerate_children(
                attributes: string,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): FileEnumerator;
            /**
             * Asynchronously gets the requested information about the files
             * in a directory. The result is a #GFileEnumerator object that will
             * give out #GFileInfo objects for all the files in the directory.
             *
             * For more details, see g_file_enumerate_children() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_enumerate_children_finish() to get the result of
             * the operation.
             */
            enumerate_children_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileEnumerator>;
            /**
             * Asynchronously gets the requested information about the files
             * in a directory. The result is a #GFileEnumerator object that will
             * give out #GFileInfo objects for all the files in the directory.
             *
             * For more details, see g_file_enumerate_children() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_enumerate_children_finish() to get the result of
             * the operation.
             */
            enumerate_children_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the requested information about the files
             * in a directory. The result is a #GFileEnumerator object that will
             * give out #GFileInfo objects for all the files in the directory.
             *
             * For more details, see g_file_enumerate_children() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_enumerate_children_finish() to get the result of
             * the operation.
             */
            enumerate_children_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileEnumerator> | void;
            /**
             * Finishes an async enumerate children operation.
             * See g_file_enumerate_children_async().
             */
            enumerate_children_finish(res: AsyncResult): FileEnumerator;
            /**
             * Checks if the two given #GFiles refer to the same file.
             *
             * Note that two #GFiles that differ can still refer to the same
             * file on the filesystem due to various forms of filename
             * aliasing.
             *
             * This call does no blocking I/O.
             */
            equal(file2: File): boolean;
            /**
             * Gets a #GMount for the #GFile.
             *
             * #GMount is returned only for user interesting locations, see
             * #GVolumeMonitor. If the #GFileIface for `file `does not have a #mount,
             * `error `will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            find_enclosing_mount(cancellable?: Cancellable | null): Mount;
            /**
             * Asynchronously gets the mount for the file.
             *
             * For more details, see g_file_find_enclosing_mount() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_find_enclosing_mount_finish() to
             * get the result of the operation.
             */
            find_enclosing_mount_async(io_priority: number, cancellable?: Cancellable | null): Promise<Mount>;
            /**
             * Asynchronously gets the mount for the file.
             *
             * For more details, see g_file_find_enclosing_mount() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_find_enclosing_mount_finish() to
             * get the result of the operation.
             */
            find_enclosing_mount_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the mount for the file.
             *
             * For more details, see g_file_find_enclosing_mount() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_find_enclosing_mount_finish() to
             * get the result of the operation.
             */
            find_enclosing_mount_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<Mount> | void;
            /**
             * Finishes an asynchronous find mount request.
             * See g_file_find_enclosing_mount_async().
             */
            find_enclosing_mount_finish(res: AsyncResult): Mount;
            /**
             * Gets the base name (the last component of the path) for a given #GFile.
             *
             * If called for the top level of a system (such as the filesystem root
             * or a uri like sftp://host/) it will return a single directory separator
             * (and on Windows, possibly a drive letter).
             *
             * The base name is a byte string (not UTF-8). It has no defined encoding
             * or rules other than it may not contain zero bytes.  If you want to use
             * filenames in a user interface you should use the display name that you
             * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
             * attribute with g_file_query_info().
             *
             * This call does no blocking I/O.
             */
            get_basename(): string | null;
            /**
             * Gets a child of `file `with basename equal to `name.`
             *
             * Note that the file with that specific name might not exist, but
             * you can still have a #GFile that points to it. You can use this
             * for instance to create that file.
             *
             * This call does no blocking I/O.
             */
            get_child(name: string): File;
            /**
             * Gets the child of `file `for a given `display_name `(i.e. a UTF-8
             * version of the name). If this function fails, it returns %NULL
             * and `error `will be set. This is very useful when constructing a
             * #GFile for a new file and the user entered the filename in the
             * user interface, for instance when you select a directory and
             * type a filename in the file selector.
             *
             * This call does no blocking I/O.
             */
            get_child_for_display_name(display_name: string): File;
            /**
             * Gets the parent directory for the `file.`
             * If the `file `represents the root directory of the
             * file system, then %NULL will be returned.
             *
             * This call does no blocking I/O.
             */
            get_parent(): File | null;
            /**
             * Gets the parse name of the `file.`
             * A parse name is a UTF-8 string that describes the
             * file such that one can get the #GFile back using
             * g_file_parse_name().
             *
             * This is generally used to show the #GFile as a nice
             * full-pathname kind of string in a user interface,
             * like in a location entry.
             *
             * For local files with names that can safely be converted
             * to UTF-8 the pathname is used, otherwise the IRI is used
             * (a form of URI that allows UTF-8 characters unescaped).
             *
             * This call does no blocking I/O.
             */
            get_parse_name(): string;
            /**
             * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
             * guaranteed to be an absolute, canonical path. It might contain symlinks.
             *
             * This call does no blocking I/O.
             */
            get_path(): string | null;
            /**
             * Gets the path for `descendant `relative to `parent.`
             *
             * This call does no blocking I/O.
             */
            get_relative_path(descendant: File): string | null;
            /**
             * Gets the URI for the `file.`
             *
             * This call does no blocking I/O.
             */
            get_uri(): string;
            /**
             * Gets the URI scheme for a #GFile.
             * RFC 3986 decodes the scheme as:
             * |[
             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
             * ]|
             * Common schemes include "file", "http", "ftp", etc.
             *
             * The scheme can be different from the one used to construct the #GFile,
             * in that it might be replaced with one that is logically equivalent to the #GFile.
             *
             * This call does no blocking I/O.
             */
            get_uri_scheme(): string | null;
            /**
             * Checks if `file `has a parent, and optionally, if it is `parent.`
             *
             * If `parent `is %NULL then this function returns %TRUE if `file `has any
             * parent at all.  If `parent `is non-%NULL then %TRUE is only returned
             * if `file `is an immediate child of `parent.`
             */
            has_parent(parent?: File | null): boolean;
            /**
             * Checks whether `file `has the prefix specified by `prefix.`
             *
             * In other words, if the names of initial elements of file's
             * pathname match `prefix.` Only full pathname elements are matched,
             * so a path like /foo is not considered a prefix of /foobar, only
             * of /foo/bar.
             *
             * A #GFile is not a prefix of itself. If you want to check for
             * equality, use g_file_equal().
             *
             * This call does no I/O, as it works purely on names. As such it can
             * sometimes return %FALSE even if `file `is inside a `prefix `(from a
             * filesystem point of view), because the prefix of `file `is an alias
             * of `prefix.`
             */
            has_prefix(prefix: File): boolean;
            /**
             * Checks to see if a #GFile has a given URI scheme.
             *
             * This call does no blocking I/O.
             */
            has_uri_scheme(uri_scheme: string): boolean;
            /**
             * Creates a hash value for a #GFile.
             *
             * This call does no blocking I/O.
             */
            hash(): number;
            /**
             * Checks to see if a file is native to the platform.
             *
             * A native file is one expressed in the platform-native filename format,
             * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
             * as it might be on a locally mounted remote filesystem.
             *
             * On some systems non-native files may be available using the native
             * filesystem via a userspace filesystem (FUSE), in these cases this call
             * will return %FALSE, but g_file_get_path() will still return a native path.
             *
             * This call does no blocking I/O.
             */
            is_native(): boolean;
            /**
             * Loads the contents of `file `and returns it as #GBytes.
             *
             * If `file `is a resource:// based URI, the resulting bytes will reference the
             * embedded resource instead of a copy. Otherwise, this is equivalent to calling
             * g_file_load_contents() and g_bytes_new_take().
             *
             * For resources, `etag_out `will be set to %NULL.
             *
             * The data contained in the resulting #GBytes is always zero-terminated, but
             * this is not included in the #GBytes length. The resulting #GBytes should be
             * freed with g_bytes_unref() when no longer in use.
             */
            load_bytes(cancellable: Cancellable | null): [GLib.Bytes, string];
            /**
             * Asynchronously loads the contents of `file `as #GBytes.
             *
             * If `file `is a resource:// based URI, the resulting bytes will reference the
             * embedded resource instead of a copy. Otherwise, this is equivalent to calling
             * g_file_load_contents_async() and g_bytes_new_take().
             *
             * `callback `should call g_file_load_bytes_finish() to get the result of this
             * asynchronous operation.
             *
             * See g_file_load_bytes() for more information.
             */
            load_bytes_async(cancellable?: Cancellable | null): Promise<[GLib.Bytes, string]>;
            /**
             * Asynchronously loads the contents of `file `as #GBytes.
             *
             * If `file `is a resource:// based URI, the resulting bytes will reference the
             * embedded resource instead of a copy. Otherwise, this is equivalent to calling
             * g_file_load_contents_async() and g_bytes_new_take().
             *
             * `callback `should call g_file_load_bytes_finish() to get the result of this
             * asynchronous operation.
             *
             * See g_file_load_bytes() for more information.
             */
            load_bytes_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronously loads the contents of `file `as #GBytes.
             *
             * If `file `is a resource:// based URI, the resulting bytes will reference the
             * embedded resource instead of a copy. Otherwise, this is equivalent to calling
             * g_file_load_contents_async() and g_bytes_new_take().
             *
             * `callback `should call g_file_load_bytes_finish() to get the result of this
             * asynchronous operation.
             *
             * See g_file_load_bytes() for more information.
             */
            load_bytes_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[GLib.Bytes, string]> | void;
            /**
             * Completes an asynchronous request to g_file_load_bytes_async().
             *
             * For resources, `etag_out `will be set to %NULL.
             *
             * The data contained in the resulting #GBytes is always zero-terminated, but
             * this is not included in the #GBytes length. The resulting #GBytes should be
             * freed with g_bytes_unref() when no longer in use.
             *
             * See g_file_load_bytes() for more information.
             */
            load_bytes_finish(result: AsyncResult): [GLib.Bytes, string];
            /**
             * Loads the content of the file into memory. The data is always
             * zero-terminated, but this is not included in the resultant `length.`
             * The returned `contents `should be freed with g_free() when no longer
             * needed.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            load_contents(cancellable: Cancellable | null): [boolean, Uint8Array, string];
            /**
             * Starts an asynchronous load of the file's contents.
             *
             * For more details, see g_file_load_contents() which is
             * the synchronous version of this call.
             *
             * When the load operation has completed, `callback `will be called
             * with `user `data. To finish the operation, call
             * g_file_load_contents_finish() with the #GAsyncResult returned by
             * the `callback.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            load_contents_async(cancellable?: Cancellable | null): Promise<[Uint8Array, string]>;
            /**
             * Starts an asynchronous load of the file's contents.
             *
             * For more details, see g_file_load_contents() which is
             * the synchronous version of this call.
             *
             * When the load operation has completed, `callback `will be called
             * with `user `data. To finish the operation, call
             * g_file_load_contents_finish() with the #GAsyncResult returned by
             * the `callback.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            load_contents_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Starts an asynchronous load of the file's contents.
             *
             * For more details, see g_file_load_contents() which is
             * the synchronous version of this call.
             *
             * When the load operation has completed, `callback `will be called
             * with `user `data. To finish the operation, call
             * g_file_load_contents_finish() with the #GAsyncResult returned by
             * the `callback.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            load_contents_async(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[Uint8Array, string]> | void;
            /**
             * Finishes an asynchronous load of the file's contents.
             * The contents are placed in contents, and `length `is set to the
             * size of the `contents `string. The `contents `should be freed with
             * g_free() when no longer needed. If `etag_out `is present, it will be
             * set to the new entity tag for the `file.`
             */
            load_contents_finish(res: AsyncResult): [boolean, Uint8Array, string];
            /**
             * Finishes an asynchronous partial load operation that was started
             * with g_file_load_partial_contents_async(). The data is always
             * zero-terminated, but this is not included in the resultant `length.`
             * The returned `contents `should be freed with g_free() when no longer
             * needed.
             */
            load_partial_contents_finish(res: AsyncResult): [boolean, Uint8Array, string];
            /**
             * Creates a directory. Note that this will only create a child directory
             * of the immediate parent directory of the path or URI given by the #GFile.
             * To recursively create directories, see g_file_make_directory_with_parents().
             * This function will fail if the parent directory does not exist, setting
             * `error `to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
             * creating directories, this function will fail, setting `error `to
             * %G_IO_ERROR_NOT_SUPPORTED.
             *
             * For a local #GFile the newly created directory will have the default
             * (current) ownership and permissions of the current process.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            make_directory(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously creates a directory.
             */
            make_directory_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously creates a directory.
             */
            make_directory_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a directory.
             */
            make_directory_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous directory creation, started with
             * g_file_make_directory_async().
             */
            make_directory_finish(result: AsyncResult): boolean;
            /**
             * Creates a directory and any parent directories that may not
             * exist similar to 'mkdir -p'. If the file system does not support
             * creating directories, this function will fail, setting `error `to
             * %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
             * this function will fail setting `error `to %G_IO_ERROR_EXISTS, unlike
             * the similar g_mkdir_with_parents().
             *
             * For a local #GFile the newly created directories will have the default
             * (current) ownership and permissions of the current process.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            make_directory_with_parents(cancellable?: Cancellable | null): boolean;
            /**
             * Creates a symbolic link named `file `which contains the string
             * `symlink_value.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            make_symbolic_link(symlink_value: string, cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously creates a symbolic link named `file `which contains the
             * string `symlink_value.`
             */
            make_symbolic_link_async(
                symlink_value: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously creates a symbolic link named `file `which contains the
             * string `symlink_value.`
             */
            make_symbolic_link_async(
                symlink_value: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a symbolic link named `file `which contains the
             * string `symlink_value.`
             */
            make_symbolic_link_async(
                symlink_value: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous symbolic link creation, started with
             * g_file_make_symbolic_link_async().
             */
            make_symbolic_link_finish(result: AsyncResult): boolean;
            /**
             * Collects the results from an earlier call to
             * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
             * more information.
             */
            measure_disk_usage_finish(result: AsyncResult): [boolean, number, number, number];
            /**
             * Obtains a file or directory monitor for the given file,
             * depending on the type of the file.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            monitor(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
            /**
             * Obtains a directory monitor for the given file.
             * This may fail if directory monitoring is not supported.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * It does not make sense for `flags `to contain
             * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
             * directories.  It is not possible to monitor all the files in a
             * directory for changes made via hard links; if you want to do this then
             * you must register individual watches with g_file_monitor().
             */
            monitor_directory(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
            /**
             * Obtains a file monitor for the given file. If no file notification
             * mechanism exists, then regular polling of the file is used.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `flags `contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
             * will also attempt to report changes made to the file via another
             * filename (ie, a hard link). Without this flag, you can only rely on
             * changes made through the filename contained in `file `to be
             * reported. Using this flag may result in an increase in resource
             * usage, and may not have any effect depending on the #GFileMonitor
             * backend and/or filesystem type.
             */
            monitor_file(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
            /**
             * Starts a mount_operation, mounting the volume that contains
             * the file `location.`
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_mount_enclosing_volume_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            mount_enclosing_volume(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Starts a mount_operation, mounting the volume that contains
             * the file `location.`
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_mount_enclosing_volume_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            mount_enclosing_volume(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts a mount_operation, mounting the volume that contains
             * the file `location.`
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_mount_enclosing_volume_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            mount_enclosing_volume(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a mount operation started by g_file_mount_enclosing_volume().
             */
            mount_enclosing_volume_finish(result: AsyncResult): boolean;
            /**
             * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
             * Using mount_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            mount_mountable(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<File>;
            /**
             * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
             * Using mount_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            mount_mountable(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
             * Using mount_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            mount_mountable(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<File> | void;
            /**
             * Finishes a mount operation. See g_file_mount_mountable() for details.
             *
             * Finish an asynchronous mount operation that was started
             * with g_file_mount_mountable().
             */
            mount_mountable_finish(result: AsyncResult): File;
            /**
             * Tries to move the file or directory `source `to the location specified
             * by `destination.` If native move operations are supported then this is
             * used, otherwise a copy + delete fallback is used. The native
             * implementation may support moving directories (for instance on moves
             * inside the same filesystem), but the fallback code does not.
             *
             * If the flag %G_FILE_COPY_OVERWRITE is specified an already
             * existing `destination `file is overwritten.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `progress_callback `is not %NULL, then the operation can be monitored
             * by setting this to a #GFileProgressCallback function.
             * `progress_callback_data `will be passed to this function. It is
             * guaranteed that this callback will be called after all data has been
             * transferred with the total number of bytes copied during the operation.
             *
             * If the `source `file does not exist, then the %G_IO_ERROR_NOT_FOUND
             * error is returned, independent on the status of the `destination.`
             *
             * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
             * then the error %G_IO_ERROR_EXISTS is returned.
             *
             * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error is returned. If trying to overwrite a directory with a directory the
             * %G_IO_ERROR_WOULD_MERGE error is returned.
             *
             * If the source is a directory and the target does not exist, or
             * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
             * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
             * move operation isn't available).
             */
            move(
                destination: File,
                flags: FileCopyFlags,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null
            ): boolean;
            /**
             * Asynchronously moves a file `source `to the location of `destination.` For details of the behaviour, see g_file_move().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_move(). The callback will run in the default main context
             * of the thread calling g_file_move_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_move_finish() to get the result of the operation.
             */
            move_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null
            ): Promise<boolean>;
            /**
             * Asynchronously moves a file `source `to the location of `destination.` For details of the behaviour, see g_file_move().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_move(). The callback will run in the default main context
             * of the thread calling g_file_move_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_move_finish() to get the result of the operation.
             */
            move_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                progress_callback: FileProgressCallback | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously moves a file `source `to the location of `destination.` For details of the behaviour, see g_file_move().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_move(). The callback will run in the default main context
             * of the thread calling g_file_move_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_move_finish() to get the result of the operation.
             */
            move_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous file movement, started with
             * g_file_move_async().
             */
            move_finish(result: AsyncResult): boolean;
            /**
             * Opens an existing file for reading and writing. The result is
             * a #GFileIOStream that can be used to read and write the contents
             * of the file.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
             * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error will be returned. Other errors are possible too, and depend on
             * what kind of filesystem the file is on. Note that in many non-local
             * file cases read and write streams are not supported, so make sure you
             * really need to do read and write streaming, rather than just opening
             * for reading or writing.
             */
            open_readwrite(cancellable?: Cancellable | null): FileIOStream;
            /**
             * Asynchronously opens `file `for reading and writing.
             *
             * For more details, see g_file_open_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_open_readwrite_finish() to get
             * the result of the operation.
             */
            open_readwrite_async(io_priority: number, cancellable?: Cancellable | null): Promise<FileIOStream>;
            /**
             * Asynchronously opens `file `for reading and writing.
             *
             * For more details, see g_file_open_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_open_readwrite_finish() to get
             * the result of the operation.
             */
            open_readwrite_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously opens `file `for reading and writing.
             *
             * For more details, see g_file_open_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_open_readwrite_finish() to get
             * the result of the operation.
             */
            open_readwrite_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileIOStream> | void;
            /**
             * Finishes an asynchronous file read operation started with
             * g_file_open_readwrite_async().
             */
            open_readwrite_finish(res: AsyncResult): FileIOStream;
            /**
             * Exactly like g_file_get_path(), but caches the result via
             * g_object_set_qdata_full().  This is useful for example in C
             * applications which mix `g_file_*` APIs with native ones.  It
             * also avoids an extra duplicated string when possible, so will be
             * generally more efficient.
             *
             * This call does no blocking I/O.
             */
            peek_path(): string | null;
            /**
             * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            poll_mountable(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            poll_mountable(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            poll_mountable(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a poll operation. See g_file_poll_mountable() for details.
             *
             * Finish an asynchronous poll operation that was polled
             * with g_file_poll_mountable().
             */
            poll_mountable_finish(result: AsyncResult): boolean;
            /**
             * Returns the #GAppInfo that is registered as the default
             * application to handle the file specified by `file.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            query_default_handler(cancellable?: Cancellable | null): AppInfo;
            /**
             * Async version of g_file_query_default_handler().
             */
            query_default_handler_async(io_priority: number, cancellable?: Cancellable | null): Promise<AppInfo>;
            /**
             * Async version of g_file_query_default_handler().
             */
            query_default_handler_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Async version of g_file_query_default_handler().
             */
            query_default_handler_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<AppInfo> | void;
            /**
             * Finishes a g_file_query_default_handler_async() operation.
             */
            query_default_handler_finish(result: AsyncResult): AppInfo;
            /**
             * Utility function to check if a particular file exists. This is
             * implemented using g_file_query_info() and as such does blocking I/O.
             *
             * Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
             * and then execute something based on the outcome of that, because the
             * file might have been created or removed in between the operations. The
             * general approach to handling that is to not check, but just do the
             * operation and handle the errors as they come.
             *
             * As an example of race-free checking, take the case of reading a file,
             * and if it doesn't exist, creating it. There are two racy versions: read
             * it, and on error create it; and: check if it exists, if not create it.
             * These can both result in two processes creating the file (with perhaps
             * a partially written file as the result). The correct approach is to
             * always try to create the file with g_file_create() which will either
             * atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
             *
             * However, in many cases an existence check is useful in a user interface,
             * for instance to make a menu item sensitive/insensitive, so that you don't
             * have to fool users that something is possible and then just show an error
             * dialog. If you do this, you should make sure to also handle the errors
             * that can happen due to races when you execute the operation.
             */
            query_exists(cancellable?: Cancellable | null): boolean;
            /**
             * Utility function to inspect the #GFileType of a file. This is
             * implemented using g_file_query_info() and as such does blocking I/O.
             *
             * The primary use case of this method is to check if a file is
             * a regular file, directory, or symlink.
             */
            query_file_type(flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileType;
            /**
             * Similar to g_file_query_info(), but obtains information
             * about the filesystem the `file `is on, rather than the file itself.
             * For instance the amount of space available and the type of
             * the filesystem.
             *
             * The `attributes `value is a string that specifies the attributes
             * that should be gathered. It is not an error if it's not possible
             * to read a particular requested attribute from a file - it just
             * won't be set. `attributes `should be a comma-separated list of
             * attributes or attribute wildcards. The wildcard "*" means all
             * attributes, and a wildcard like "filesystem::*" means all attributes
             * in the filesystem namespace. The standard namespace for filesystem
             * attributes is "filesystem". Common attributes of interest are
             * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
             * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
             * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
             * be returned. Other errors are possible too, and depend on what
             * kind of filesystem the file is on.
             */
            query_filesystem_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously gets the requested information about the filesystem
             * that the specified `file `is on. The result is a #GFileInfo object
             * that contains key-value attributes (such as type or size for the
             * file).
             *
             * For more details, see g_file_query_filesystem_info() which is the
             * synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the
             * operation.
             */
            query_filesystem_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously gets the requested information about the filesystem
             * that the specified `file `is on. The result is a #GFileInfo object
             * that contains key-value attributes (such as type or size for the
             * file).
             *
             * For more details, see g_file_query_filesystem_info() which is the
             * synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the
             * operation.
             */
            query_filesystem_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the requested information about the filesystem
             * that the specified `file `is on. The result is a #GFileInfo object
             * that contains key-value attributes (such as type or size for the
             * file).
             *
             * For more details, see g_file_query_filesystem_info() which is the
             * synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the
             * operation.
             */
            query_filesystem_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finishes an asynchronous filesystem info query.
             * See g_file_query_filesystem_info_async().
             */
            query_filesystem_info_finish(res: AsyncResult): FileInfo;
            /**
             * Gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value
             * attributes (such as the type or size of the file).
             *
             * The `attributes `value is a string that specifies the file
             * attributes that should be gathered. It is not an error if
             * it's not possible to read a particular requested attribute
             * from a file - it just won't be set. `attributes `should be a
             * comma-separated list of attributes or attribute wildcards.
             * The wildcard "*" means all attributes, and a wildcard like
             * "standard::*" means all attributes in the standard namespace.
             * An example attribute query be "standard::*,owner::user".
             * The standard attributes are available as defines, like
             * %G_FILE_ATTRIBUTE_STANDARD_NAME.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * For symlinks, normally the information about the target of the
             * symlink is returned, rather than information about the symlink
             * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
             * in `flags `the information about the symlink itself will be returned.
             * Also, for symlinks that point to non-existing files the information
             * about the symlink itself will be returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
             * returned. Other errors are possible too, and depend on what kind of
             * filesystem the file is on.
             */
            query_info(attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value attributes
             * (such as type or size for the file).
             *
             * For more details, see g_file_query_info() which is the synchronous
             * version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the operation.
             */
            query_info_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value attributes
             * (such as type or size for the file).
             *
             * For more details, see g_file_query_info() which is the synchronous
             * version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the operation.
             */
            query_info_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value attributes
             * (such as type or size for the file).
             *
             * For more details, see g_file_query_info() which is the synchronous
             * version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the operation.
             */
            query_info_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finishes an asynchronous file info query.
             * See g_file_query_info_async().
             */
            query_info_finish(res: AsyncResult): FileInfo;
            /**
             * Obtain the list of settable attributes for the file.
             *
             * Returns the type and full attribute name of all the attributes
             * that can be set on this file. This doesn't mean setting it will
             * always succeed though, you might get an access failure, or some
             * specific file may not support a specific attribute.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            query_settable_attributes(cancellable?: Cancellable | null): FileAttributeInfoList;
            /**
             * Obtain the list of attribute namespaces where new attributes
             * can be created by a user. An example of this is extended
             * attributes (in the "xattr" namespace).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            query_writable_namespaces(cancellable?: Cancellable | null): FileAttributeInfoList;
            /**
             * Opens a file for reading. The result is a #GFileInputStream that
             * can be used to read the contents of the file.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
             * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error will be returned. Other errors are possible too, and depend
             * on what kind of filesystem the file is on.
             */
            read(cancellable?: Cancellable | null): FileInputStream;
            /**
             * Asynchronously opens `file `for reading.
             *
             * For more details, see g_file_read() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_read_finish() to get the result
             * of the operation.
             */
            read_async(io_priority: number, cancellable?: Cancellable | null): Promise<FileInputStream>;
            /**
             * Asynchronously opens `file `for reading.
             *
             * For more details, see g_file_read() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_read_finish() to get the result
             * of the operation.
             */
            read_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously opens `file `for reading.
             *
             * For more details, see g_file_read() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_read_finish() to get the result
             * of the operation.
             */
            read_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInputStream> | void;
            /**
             * Finishes an asynchronous file read operation started with
             * g_file_read_async().
             */
            read_finish(res: AsyncResult): FileInputStream;
            /**
             * Returns an output stream for overwriting the file, possibly
             * creating a backup copy of the file first. If the file doesn't exist,
             * it will be created.
             *
             * This will try to replace the file in the safest way possible so
             * that any errors during the writing will not affect an already
             * existing copy of the file. For instance, for local files it
             * may write to a temporary file and then atomically rename over
             * the destination when the stream is closed.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level that
             * is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If you pass in a non-%NULL `etag `value and `file `already exists, then
             * this value is compared to the current entity tag of the file, and if
             * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
             * generally means that the file has been changed since you last read
             * it. You can get the new etag from g_file_output_stream_get_etag()
             * after you've finished writing and closed the #GFileOutputStream. When
             * you load a new file you can use g_file_input_stream_query_info() to
             * get the etag of the file.
             *
             * If `make_backup `is %TRUE, this function will attempt to make a
             * backup of the current file before overwriting it. If this fails
             * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
             * want to replace anyway, try again with `make_backup `set to %FALSE.
             *
             * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
             * be returned, and if the file is some other form of non-regular file
             * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
             * file systems don't allow all file names, and may return an
             * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
             * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
             * possible too, and depend on what kind of filesystem the file is on.
             */
            replace(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null
            ): FileOutputStream;
            /**
             * Asynchronously overwrites the file, replacing the contents,
             * possibly creating a backup copy of the file first.
             *
             * For more details, see g_file_replace() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_finish() to get the result
             * of the operation.
             */
            replace_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileOutputStream>;
            /**
             * Asynchronously overwrites the file, replacing the contents,
             * possibly creating a backup copy of the file first.
             *
             * For more details, see g_file_replace() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_finish() to get the result
             * of the operation.
             */
            replace_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously overwrites the file, replacing the contents,
             * possibly creating a backup copy of the file first.
             *
             * For more details, see g_file_replace() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_finish() to get the result
             * of the operation.
             */
            replace_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileOutputStream> | void;
            /**
             * Replaces the contents of `file `with `contents `of `length `bytes.
             *
             * If `etag `is specified (not %NULL), any existing file must have that etag,
             * or the error %G_IO_ERROR_WRONG_ETAG will be returned.
             *
             * If `make_backup `is %TRUE, this function will attempt to make a backup
             * of `file.` Internally, it uses g_file_replace(), so will try to replace the
             * file contents in the safest way possible. For example, atomic renames are
             * used when replacing local files’ contents.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * The returned `new_etag `can be used to verify that the file hasn't
             * changed the next time it is saved over.
             */
            replace_contents(
                contents: Uint8Array | string,
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null
            ): [boolean, string];
            /**
             * Starts an asynchronous replacement of `file `with the given
             * `contents `of `length `bytes. `etag `will replace the document's
             * current entity tag.
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_replace_contents_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `make_backup `is %TRUE, this function will attempt to
             * make a backup of `file.`
             *
             * Note that no copy of `contents `will be made, so it must stay valid
             * until `callback `is called. See g_file_replace_contents_bytes_async()
             * for a #GBytes version that will automatically hold a reference to the
             * contents (without copying) for the duration of the call.
             */
            replace_contents_async(
                contents: Uint8Array | string,
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null
            ): Promise<[string]>;
            /**
             * Starts an asynchronous replacement of `file `with the given
             * `contents `of `length `bytes. `etag `will replace the document's
             * current entity tag.
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_replace_contents_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `make_backup `is %TRUE, this function will attempt to
             * make a backup of `file.`
             *
             * Note that no copy of `contents `will be made, so it must stay valid
             * until `callback `is called. See g_file_replace_contents_bytes_async()
             * for a #GBytes version that will automatically hold a reference to the
             * contents (without copying) for the duration of the call.
             */
            replace_contents_async(
                contents: Uint8Array | string,
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts an asynchronous replacement of `file `with the given
             * `contents `of `length `bytes. `etag `will replace the document's
             * current entity tag.
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_replace_contents_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `make_backup `is %TRUE, this function will attempt to
             * make a backup of `file.`
             *
             * Note that no copy of `contents `will be made, so it must stay valid
             * until `callback `is called. See g_file_replace_contents_bytes_async()
             * for a #GBytes version that will automatically hold a reference to the
             * contents (without copying) for the duration of the call.
             */
            replace_contents_async(
                contents: Uint8Array | string,
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[string]> | void;
            /**
             * Same as g_file_replace_contents_async() but takes a #GBytes input instead.
             * This function will keep a ref on `contents `until the operation is done.
             * Unlike g_file_replace_contents_async() this allows forgetting about the
             * content without waiting for the callback.
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_replace_contents_finish().
             */
            replace_contents_bytes_async(
                contents: GLib.Bytes | Uint8Array,
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Finishes an asynchronous replace of the given `file.` See
             * g_file_replace_contents_async(). Sets `new_etag `to the new entity
             * tag for the document, if present.
             */
            replace_contents_finish(res: AsyncResult): [boolean, string];
            /**
             * Finishes an asynchronous file replace operation started with
             * g_file_replace_async().
             */
            replace_finish(res: AsyncResult): FileOutputStream;
            /**
             * Returns an output stream for overwriting the file in readwrite mode,
             * possibly creating a backup copy of the file first. If the file doesn't
             * exist, it will be created.
             *
             * For details about the behaviour, see g_file_replace() which does the
             * same thing but returns an output stream only.
             *
             * Note that in many non-local file cases read and write streams are not
             * supported, so make sure you really need to do read and write streaming,
             * rather than just opening for reading or writing.
             */
            replace_readwrite(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null
            ): FileIOStream;
            /**
             * Asynchronously overwrites the file in read-write mode,
             * replacing the contents, possibly creating a backup copy
             * of the file first.
             *
             * For more details, see g_file_replace_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_readwrite_finish() to get
             * the result of the operation.
             */
            replace_readwrite_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileIOStream>;
            /**
             * Asynchronously overwrites the file in read-write mode,
             * replacing the contents, possibly creating a backup copy
             * of the file first.
             *
             * For more details, see g_file_replace_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_readwrite_finish() to get
             * the result of the operation.
             */
            replace_readwrite_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously overwrites the file in read-write mode,
             * replacing the contents, possibly creating a backup copy
             * of the file first.
             *
             * For more details, see g_file_replace_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_readwrite_finish() to get
             * the result of the operation.
             */
            replace_readwrite_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileIOStream> | void;
            /**
             * Finishes an asynchronous file replace operation started with
             * g_file_replace_readwrite_async().
             */
            replace_readwrite_finish(res: AsyncResult): FileIOStream;
            /**
             * Resolves a relative path for `file `to an absolute path.
             *
             * This call does no blocking I/O.
             *
             * If the `relative_path `is an absolute path name, the resolution
             * is done absolutely (without taking `file `path as base).
             */
            resolve_relative_path(relative_path: string): File;
            /**
             * Sets an attribute in the file with attribute name `attribute `to `value_p.`
             *
             * Some attributes can be unset by setting `type `to
             * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p `to %NULL.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute(
                attribute: string,
                type: FileAttributeType,
                value_p: any | null,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Sets `attribute `of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to `value.`
             * If `attribute `is of a different type, this operation will fail,
             * returning %FALSE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute_byte_string(
                attribute: string,
                value: string,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Sets `attribute `of type %G_FILE_ATTRIBUTE_TYPE_INT32 to `value.`
             * If `attribute `is of a different type, this operation will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute_int32(
                attribute: string,
                value: number,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Sets `attribute `of type %G_FILE_ATTRIBUTE_TYPE_INT64 to `value.`
             * If `attribute `is of a different type, this operation will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute_int64(
                attribute: string,
                value: number,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Sets `attribute `of type %G_FILE_ATTRIBUTE_TYPE_STRING to `value.`
             * If `attribute `is of a different type, this operation will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute_string(
                attribute: string,
                value: string,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Sets `attribute `of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to `value.`
             * If `attribute `is of a different type, this operation will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute_uint32(
                attribute: string,
                value: number,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Sets `attribute `of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to `value.`
             * If `attribute `is of a different type, this operation will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attribute_uint64(
                attribute: string,
                value: number,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Asynchronously sets the attributes of `file `with `info.`
             *
             * For more details, see g_file_set_attributes_from_info(),
             * which is the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_attributes_finish() to get
             * the result of the operation.
             */
            set_attributes_async(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[FileInfo]>;
            /**
             * Asynchronously sets the attributes of `file `with `info.`
             *
             * For more details, see g_file_set_attributes_from_info(),
             * which is the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_attributes_finish() to get
             * the result of the operation.
             */
            set_attributes_async(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously sets the attributes of `file `with `info.`
             *
             * For more details, see g_file_set_attributes_from_info(),
             * which is the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_attributes_finish() to get
             * the result of the operation.
             */
            set_attributes_async(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[FileInfo]> | void;
            /**
             * Finishes setting an attribute started in g_file_set_attributes_async().
             */
            set_attributes_finish(result: AsyncResult): [boolean, FileInfo];
            /**
             * Tries to set all attributes in the #GFileInfo on the target
             * values, not stopping on the first error.
             *
             * If there is any error during this operation then `error `will
             * be set to the first error. Error on particular fields are flagged
             * by setting the "status" field in the attribute value to
             * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
             * also detect further errors.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_attributes_from_info(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Renames `file `to the specified display name.
             *
             * The display name is converted from UTF-8 to the correct encoding
             * for the target filesystem if possible and the `file `is renamed to this.
             *
             * If you want to implement a rename operation in the user interface the
             * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
             * initial value in the rename widget, and then the result after editing
             * should be passed to g_file_set_display_name().
             *
             * On success the resulting converted filename is returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            set_display_name(display_name: string, cancellable?: Cancellable | null): File;
            /**
             * Asynchronously sets the display name for a given #GFile.
             *
             * For more details, see g_file_set_display_name() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_display_name_finish() to get
             * the result of the operation.
             */
            set_display_name_async(
                display_name: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<File>;
            /**
             * Asynchronously sets the display name for a given #GFile.
             *
             * For more details, see g_file_set_display_name() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_display_name_finish() to get
             * the result of the operation.
             */
            set_display_name_async(
                display_name: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously sets the display name for a given #GFile.
             *
             * For more details, see g_file_set_display_name() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_display_name_finish() to get
             * the result of the operation.
             */
            set_display_name_async(
                display_name: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<File> | void;
            /**
             * Finishes setting a display name started with
             * g_file_set_display_name_async().
             */
            set_display_name_finish(res: AsyncResult): File;
            /**
             * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
             * Using start_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            start_mountable(
                flags: DriveStartFlags,
                start_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
             * Using start_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            start_mountable(
                flags: DriveStartFlags,
                start_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
             * Using start_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            start_mountable(
                flags: DriveStartFlags,
                start_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a start operation. See g_file_start_mountable() for details.
             *
             * Finish an asynchronous start operation that was started
             * with g_file_start_mountable().
             */
            start_mountable_finish(result: AsyncResult): boolean;
            /**
             * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_stop_mountable_finish() to get
             * the result of the operation.
             */
            stop_mountable(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_stop_mountable_finish() to get
             * the result of the operation.
             */
            stop_mountable(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_stop_mountable_finish() to get
             * the result of the operation.
             */
            stop_mountable(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a stop operation, see g_file_stop_mountable() for details.
             *
             * Finish an asynchronous stop operation that was started
             * with g_file_stop_mountable().
             */
            stop_mountable_finish(result: AsyncResult): boolean;
            /**
             * Checks if `file `supports
             * [thread-default contexts][g-main-context-push-thread-default-context].
             * If this returns %FALSE, you cannot perform asynchronous operations on
             * `file `in a thread that has a thread-default context.
             */
            supports_thread_contexts(): boolean;
            /**
             * Sends `file `to the "Trashcan", if possible. This is similar to
             * deleting it, but the user can recover it before emptying the trashcan.
             * Not all file systems support trashing, so this call can return the
             * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
             * mount option can be used to disable g_file_trash() support for certain
             * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            trash(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously sends `file `to the Trash location, if possible.
             */
            trash_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously sends `file `to the Trash location, if possible.
             */
            trash_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously sends `file `to the Trash location, if possible.
             */
            trash_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous file trashing operation, started with
             * g_file_trash_async().
             */
            trash_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            unmount_mountable(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            unmount_mountable(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            unmount_mountable(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an unmount operation, see g_file_unmount_mountable() for details.
             *
             * Finish an asynchronous unmount operation that was started
             * with g_file_unmount_mountable().
             */
            unmount_mountable_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            unmount_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            unmount_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            unmount_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an unmount operation,
             * see g_file_unmount_mountable_with_operation() for details.
             *
             * Finish an asynchronous unmount operation that was started
             * with g_file_unmount_mountable_with_operation().
             */
            unmount_mountable_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets an output stream for appending data to the file.
             * If the file doesn't already exist it is created.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level that
             * is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * Some file systems don't allow all file names, and may return an
             * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
             * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
             * possible too, and depend on what kind of filesystem the file is on.
             */
            vfunc_append_to(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
            /**
             * Asynchronously opens `file `for appending.
             *
             * For more details, see g_file_append_to() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_append_to_finish() to get the result
             * of the operation.
             */
            vfunc_append_to_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileOutputStream>;
            /**
             * Asynchronously opens `file `for appending.
             *
             * For more details, see g_file_append_to() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_append_to_finish() to get the result
             * of the operation.
             */
            vfunc_append_to_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously opens `file `for appending.
             *
             * For more details, see g_file_append_to() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_append_to_finish() to get the result
             * of the operation.
             */
            vfunc_append_to_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileOutputStream> | void;
            /**
             * Finishes an asynchronous file append operation started with
             * g_file_append_to_async().
             */
            vfunc_append_to_finish(res: AsyncResult): FileOutputStream;
            /**
             * Copies the file `source `to the location specified by `destination.`
             * Can not handle recursive copies of directories.
             *
             * If the flag %G_FILE_COPY_OVERWRITE is specified an already
             * existing `destination `file is overwritten.
             *
             * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
             * will be copied as symlinks, otherwise the target of the
             * `source `symlink will be copied.
             *
             * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
             * that is possible to copy is copied, not just the default subset (which,
             * for instance, does not include the owner, see #GFileInfo).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `progress_callback `is not %NULL, then the operation can be monitored
             * by setting this to a #GFileProgressCallback function.
             * `progress_callback_data `will be passed to this function. It is guaranteed
             * that this callback will be called after all data has been transferred with
             * the total number of bytes copied during the operation.
             *
             * If the `source `file does not exist, then the %G_IO_ERROR_NOT_FOUND error
             * is returned, independent on the status of the `destination.`
             *
             * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
             * the error %G_IO_ERROR_EXISTS is returned.
             *
             * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error is returned. If trying to overwrite a directory with a directory the
             * %G_IO_ERROR_WOULD_MERGE error is returned.
             *
             * If the source is a directory and the target does not exist, or
             * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
             * %G_IO_ERROR_WOULD_RECURSE error is returned.
             *
             * If you are interested in copying the #GFile object itself (not the on-disk
             * file), see g_file_dup().
             */
            vfunc_copy(
                destination: File,
                flags: FileCopyFlags,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null
            ): boolean;
            /**
             * Copies the file `source `to the location specified by destination
             * asynchronously. For details of the behaviour, see g_file_copy().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_copy(). The callback will run in the default main context
             * of the thread calling g_file_copy_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_copy_finish() to get the result of the operation.
             */
            vfunc_copy_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): void;
            /**
             * Finishes copying the file started with g_file_copy_async().
             */
            vfunc_copy_finish(res: AsyncResult): boolean;
            /**
             * Creates a new file and returns an output stream for writing to it.
             * The file must not already exist.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level
             * that is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If a file or directory with this name already exists the
             * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
             * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
             * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
             * be returned. Other errors are possible too, and depend on what kind
             * of filesystem the file is on.
             */
            vfunc_create(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
            /**
             * Asynchronously creates a new file and returns an output stream
             * for writing to it. The file must not already exist.
             *
             * For more details, see g_file_create() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_finish() to get the result
             * of the operation.
             */
            vfunc_create_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileOutputStream>;
            /**
             * Asynchronously creates a new file and returns an output stream
             * for writing to it. The file must not already exist.
             *
             * For more details, see g_file_create() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_finish() to get the result
             * of the operation.
             */
            vfunc_create_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a new file and returns an output stream
             * for writing to it. The file must not already exist.
             *
             * For more details, see g_file_create() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_finish() to get the result
             * of the operation.
             */
            vfunc_create_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileOutputStream> | void;
            /**
             * Finishes an asynchronous file create operation started with
             * g_file_create_async().
             */
            vfunc_create_finish(res: AsyncResult): FileOutputStream;
            /**
             * Creates a new file and returns a stream for reading and
             * writing to it. The file must not already exist.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level
             * that is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If a file or directory with this name already exists, the
             * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
             * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
             * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
             * will be returned. Other errors are possible too, and depend on what
             * kind of filesystem the file is on.
             *
             * Note that in many non-local file cases read and write streams are
             * not supported, so make sure you really need to do read and write
             * streaming, rather than just opening for reading or writing.
             */
            vfunc_create_readwrite(flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;
            /**
             * Asynchronously creates a new file and returns a stream
             * for reading and writing to it. The file must not already exist.
             *
             * For more details, see g_file_create_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_create_readwrite_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileIOStream>;
            /**
             * Asynchronously creates a new file and returns a stream
             * for reading and writing to it. The file must not already exist.
             *
             * For more details, see g_file_create_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_create_readwrite_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a new file and returns a stream
             * for reading and writing to it. The file must not already exist.
             *
             * For more details, see g_file_create_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_create_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_create_readwrite_async(
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileIOStream> | void;
            /**
             * Finishes an asynchronous file create operation started with
             * g_file_create_readwrite_async().
             */
            vfunc_create_readwrite_finish(res: AsyncResult): FileIOStream;
            /**
             * Deletes a file. If the `file `is a directory, it will only be
             * deleted if it is empty. This has the same semantics as g_unlink().
             *
             * If `file `doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
             * for deletion to be implemented avoiding
             * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
             * |[
             * g_autoptr(GError) local_error = NULL;
             * if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
             * !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
             * {
             * // deletion failed for some reason other than the file not existing:
             * // so report the error
             * g_warning ("Failed to delete %s: %s",
             * g_file_peek_path (my_file), local_error-&gt;message);
             * }
             * ]|
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_delete_file(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously delete a file. If the `file `is a directory, it will
             * only be deleted if it is empty.  This has the same semantics as
             * g_unlink().
             */
            vfunc_delete_file_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously delete a file. If the `file `is a directory, it will
             * only be deleted if it is empty.  This has the same semantics as
             * g_unlink().
             */
            vfunc_delete_file_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously delete a file. If the `file `is a directory, it will
             * only be deleted if it is empty.  This has the same semantics as
             * g_unlink().
             */
            vfunc_delete_file_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes deleting a file started with g_file_delete_async().
             */
            vfunc_delete_file_finish(result: AsyncResult): boolean;
            /**
             * Duplicates a #GFile handle. This operation does not duplicate
             * the actual file or directory represented by the #GFile; see
             * g_file_copy() if attempting to copy a file.
             *
             * g_file_dup() is useful when a second handle is needed to the same underlying
             * file, for use in a separate thread (#GFile is not thread-safe). For use
             * within the same thread, use g_object_ref() to increment the existing object’s
             * reference count.
             *
             * This call does no blocking I/O.
             */
            vfunc_dup(): File;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_eject_mountable(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_eject_mountable(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_eject_mountable(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous eject operation started by
             * g_file_eject_mountable().
             */
            vfunc_eject_mountable_finish(result: AsyncResult): boolean;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_with_operation_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_eject_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_with_operation_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_eject_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts an asynchronous eject on a mountable.
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_eject_mountable_with_operation_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_eject_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous eject operation started by
             * g_file_eject_mountable_with_operation().
             */
            vfunc_eject_mountable_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the requested information about the files in a directory.
             * The result is a #GFileEnumerator object that will give out
             * #GFileInfo objects for all the files in the directory.
             *
             * The `attributes `value is a string that specifies the file
             * attributes that should be gathered. It is not an error if
             * it's not possible to read a particular requested attribute
             * from a file - it just won't be set. `attributes `should
             * be a comma-separated list of attributes or attribute wildcards.
             * The wildcard "*" means all attributes, and a wildcard like
             * "standard::*" means all attributes in the standard namespace.
             * An example attribute query be "standard::*,owner::user".
             * The standard attributes are available as defines, like
             * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
             * always be specified if you plan to call g_file_enumerator_get_child() or
             * g_file_enumerator_iterate() on the returned enumerator.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
             * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
             * error will be returned. Other errors are possible too.
             */
            vfunc_enumerate_children(
                attributes: string,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): FileEnumerator;
            /**
             * Asynchronously gets the requested information about the files
             * in a directory. The result is a #GFileEnumerator object that will
             * give out #GFileInfo objects for all the files in the directory.
             *
             * For more details, see g_file_enumerate_children() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_enumerate_children_finish() to get the result of
             * the operation.
             */
            vfunc_enumerate_children_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileEnumerator>;
            /**
             * Asynchronously gets the requested information about the files
             * in a directory. The result is a #GFileEnumerator object that will
             * give out #GFileInfo objects for all the files in the directory.
             *
             * For more details, see g_file_enumerate_children() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_enumerate_children_finish() to get the result of
             * the operation.
             */
            vfunc_enumerate_children_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the requested information about the files
             * in a directory. The result is a #GFileEnumerator object that will
             * give out #GFileInfo objects for all the files in the directory.
             *
             * For more details, see g_file_enumerate_children() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_enumerate_children_finish() to get the result of
             * the operation.
             */
            vfunc_enumerate_children_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileEnumerator> | void;
            /**
             * Finishes an async enumerate children operation.
             * See g_file_enumerate_children_async().
             */
            vfunc_enumerate_children_finish(res: AsyncResult): FileEnumerator;
            /**
             * Checks if the two given #GFiles refer to the same file.
             *
             * Note that two #GFiles that differ can still refer to the same
             * file on the filesystem due to various forms of filename
             * aliasing.
             *
             * This call does no blocking I/O.
             */
            vfunc_equal(file2: File): boolean;
            /**
             * Gets a #GMount for the #GFile.
             *
             * #GMount is returned only for user interesting locations, see
             * #GVolumeMonitor. If the #GFileIface for `file `does not have a #mount,
             * `error `will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_find_enclosing_mount(cancellable?: Cancellable | null): Mount;
            /**
             * Asynchronously gets the mount for the file.
             *
             * For more details, see g_file_find_enclosing_mount() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_find_enclosing_mount_finish() to
             * get the result of the operation.
             */
            vfunc_find_enclosing_mount_async(io_priority: number, cancellable?: Cancellable | null): Promise<Mount>;
            /**
             * Asynchronously gets the mount for the file.
             *
             * For more details, see g_file_find_enclosing_mount() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_find_enclosing_mount_finish() to
             * get the result of the operation.
             */
            vfunc_find_enclosing_mount_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the mount for the file.
             *
             * For more details, see g_file_find_enclosing_mount() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_find_enclosing_mount_finish() to
             * get the result of the operation.
             */
            vfunc_find_enclosing_mount_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<Mount> | void;
            /**
             * Finishes an asynchronous find mount request.
             * See g_file_find_enclosing_mount_async().
             */
            vfunc_find_enclosing_mount_finish(res: AsyncResult): Mount;
            /**
             * Gets the base name (the last component of the path) for a given #GFile.
             *
             * If called for the top level of a system (such as the filesystem root
             * or a uri like sftp://host/) it will return a single directory separator
             * (and on Windows, possibly a drive letter).
             *
             * The base name is a byte string (not UTF-8). It has no defined encoding
             * or rules other than it may not contain zero bytes.  If you want to use
             * filenames in a user interface you should use the display name that you
             * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
             * attribute with g_file_query_info().
             *
             * This call does no blocking I/O.
             */
            vfunc_get_basename(): string | null;
            /**
             * Gets the child of `file `for a given `display_name `(i.e. a UTF-8
             * version of the name). If this function fails, it returns %NULL
             * and `error `will be set. This is very useful when constructing a
             * #GFile for a new file and the user entered the filename in the
             * user interface, for instance when you select a directory and
             * type a filename in the file selector.
             *
             * This call does no blocking I/O.
             */
            vfunc_get_child_for_display_name(display_name: string): File;
            /**
             * Gets the parent directory for the `file.`
             * If the `file `represents the root directory of the
             * file system, then %NULL will be returned.
             *
             * This call does no blocking I/O.
             */
            vfunc_get_parent(): File | null;
            /**
             * Gets the parse name of the `file.`
             * A parse name is a UTF-8 string that describes the
             * file such that one can get the #GFile back using
             * g_file_parse_name().
             *
             * This is generally used to show the #GFile as a nice
             * full-pathname kind of string in a user interface,
             * like in a location entry.
             *
             * For local files with names that can safely be converted
             * to UTF-8 the pathname is used, otherwise the IRI is used
             * (a form of URI that allows UTF-8 characters unescaped).
             *
             * This call does no blocking I/O.
             */
            vfunc_get_parse_name(): string;
            /**
             * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
             * guaranteed to be an absolute, canonical path. It might contain symlinks.
             *
             * This call does no blocking I/O.
             */
            vfunc_get_path(): string | null;
            /**
             * Gets the path for `descendant `relative to `parent.`
             *
             * This call does no blocking I/O.
             */
            vfunc_get_relative_path(descendant: File): string | null;
            /**
             * Gets the URI for the `file.`
             *
             * This call does no blocking I/O.
             */
            vfunc_get_uri(): string;
            /**
             * Gets the URI scheme for a #GFile.
             * RFC 3986 decodes the scheme as:
             * |[
             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
             * ]|
             * Common schemes include "file", "http", "ftp", etc.
             *
             * The scheme can be different from the one used to construct the #GFile,
             * in that it might be replaced with one that is logically equivalent to the #GFile.
             *
             * This call does no blocking I/O.
             */
            vfunc_get_uri_scheme(): string | null;
            /**
             * Checks to see if a #GFile has a given URI scheme.
             *
             * This call does no blocking I/O.
             */
            vfunc_has_uri_scheme(uri_scheme: string): boolean;
            /**
             * Creates a hash value for a #GFile.
             *
             * This call does no blocking I/O.
             */
            vfunc_hash(): number;
            /**
             * Checks to see if a file is native to the platform.
             *
             * A native file is one expressed in the platform-native filename format,
             * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
             * as it might be on a locally mounted remote filesystem.
             *
             * On some systems non-native files may be available using the native
             * filesystem via a userspace filesystem (FUSE), in these cases this call
             * will return %FALSE, but g_file_get_path() will still return a native path.
             *
             * This call does no blocking I/O.
             */
            vfunc_is_native(): boolean;
            /**
             * Creates a directory. Note that this will only create a child directory
             * of the immediate parent directory of the path or URI given by the #GFile.
             * To recursively create directories, see g_file_make_directory_with_parents().
             * This function will fail if the parent directory does not exist, setting
             * `error `to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
             * creating directories, this function will fail, setting `error `to
             * %G_IO_ERROR_NOT_SUPPORTED.
             *
             * For a local #GFile the newly created directory will have the default
             * (current) ownership and permissions of the current process.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_make_directory(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously creates a directory.
             */
            vfunc_make_directory_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously creates a directory.
             */
            vfunc_make_directory_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a directory.
             */
            vfunc_make_directory_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous directory creation, started with
             * g_file_make_directory_async().
             */
            vfunc_make_directory_finish(result: AsyncResult): boolean;
            /**
             * Creates a symbolic link named `file `which contains the string
             * `symlink_value.`
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_make_symbolic_link(symlink_value: string, cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously creates a symbolic link named `file `which contains the
             * string `symlink_value.`
             */
            vfunc_make_symbolic_link_async(
                symlink_value: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Asynchronously creates a symbolic link named `file `which contains the
             * string `symlink_value.`
             */
            vfunc_make_symbolic_link_async(
                symlink_value: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously creates a symbolic link named `file `which contains the
             * string `symlink_value.`
             */
            vfunc_make_symbolic_link_async(
                symlink_value: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous symbolic link creation, started with
             * g_file_make_symbolic_link_async().
             */
            vfunc_make_symbolic_link_finish(result: AsyncResult): boolean;
            /**
             * Collects the results from an earlier call to
             * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
             * more information.
             */
            vfunc_measure_disk_usage_finish(result: AsyncResult): [boolean, number, number, number];
            /**
             * Obtains a directory monitor for the given file.
             * This may fail if directory monitoring is not supported.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * It does not make sense for `flags `to contain
             * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
             * directories.  It is not possible to monitor all the files in a
             * directory for changes made via hard links; if you want to do this then
             * you must register individual watches with g_file_monitor().
             */
            vfunc_monitor_dir(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
            /**
             * Obtains a file monitor for the given file. If no file notification
             * mechanism exists, then regular polling of the file is used.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `flags `contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
             * will also attempt to report changes made to the file via another
             * filename (ie, a hard link). Without this flag, you can only rely on
             * changes made through the filename contained in `file `to be
             * reported. Using this flag may result in an increase in resource
             * usage, and may not have any effect depending on the #GFileMonitor
             * backend and/or filesystem type.
             */
            vfunc_monitor_file(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
            /**
             * Starts a mount_operation, mounting the volume that contains
             * the file `location.`
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_mount_enclosing_volume_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_mount_enclosing_volume(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Starts a mount_operation, mounting the volume that contains
             * the file `location.`
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_mount_enclosing_volume_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_mount_enclosing_volume(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts a mount_operation, mounting the volume that contains
             * the file `location.`
             *
             * When this operation has completed, `callback `will be called with
             * `user_user `data, and the operation can be finalized with
             * g_file_mount_enclosing_volume_finish().
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_mount_enclosing_volume(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a mount operation started by g_file_mount_enclosing_volume().
             */
            vfunc_mount_enclosing_volume_finish(result: AsyncResult): boolean;
            /**
             * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
             * Using mount_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_mount_mountable(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<File>;
            /**
             * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
             * Using mount_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_mount_mountable(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
             * Using mount_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_mount_mountable(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<File> | void;
            /**
             * Finishes a mount operation. See g_file_mount_mountable() for details.
             *
             * Finish an asynchronous mount operation that was started
             * with g_file_mount_mountable().
             */
            vfunc_mount_mountable_finish(result: AsyncResult): File;
            /**
             * Tries to move the file or directory `source `to the location specified
             * by `destination.` If native move operations are supported then this is
             * used, otherwise a copy + delete fallback is used. The native
             * implementation may support moving directories (for instance on moves
             * inside the same filesystem), but the fallback code does not.
             *
             * If the flag %G_FILE_COPY_OVERWRITE is specified an already
             * existing `destination `file is overwritten.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If `progress_callback `is not %NULL, then the operation can be monitored
             * by setting this to a #GFileProgressCallback function.
             * `progress_callback_data `will be passed to this function. It is
             * guaranteed that this callback will be called after all data has been
             * transferred with the total number of bytes copied during the operation.
             *
             * If the `source `file does not exist, then the %G_IO_ERROR_NOT_FOUND
             * error is returned, independent on the status of the `destination.`
             *
             * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
             * then the error %G_IO_ERROR_EXISTS is returned.
             *
             * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error is returned. If trying to overwrite a directory with a directory the
             * %G_IO_ERROR_WOULD_MERGE error is returned.
             *
             * If the source is a directory and the target does not exist, or
             * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
             * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
             * move operation isn't available).
             */
            vfunc_move(
                destination: File,
                flags: FileCopyFlags,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null
            ): boolean;
            /**
             * Asynchronously moves a file `source `to the location of `destination.` For details of the behaviour, see g_file_move().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_move(). The callback will run in the default main context
             * of the thread calling g_file_move_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_move_finish() to get the result of the operation.
             */
            vfunc_move_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null
            ): Promise<boolean>;
            /**
             * Asynchronously moves a file `source `to the location of `destination.` For details of the behaviour, see g_file_move().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_move(). The callback will run in the default main context
             * of the thread calling g_file_move_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_move_finish() to get the result of the operation.
             */
            vfunc_move_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                progress_callback: FileProgressCallback | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously moves a file `source `to the location of `destination.` For details of the behaviour, see g_file_move().
             *
             * If `progress_callback `is not %NULL, then that function that will be called
             * just like in g_file_move(). The callback will run in the default main context
             * of the thread calling g_file_move_async() — the same context as `callback `is
             * run in.
             *
             * When the operation is finished, `callback `will be called. You can then call
             * g_file_move_finish() to get the result of the operation.
             */
            vfunc_move_async(
                destination: File,
                flags: FileCopyFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                progress_callback?: FileProgressCallback | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous file movement, started with
             * g_file_move_async().
             */
            vfunc_move_finish(result: AsyncResult): boolean;
            /**
             * Opens an existing file for reading and writing. The result is
             * a #GFileIOStream that can be used to read and write the contents
             * of the file.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
             * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error will be returned. Other errors are possible too, and depend on
             * what kind of filesystem the file is on. Note that in many non-local
             * file cases read and write streams are not supported, so make sure you
             * really need to do read and write streaming, rather than just opening
             * for reading or writing.
             */
            vfunc_open_readwrite(cancellable?: Cancellable | null): FileIOStream;
            /**
             * Asynchronously opens `file `for reading and writing.
             *
             * For more details, see g_file_open_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_open_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_open_readwrite_async(io_priority: number, cancellable?: Cancellable | null): Promise<FileIOStream>;
            /**
             * Asynchronously opens `file `for reading and writing.
             *
             * For more details, see g_file_open_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_open_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_open_readwrite_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously opens `file `for reading and writing.
             *
             * For more details, see g_file_open_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_open_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_open_readwrite_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileIOStream> | void;
            /**
             * Finishes an asynchronous file read operation started with
             * g_file_open_readwrite_async().
             */
            vfunc_open_readwrite_finish(res: AsyncResult): FileIOStream;
            /**
             * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_poll_mountable(cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_poll_mountable(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_poll_mountable(
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a poll operation. See g_file_poll_mountable() for details.
             *
             * Finish an asynchronous poll operation that was polled
             * with g_file_poll_mountable().
             */
            vfunc_poll_mountable_finish(result: AsyncResult): boolean;
            /**
             * Checks whether `file `has the prefix specified by `prefix.`
             *
             * In other words, if the names of initial elements of file's
             * pathname match `prefix.` Only full pathname elements are matched,
             * so a path like /foo is not considered a prefix of /foobar, only
             * of /foo/bar.
             *
             * A #GFile is not a prefix of itself. If you want to check for
             * equality, use g_file_equal().
             *
             * This call does no I/O, as it works purely on names. As such it can
             * sometimes return %FALSE even if `file `is inside a `prefix `(from a
             * filesystem point of view), because the prefix of `file `is an alias
             * of `prefix.`
             */
            vfunc_prefix_matches(file: File): boolean;
            /**
             * Similar to g_file_query_info(), but obtains information
             * about the filesystem the `file `is on, rather than the file itself.
             * For instance the amount of space available and the type of
             * the filesystem.
             *
             * The `attributes `value is a string that specifies the attributes
             * that should be gathered. It is not an error if it's not possible
             * to read a particular requested attribute from a file - it just
             * won't be set. `attributes `should be a comma-separated list of
             * attributes or attribute wildcards. The wildcard "*" means all
             * attributes, and a wildcard like "filesystem::*" means all attributes
             * in the filesystem namespace. The standard namespace for filesystem
             * attributes is "filesystem". Common attributes of interest are
             * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
             * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
             * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
             * be returned. Other errors are possible too, and depend on what
             * kind of filesystem the file is on.
             */
            vfunc_query_filesystem_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously gets the requested information about the filesystem
             * that the specified `file `is on. The result is a #GFileInfo object
             * that contains key-value attributes (such as type or size for the
             * file).
             *
             * For more details, see g_file_query_filesystem_info() which is the
             * synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the
             * operation.
             */
            vfunc_query_filesystem_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously gets the requested information about the filesystem
             * that the specified `file `is on. The result is a #GFileInfo object
             * that contains key-value attributes (such as type or size for the
             * file).
             *
             * For more details, see g_file_query_filesystem_info() which is the
             * synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the
             * operation.
             */
            vfunc_query_filesystem_info_async(
                attributes: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the requested information about the filesystem
             * that the specified `file `is on. The result is a #GFileInfo object
             * that contains key-value attributes (such as type or size for the
             * file).
             *
             * For more details, see g_file_query_filesystem_info() which is the
             * synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the
             * operation.
             */
            vfunc_query_filesystem_info_async(
                attributes: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finishes an asynchronous filesystem info query.
             * See g_file_query_filesystem_info_async().
             */
            vfunc_query_filesystem_info_finish(res: AsyncResult): FileInfo;
            /**
             * Gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value
             * attributes (such as the type or size of the file).
             *
             * The `attributes `value is a string that specifies the file
             * attributes that should be gathered. It is not an error if
             * it's not possible to read a particular requested attribute
             * from a file - it just won't be set. `attributes `should be a
             * comma-separated list of attributes or attribute wildcards.
             * The wildcard "*" means all attributes, and a wildcard like
             * "standard::*" means all attributes in the standard namespace.
             * An example attribute query be "standard::*,owner::user".
             * The standard attributes are available as defines, like
             * %G_FILE_ATTRIBUTE_STANDARD_NAME.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * For symlinks, normally the information about the target of the
             * symlink is returned, rather than information about the symlink
             * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
             * in `flags `the information about the symlink itself will be returned.
             * Also, for symlinks that point to non-existing files the information
             * about the symlink itself will be returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
             * returned. Other errors are possible too, and depend on what kind of
             * filesystem the file is on.
             */
            vfunc_query_info(attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileInfo;
            /**
             * Asynchronously gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value attributes
             * (such as type or size for the file).
             *
             * For more details, see g_file_query_info() which is the synchronous
             * version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the operation.
             */
            vfunc_query_info_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileInfo>;
            /**
             * Asynchronously gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value attributes
             * (such as type or size for the file).
             *
             * For more details, see g_file_query_info() which is the synchronous
             * version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the operation.
             */
            vfunc_query_info_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously gets the requested information about specified `file.`
             * The result is a #GFileInfo object that contains key-value attributes
             * (such as type or size for the file).
             *
             * For more details, see g_file_query_info() which is the synchronous
             * version of this call.
             *
             * When the operation is finished, `callback `will be called. You can
             * then call g_file_query_info_finish() to get the result of the operation.
             */
            vfunc_query_info_async(
                attributes: string,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInfo> | void;
            /**
             * Finishes an asynchronous file info query.
             * See g_file_query_info_async().
             */
            vfunc_query_info_finish(res: AsyncResult): FileInfo;
            /**
             * Obtain the list of settable attributes for the file.
             *
             * Returns the type and full attribute name of all the attributes
             * that can be set on this file. This doesn't mean setting it will
             * always succeed though, you might get an access failure, or some
             * specific file may not support a specific attribute.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_query_settable_attributes(cancellable?: Cancellable | null): FileAttributeInfoList;
            /**
             * Obtain the list of attribute namespaces where new attributes
             * can be created by a user. An example of this is extended
             * attributes (in the "xattr" namespace).
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_query_writable_namespaces(cancellable?: Cancellable | null): FileAttributeInfoList;
            /**
             * Asynchronously opens `file `for reading.
             *
             * For more details, see g_file_read() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_read_finish() to get the result
             * of the operation.
             */
            vfunc_read_async(io_priority: number, cancellable?: Cancellable | null): Promise<FileInputStream>;
            /**
             * Asynchronously opens `file `for reading.
             *
             * For more details, see g_file_read() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_read_finish() to get the result
             * of the operation.
             */
            vfunc_read_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously opens `file `for reading.
             *
             * For more details, see g_file_read() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_read_finish() to get the result
             * of the operation.
             */
            vfunc_read_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileInputStream> | void;
            /**
             * Finishes an asynchronous file read operation started with
             * g_file_read_async().
             */
            vfunc_read_finish(res: AsyncResult): FileInputStream;
            /**
             * Opens a file for reading. The result is a #GFileInputStream that
             * can be used to read the contents of the file.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
             * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
             * error will be returned. Other errors are possible too, and depend
             * on what kind of filesystem the file is on.
             */
            vfunc_read_fn(cancellable?: Cancellable | null): FileInputStream;
            /**
             * Returns an output stream for overwriting the file, possibly
             * creating a backup copy of the file first. If the file doesn't exist,
             * it will be created.
             *
             * This will try to replace the file in the safest way possible so
             * that any errors during the writing will not affect an already
             * existing copy of the file. For instance, for local files it
             * may write to a temporary file and then atomically rename over
             * the destination when the stream is closed.
             *
             * By default files created are generally readable by everyone,
             * but if you pass %G_FILE_CREATE_PRIVATE in `flags `the file
             * will be made readable only to the current user, to the level that
             * is supported on the target filesystem.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled
             * by triggering the cancellable object from another thread. If the
             * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
             * returned.
             *
             * If you pass in a non-%NULL `etag `value and `file `already exists, then
             * this value is compared to the current entity tag of the file, and if
             * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
             * generally means that the file has been changed since you last read
             * it. You can get the new etag from g_file_output_stream_get_etag()
             * after you've finished writing and closed the #GFileOutputStream. When
             * you load a new file you can use g_file_input_stream_query_info() to
             * get the etag of the file.
             *
             * If `make_backup `is %TRUE, this function will attempt to make a
             * backup of the current file before overwriting it. If this fails
             * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
             * want to replace anyway, try again with `make_backup `set to %FALSE.
             *
             * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
             * be returned, and if the file is some other form of non-regular file
             * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
             * file systems don't allow all file names, and may return an
             * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
             * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
             * possible too, and depend on what kind of filesystem the file is on.
             */
            vfunc_replace(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null
            ): FileOutputStream;
            /**
             * Asynchronously overwrites the file, replacing the contents,
             * possibly creating a backup copy of the file first.
             *
             * For more details, see g_file_replace() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_finish() to get the result
             * of the operation.
             */
            vfunc_replace_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileOutputStream>;
            /**
             * Asynchronously overwrites the file, replacing the contents,
             * possibly creating a backup copy of the file first.
             *
             * For more details, see g_file_replace() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_finish() to get the result
             * of the operation.
             */
            vfunc_replace_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously overwrites the file, replacing the contents,
             * possibly creating a backup copy of the file first.
             *
             * For more details, see g_file_replace() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_finish() to get the result
             * of the operation.
             */
            vfunc_replace_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileOutputStream> | void;
            /**
             * Finishes an asynchronous file replace operation started with
             * g_file_replace_async().
             */
            vfunc_replace_finish(res: AsyncResult): FileOutputStream;
            /**
             * Returns an output stream for overwriting the file in readwrite mode,
             * possibly creating a backup copy of the file first. If the file doesn't
             * exist, it will be created.
             *
             * For details about the behaviour, see g_file_replace() which does the
             * same thing but returns an output stream only.
             *
             * Note that in many non-local file cases read and write streams are not
             * supported, so make sure you really need to do read and write streaming,
             * rather than just opening for reading or writing.
             */
            vfunc_replace_readwrite(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                cancellable?: Cancellable | null
            ): FileIOStream;
            /**
             * Asynchronously overwrites the file in read-write mode,
             * replacing the contents, possibly creating a backup copy
             * of the file first.
             *
             * For more details, see g_file_replace_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_replace_readwrite_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<FileIOStream>;
            /**
             * Asynchronously overwrites the file in read-write mode,
             * replacing the contents, possibly creating a backup copy
             * of the file first.
             *
             * For more details, see g_file_replace_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_replace_readwrite_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously overwrites the file in read-write mode,
             * replacing the contents, possibly creating a backup copy
             * of the file first.
             *
             * For more details, see g_file_replace_readwrite() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_replace_readwrite_finish() to get
             * the result of the operation.
             */
            vfunc_replace_readwrite_async(
                etag: string | null,
                make_backup: boolean,
                flags: FileCreateFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<FileIOStream> | void;
            /**
             * Finishes an asynchronous file replace operation started with
             * g_file_replace_readwrite_async().
             */
            vfunc_replace_readwrite_finish(res: AsyncResult): FileIOStream;
            /**
             * Resolves a relative path for `file `to an absolute path.
             *
             * This call does no blocking I/O.
             *
             * If the `relative_path `is an absolute path name, the resolution
             * is done absolutely (without taking `file `path as base).
             */
            vfunc_resolve_relative_path(relative_path: string): File;
            /**
             * Sets an attribute in the file with attribute name `attribute `to `value_p.`
             *
             * Some attributes can be unset by setting `type `to
             * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p `to %NULL.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_set_attribute(
                attribute: string,
                type: FileAttributeType,
                value_p: any | null,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Asynchronously sets the attributes of `file `with `info.`
             *
             * For more details, see g_file_set_attributes_from_info(),
             * which is the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_attributes_finish() to get
             * the result of the operation.
             */
            vfunc_set_attributes_async(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<[FileInfo]>;
            /**
             * Asynchronously sets the attributes of `file `with `info.`
             *
             * For more details, see g_file_set_attributes_from_info(),
             * which is the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_attributes_finish() to get
             * the result of the operation.
             */
            vfunc_set_attributes_async(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously sets the attributes of `file `with `info.`
             *
             * For more details, see g_file_set_attributes_from_info(),
             * which is the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_attributes_finish() to get
             * the result of the operation.
             */
            vfunc_set_attributes_async(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[FileInfo]> | void;
            /**
             * Finishes setting an attribute started in g_file_set_attributes_async().
             */
            vfunc_set_attributes_finish(result: AsyncResult): [boolean, FileInfo];
            /**
             * Tries to set all attributes in the #GFileInfo on the target
             * values, not stopping on the first error.
             *
             * If there is any error during this operation then `error `will
             * be set to the first error. Error on particular fields are flagged
             * by setting the "status" field in the attribute value to
             * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
             * also detect further errors.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_set_attributes_from_info(
                info: FileInfo,
                flags: FileQueryInfoFlags,
                cancellable?: Cancellable | null
            ): boolean;
            /**
             * Renames `file `to the specified display name.
             *
             * The display name is converted from UTF-8 to the correct encoding
             * for the target filesystem if possible and the `file `is renamed to this.
             *
             * If you want to implement a rename operation in the user interface the
             * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
             * initial value in the rename widget, and then the result after editing
             * should be passed to g_file_set_display_name().
             *
             * On success the resulting converted filename is returned.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_set_display_name(display_name: string, cancellable?: Cancellable | null): File;
            /**
             * Asynchronously sets the display name for a given #GFile.
             *
             * For more details, see g_file_set_display_name() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_display_name_finish() to get
             * the result of the operation.
             */
            vfunc_set_display_name_async(
                display_name: string,
                io_priority: number,
                cancellable?: Cancellable | null
            ): Promise<File>;
            /**
             * Asynchronously sets the display name for a given #GFile.
             *
             * For more details, see g_file_set_display_name() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_display_name_finish() to get
             * the result of the operation.
             */
            vfunc_set_display_name_async(
                display_name: string,
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously sets the display name for a given #GFile.
             *
             * For more details, see g_file_set_display_name() which is
             * the synchronous version of this call.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_set_display_name_finish() to get
             * the result of the operation.
             */
            vfunc_set_display_name_async(
                display_name: string,
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<File> | void;
            /**
             * Finishes setting a display name started with
             * g_file_set_display_name_async().
             */
            vfunc_set_display_name_finish(res: AsyncResult): File;
            /**
             * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
             * Using start_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_start_mountable(
                flags: DriveStartFlags,
                start_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
             * Using start_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_start_mountable(
                flags: DriveStartFlags,
                start_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
             * Using start_operation, you can request callbacks when, for instance,
             * passwords are needed during authentication.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_mount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_start_mountable(
                flags: DriveStartFlags,
                start_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a start operation. See g_file_start_mountable() for details.
             *
             * Finish an asynchronous start operation that was started
             * with g_file_start_mountable().
             */
            vfunc_start_mountable_finish(result: AsyncResult): boolean;
            /**
             * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_stop_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_stop_mountable(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_stop_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_stop_mountable(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_stop_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_stop_mountable(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes a stop operation, see g_file_stop_mountable() for details.
             *
             * Finish an asynchronous stop operation that was started
             * with g_file_stop_mountable().
             */
            vfunc_stop_mountable_finish(result: AsyncResult): boolean;
            /**
             * Sends `file `to the "Trashcan", if possible. This is similar to
             * deleting it, but the user can recover it before emptying the trashcan.
             * Not all file systems support trashing, so this call can return the
             * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
             * mount option can be used to disable g_file_trash() support for certain
             * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_trash(cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously sends `file `to the Trash location, if possible.
             */
            vfunc_trash_async(io_priority: number, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously sends `file `to the Trash location, if possible.
             */
            vfunc_trash_async(
                io_priority: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously sends `file `to the Trash location, if possible.
             */
            vfunc_trash_async(
                io_priority: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an asynchronous file trashing operation, started with
             * g_file_trash_async().
             */
            vfunc_trash_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_unmount_mountable(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_unmount_mountable(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_unmount_mountable(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an unmount operation, see g_file_unmount_mountable() for details.
             *
             * Finish an asynchronous unmount operation that was started
             * with g_file_unmount_mountable().
             */
            vfunc_unmount_mountable_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_unmount_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_unmount_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_file_unmount_mountable_finish() to get
             * the result of the operation.
             */
            vfunc_unmount_mountable_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an unmount operation,
             * see g_file_unmount_mountable_with_operation() for details.
             *
             * Finish an asynchronous unmount operation that was started
             * with g_file_unmount_mountable_with_operation().
             */
            vfunc_unmount_mountable_with_operation_finish(result: AsyncResult): boolean;
        }

        export const File: FileNamespace;

        /**
         * #GFileDescriptorBased is implemented by streams (implementations of
         * #GInputStream or #GOutputStream) that are based on file descriptors.
         *
         * Note that `&lt;gio/gfiledescriptorbased.h&gt;` belongs to the UNIX-specific
         * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
         * file when using it.
         */
        export interface FileDescriptorBasedNamespace {
            $gtype: GObject.GType<FileDescriptorBased>;
            prototype: FileDescriptorBasedPrototype;
        }
        export type FileDescriptorBased = FileDescriptorBasedPrototype;
        export interface FileDescriptorBasedPrototype extends GObject.Object {
            // Members

            /**
             * Gets the underlying file descriptor.
             */
            get_fd(): number;
            /**
             * Gets the underlying file descriptor.
             */
            vfunc_get_fd(): number;
        }

        export const FileDescriptorBased: FileDescriptorBasedNamespace;

        /**
         * #GIcon is a very minimal interface for icons. It provides functions
         * for checking the equality of two icons, hashing of icons and
         * serializing an icon to and from strings.
         *
         * #GIcon does not provide the actual pixmap for the icon as this is out
         * of GIO's scope, however implementations of #GIcon may contain the name
         * of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).
         *
         * To obtain a hash of a #GIcon, see g_icon_hash().
         *
         * To check if two #GIcons are equal, see g_icon_equal().
         *
         * For serializing a #GIcon, use g_icon_serialize() and
         * g_icon_deserialize().
         *
         * If you want to consume #GIcon (for example, in a toolkit) you must
         * be prepared to handle at least the three following cases:
         * #GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
         * sense to have fast-paths for other cases (like handling #GdkPixbuf
         * directly, for example) but all compliant #GIcon implementations
         * outside of GIO must implement #GLoadableIcon.
         *
         * If your application or library provides one or more #GIcon
         * implementations you need to ensure that your new implementation also
         * implements #GLoadableIcon.  Additionally, you must provide an
         * implementation of g_icon_serialize() that gives a result that is
         * understood by g_icon_deserialize(), yielding one of the built-in icon
         * types.
         */
        export interface IconNamespace {
            $gtype: GObject.GType<Icon>;
            prototype: IconPrototype;

            /**
             * Deserializes a #GIcon previously serialized using g_icon_serialize().
             */
            deserialize(value: GLib.Variant): Icon | null;
            /**
             * Generate a #GIcon instance from `str.` This function can fail if
             * `str `is not valid - see g_icon_to_string() for discussion.
             *
             * If your application or library provides one or more #GIcon
             * implementations you need to ensure that each #GType is registered
             * with the type system prior to calling g_icon_new_for_string().
             */
            new_for_string(str: string): Icon;
        }
        export type Icon = IconPrototype;
        export interface IconPrototype extends GObject.Object {
            // Members

            /**
             * Checks if two icons are equal.
             */
            equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            serialize(): GLib.Variant | null;
            /**
             * Generates a textual representation of `icon `that can be used for
             * serialization such as when passing `icon `to a different process or
             * saving it to persistent storage. Use g_icon_new_for_string() to
             * get `icon `back from the returned string.
             *
             * The encoding of the returned string is proprietary to #GIcon except
             * in the following two cases
             *
             * - If `icon `is a #GFileIcon, the returned string is a native path
             * (such as `/path/to/my icon.png`) without escaping
             * if the #GFile for `icon `is a native file.  If the file is not
             * native, the returned string is the result of g_file_get_uri()
             * (such as `sftp://path/to/my%20icon.png`).
             *
             * - If `icon `is a #GThemedIcon with exactly one name and no fallbacks,
             * the encoding is simply the name (such as `network-server`).
             */
            to_string(): string | null;
            /**
             * Checks if two icons are equal.
             */
            vfunc_equal(icon2?: Icon | null): boolean;
            /**
             * Gets a hash for an icon.
             */
            vfunc_hash(): number;
            /**
             * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
             * back by calling g_icon_deserialize() on the returned value.
             * As serialization will avoid using raw icon data when possible, it only
             * makes sense to transfer the #GVariant between processes on the same machine,
             * (as opposed to over the network), and within the same file system namespace.
             */
            vfunc_serialize(): GLib.Variant | null;
            /**
             * Serializes the `icon `into string tokens.
             * This is can be invoked when g_icon_new_for_string() is called.
             */
            vfunc_to_tokens(): [boolean, string[], number];
        }

        export const Icon: IconNamespace;

        /**
         * #GInitable is implemented by objects that can fail during
         * initialization. If an object implements this interface then
         * it must be initialized as the first thing after construction,
         * either via g_initable_init() or g_async_initable_init_async()
         * (the latter is only available if it also implements #GAsyncInitable).
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. They will often fail with g_critical() or g_warning(), but
         * this must not be relied on.
         *
         * Users of objects implementing this are not intended to use
         * the interface method directly, instead it will be used automatically
         * in various ways. For C applications you generally just call
         * g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.
         * This will call g_initable_init() under the cover, returning %NULL and
         * setting a #GError on failure (at which point the instance is
         * unreferenced).
         *
         * For bindings in languages where the native constructor supports
         * exceptions the binding could check for objects implementing %GInitable
         * during normal construction and automatically initialize them, throwing
         * an exception on failure.
         */
        export interface InitableNamespace {
            $gtype: GObject.GType<Initable>;
            prototype: InitablePrototype;

            /**
             * Helper function for constructing #GInitable object. This is
             * similar to g_object_newv() but also initializes the object
             * and returns %NULL, setting an error on failure.
             */
            newv<T = GObject.Object>(
                object_type: GObject.GType,
                parameters: GObject.Parameter[],
                cancellable?: Cancellable | null
            ): T;
            // Conflicted with GObject.Object.newv
            newv(...args: never[]): any;
        }
        export type Initable = InitablePrototype;
        export interface InitablePrototype extends GObject.Object {
            // Members

            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            init(cancellable?: Cancellable | null): boolean;
            /**
             * Initializes the object implementing the interface.
             *
             * This method is intended for language bindings. If writing in C,
             * g_initable_new() should typically be used instead.
             *
             * The object must be initialized before any real use after initial
             * construction, either with this function or g_async_initable_init_async().
             *
             * Implementations may also support cancellation. If `cancellable `is not %NULL,
             * then initialization can be cancelled by triggering the cancellable object
             * from another thread. If the operation was cancelled, the error
             * %G_IO_ERROR_CANCELLED will be returned. If `cancellable `is not %NULL and
             * the object doesn't support cancellable initialization the error
             * %G_IO_ERROR_NOT_SUPPORTED will be returned.
             *
             * If the object is not initialized, or initialization returns with an
             * error, then all operations on the object except g_object_ref() and
             * g_object_unref() are considered to be invalid, and have undefined
             * behaviour. See the [introduction][ginitable] for more details.
             *
             * Callers should not assume that a class which implements #GInitable can be
             * initialized multiple times, unless the class explicitly documents itself as
             * supporting this. Generally, a class’ implementation of init() can assume
             * (and assert) that it will only be called once. Previously, this documentation
             * recommended all #GInitable implementations should be idempotent; that
             * recommendation was relaxed in GLib 2.54.
             *
             * If a class explicitly supports being initialized multiple times, it is
             * recommended that the method is idempotent: multiple calls with the same
             * arguments should return the same results. Only the first call initializes
             * the object; further calls return the result of the first call.
             *
             * One reason why a class might need to support idempotent initialization is if
             * it is designed to be used via the singleton pattern, with a
             * #GObjectClass.constructor that sometimes returns an existing instance.
             * In this pattern, a caller would expect to be able to call g_initable_init()
             * on the result of g_object_new(), regardless of whether it is in fact a new
             * instance.
             */
            vfunc_init(cancellable?: Cancellable | null): boolean;
        }

        export const Initable: InitableNamespace;

        /**
         * #GListModel is an interface that represents a mutable list of
         * #GObjects. Its main intention is as a model for various widgets in
         * user interfaces, such as list views, but it can also be used as a
         * convenient method of returning lists of data, with support for
         * updates.
         *
         * Each object in the list may also report changes in itself via some
         * mechanism (normally the #GObject::notify signal).  Taken together
         * with the #GListModel::items-changed signal, this provides for a list
         * that can change its membership, and in which the members can change
         * their individual properties.
         *
         * A good example would be the list of visible wireless network access
         * points, where each access point can report dynamic properties such as
         * signal strength.
         *
         * It is important to note that the #GListModel itself does not report
         * changes to the individual items.  It only reports changes to the list
         * membership.  If you want to observe changes to the objects themselves
         * then you need to connect signals to the objects that you are
         * interested in.
         *
         * All items in a #GListModel are of (or derived from) the same type.
         * g_list_model_get_item_type() returns that type.  The type may be an
         * interface, in which case all objects in the list must implement it.
         *
         * The semantics are close to that of an array:
         * g_list_model_get_n_items() returns the number of items in the list and
         * g_list_model_get_item() returns an item at a (0-based) position. In
         * order to allow implementations to calculate the list length lazily,
         * you can also iterate over items: starting from 0, repeatedly call
         * g_list_model_get_item() until it returns %NULL.
         *
         * An implementation may create objects lazily, but must take care to
         * return the same object for a given position until all references to
         * it are gone.
         *
         * On the other side, a consumer is expected only to hold references on
         * objects that are currently "user visible", in order to facilitate the
         * maximum level of laziness in the implementation of the list and to
         * reduce the required number of signal connections at a given time.
         *
         * This interface is intended only to be used from a single thread.  The
         * thread in which it is appropriate to use it depends on the particular
         * implementation, but typically it will be from the thread that owns
         * the [thread-default main context][g-main-context-push-thread-default]
         * in effect at the time that the model was created.
         *
         * Over time, it has established itself as good practice for listmodel
         * implementations to provide properties `item-type` and `n-items` to
         * ease working with them. While it is not required, it is recommended
         * that implementations provide these two properties. They should return
         * the values of g_list_model_get_item_type() and g_list_model_get_n_items()
         * respectively and be defined as such:
         * |[&lt;!-- language="C" --&gt;
         * properties[PROP_ITEM_TYPE] =
         * g_param_spec_gtype ("item-type", "", "", G_TYPE_OBJECT,
         * G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         * properties[PROP_N_ITEMS] =
         * g_param_spec_uint ("n-items", "", "", 0, G_MAXUINT, 0,
         * G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
         * ]|
         */
        export interface ListModelNamespace {
            $gtype: GObject.GType<ListModel>;
            prototype: ListModelPrototype;
        }
        export type ListModel<A extends GObject.Object = GObject.Object> = ListModelPrototype<A>;
        export interface ListModelPrototype<A extends GObject.Object = GObject.Object> extends GObject.Object {
            // Members

            /**
             * Gets the type of the items in `list.`
             *
             * All items returned from g_list_model_get_item() are of the type
             * returned by this function, or a subtype, or if the type is an
             * interface, they are an implementation of that interface.
             *
             * The item type of a #GListModel can not change during the life of the
             * model.
             */
            get_item_type(): GObject.GType;
            /**
             * Gets the number of items in `list.`
             *
             * Depending on the model implementation, calling this function may be
             * less efficient than iterating the list with increasing values for
             * `position `until g_list_model_get_item() returns %NULL.
             */
            get_n_items(): number;
            /**
             * Get the item at `position.`
             *
             * If `position `is greater than the number of items in list, %NULL is
             * returned.
             *
             * %NULL is never returned for an index that is smaller than the length
             * of the list.
             *
             * This function is meant to be used by language bindings in place
             * of g_list_model_get_item().
             *
             * See also: g_list_model_get_n_items()
             */
            get_item(position: number): A | null;
            /**
             * Emits the #GListModel::items-changed signal on `list.`
             *
             * This function should only be called by classes implementing
             * #GListModel. It has to be called after the internal representation
             * of `list `has been updated, because handlers connected to this signal
             * might query the new state of the list.
             *
             * Implementations must only make changes to the model (as visible to
             * its consumer) in places that will not cause problems for that
             * consumer.  For models that are driven directly by a write API (such
             * as #GListStore), changes can be reported in response to uses of that
             * API.  For models that represent remote data, changes should only be
             * made from a fresh mainloop dispatch.  It is particularly not
             * permitted to make changes in response to a call to the #GListModel
             * consumer API.
             *
             * Stated another way: in general, it is assumed that code making a
             * series of accesses to the model via the API, without returning to the
             * mainloop, and without calling other code, will continue to view the
             * same contents of the model.
             */
            items_changed(position: number, removed: number, added: number): void;
            /**
             * Get the item at `position.` If `position `is greater than the number of
             * items in list, %NULL is returned.
             *
             * %NULL is never returned for an index that is smaller than the length
             * of the list.  See g_list_model_get_n_items().
             */
            vfunc_get_item(position: number): A | null;
            /**
             * Gets the type of the items in `list.`
             *
             * All items returned from g_list_model_get_item() are of the type
             * returned by this function, or a subtype, or if the type is an
             * interface, they are an implementation of that interface.
             *
             * The item type of a #GListModel can not change during the life of the
             * model.
             */
            vfunc_get_item_type(): GObject.GType;
            /**
             * Gets the number of items in `list.`
             *
             * Depending on the model implementation, calling this function may be
             * less efficient than iterating the list with increasing values for
             * `position `until g_list_model_get_item() returns %NULL.
             */
            vfunc_get_n_items(): number;
        }

        export const ListModel: ListModelNamespace;

        /**
         * Extends the #GIcon interface and adds the ability to
         * load icons from streams.
         */
        export interface LoadableIconNamespace {
            $gtype: GObject.GType<LoadableIcon>;
            prototype: LoadableIconPrototype;
        }
        export type LoadableIcon = LoadableIconPrototype;
        export interface LoadableIconPrototype extends Icon {
            // Members

            /**
             * Loads a loadable icon. For the asynchronous version of this function,
             * see g_loadable_icon_load_async().
             */
            load(size: number, cancellable?: Cancellable | null): [InputStream, string];
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(size: number, cancellable?: Cancellable | null): Promise<[InputStream, string]>;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(size: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            load_async(
                size: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[InputStream, string]> | void;
            /**
             * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
             */
            load_finish(res: AsyncResult): [InputStream, string];
            /**
             * Loads a loadable icon. For the asynchronous version of this function,
             * see g_loadable_icon_load_async().
             */
            vfunc_load(size: number, cancellable?: Cancellable | null): [InputStream, string];
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(size: number, cancellable?: Cancellable | null): Promise<[InputStream, string]>;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(
                size: number,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Loads an icon asynchronously. To finish this function, see
             * g_loadable_icon_load_finish(). For the synchronous, blocking
             * version of this function, see g_loadable_icon_load().
             */
            vfunc_load_async(
                size: number,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<[InputStream, string]> | void;
            /**
             * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
             */
            vfunc_load_finish(res: AsyncResult): [InputStream, string];
        }

        export const LoadableIcon: LoadableIconNamespace;

        /**
         * #GMemoryMonitor will monitor system memory and suggest to the application
         * when to free memory so as to leave more room for other applications.
         * It is implemented on Linux using the [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
         * ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).
         *
         * There is also an implementation for use inside Flatpak sandboxes.
         *
         * Possible actions to take when the signal is received are:
         *
         * - Free caches
         * - Save files that haven't been looked at in a while to disk, ready to be reopened when needed
         * - Run a garbage collection cycle
         * - Try and compress fragmented allocations
         * - Exit on idle if the process has no reason to stay around
         * - Call [`malloc_trim(3)`](man:malloc_trim) to return cached heap pages to
         * the kernel (if supported by your libc)
         *
         * Note that some actions may not always improve system performance, and so
         * should be profiled for your application. `malloc_trim()`, for example, may
         * make future heap allocations slower (due to releasing cached heap pages back
         * to the kernel).
         *
         * See #GMemoryMonitorWarningLevel for details on the various warning levels.
         *
         * |[&lt;!-- language="C" --&gt;
         * static void
         * warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
         * {
         * g_debug ("Warning level: %d", level);
         * if (warning_level &gt; G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
         * drop_caches ();
         * }
         *
         * static GMemoryMonitor *
         * monitor_low_memory (void)
         * {
         * GMemoryMonitor *m;
         * m = g_memory_monitor_dup_default ();
         * g_signal_connect (G_OBJECT (m), "low-memory-warning",
         * G_CALLBACK (warning_cb), NULL);
         * return m;
         * }
         * ]|
         *
         * Don't forget to disconnect the #GMemoryMonitor::low-memory-warning
         * signal, and unref the #GMemoryMonitor itself when exiting.
         */
        export interface MemoryMonitorNamespace {
            $gtype: GObject.GType<MemoryMonitor>;
            prototype: MemoryMonitorPrototype;

            /**
             * Gets a reference to the default #GMemoryMonitor for the system.
             */
            dup_default(): MemoryMonitor;
        }
        export type MemoryMonitor = MemoryMonitorPrototype;
        export interface MemoryMonitorPrototype extends Initable {
            // Members

            vfunc_low_memory_warning(level: MemoryMonitorWarningLevel): void;
        }

        export const MemoryMonitor: MemoryMonitorNamespace;

        /**
         * The #GMount interface represents user-visible mounts. Note, when
         * porting from GnomeVFS, #GMount is the moral equivalent of #GnomeVFSVolume.
         *
         * #GMount is a "mounted" filesystem that you can access. Mounted is in
         * quotes because it's not the same as a unix mount, it might be a gvfs
         * mount, but you can still access the files on it if you use GIO. Might or
         * might not be related to a volume object.
         *
         * Unmounting a #GMount instance is an asynchronous operation. For
         * more information about asynchronous operations, see #GAsyncResult
         * and #GTask. To unmount a #GMount instance, first call
         * g_mount_unmount_with_operation() with (at least) the #GMount instance and a
         * #GAsyncReadyCallback.  The callback will be fired when the
         * operation has resolved (either with success or failure), and a
         * #GAsyncResult structure will be passed to the callback.  That
         * callback should then call g_mount_unmount_with_operation_finish() with the #GMount
         * and the #GAsyncResult data to see if the operation was completed
         * successfully.  If an `error `is present when g_mount_unmount_with_operation_finish()
         * is called, then it will be filled with any error information.
         */
        export interface MountNamespace {
            $gtype: GObject.GType<Mount>;
            prototype: MountPrototype;
        }
        export type Mount = MountPrototype;
        export interface MountPrototype extends GObject.Object {
            // Members

            /**
             * Checks if `mount `can be ejected.
             */
            can_eject(): boolean;
            /**
             * Checks if `mount `can be unmounted.
             */
            can_unmount(): boolean;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            eject(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            eject(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            eject(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            eject_finish(result: AsyncResult): boolean;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            eject_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the default location of `mount.` The default location of the given
             * `mount `is a path that reflects the main entry point for the user (e.g.
             * the home directory, or the root of the volume).
             */
            get_default_location(): File;
            /**
             * Gets the drive for the `mount.`
             *
             * This is a convenience method for getting the #GVolume and then
             * using that object to get the #GDrive.
             */
            get_drive(): Drive | null;
            /**
             * Gets the icon for `mount.`
             */
            get_icon(): Icon;
            /**
             * Gets the name of `mount.`
             */
            get_name(): string;
            /**
             * Gets the root directory on `mount.`
             */
            get_root(): File;
            /**
             * Gets the sort key for mount, if any.
             */
            get_sort_key(): string | null;
            /**
             * Gets the symbolic icon for `mount.`
             */
            get_symbolic_icon(): Icon;
            /**
             * Gets the UUID for the `mount.` The reference is typically based on
             * the file system UUID for the mount in question and should be
             * considered an opaque string. Returns %NULL if there is no UUID
             * available.
             */
            get_uuid(): string | null;
            /**
             * Gets the volume for the `mount.`
             */
            get_volume(): Volume | null;
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is an asynchronous operation (see
             * g_mount_guess_content_type_sync() for the synchronous version), and
             * is finished by calling g_mount_guess_content_type_finish() with the
             * `mount `and #GAsyncResult data returned in the `callback.`
             */
            guess_content_type(force_rescan: boolean, cancellable?: Cancellable | null): Promise<string[]>;
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is an asynchronous operation (see
             * g_mount_guess_content_type_sync() for the synchronous version), and
             * is finished by calling g_mount_guess_content_type_finish() with the
             * `mount `and #GAsyncResult data returned in the `callback.`
             */
            guess_content_type(
                force_rescan: boolean,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is an asynchronous operation (see
             * g_mount_guess_content_type_sync() for the synchronous version), and
             * is finished by calling g_mount_guess_content_type_finish() with the
             * `mount `and #GAsyncResult data returned in the `callback.`
             */
            guess_content_type(
                force_rescan: boolean,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string[]> | void;
            /**
             * Finishes guessing content types of `mount.` If any errors occurred
             * during the operation, `error `will be set to contain the errors and
             * %FALSE will be returned. In particular, you may get an
             * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
             * guessing.
             */
            guess_content_type_finish(result: AsyncResult): string[];
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is a synchronous operation and as such may block doing IO;
             * see g_mount_guess_content_type() for the asynchronous version.
             */
            guess_content_type_sync(force_rescan: boolean, cancellable?: Cancellable | null): string[];
            /**
             * Determines if `mount `is shadowed. Applications or libraries should
             * avoid displaying `mount `in the user interface if it is shadowed.
             *
             * A mount is said to be shadowed if there exists one or more user
             * visible objects (currently #GMount objects) with a root that is
             * inside the root of `mount.`
             *
             * One application of shadow mounts is when exposing a single file
             * system that is used to address several logical volumes. In this
             * situation, a #GVolumeMonitor implementation would create two
             * #GVolume objects (for example, one for the camera functionality of
             * the device and one for a SD card reader on the device) with
             * activation URIs `gphoto2://[usb:001,002]/store1/`
             * and `gphoto2://[usb:001,002]/store2/`. When the
             * underlying mount (with root
             * `gphoto2://[usb:001,002]/`) is mounted, said
             * #GVolumeMonitor implementation would create two #GMount objects
             * (each with their root matching the corresponding volume activation
             * root) that would shadow the original mount.
             *
             * The proxy monitor in GVfs 2.26 and later, automatically creates and
             * manage shadow mounts (and shadows the underlying mount) if the
             * activation root on a #GVolume is set.
             */
            is_shadowed(): boolean;
            /**
             * Remounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_remount_finish() with the mount
             * and #GAsyncResults data returned in the `callback.`
             *
             * Remounting is useful when some setting affecting the operation
             * of the volume has been changed, as these may need a remount to
             * take affect. While this is semantically equivalent with unmounting
             * and then remounting not all backends might need to actually be
             * unmounted.
             */
            remount(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Remounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_remount_finish() with the mount
             * and #GAsyncResults data returned in the `callback.`
             *
             * Remounting is useful when some setting affecting the operation
             * of the volume has been changed, as these may need a remount to
             * take affect. While this is semantically equivalent with unmounting
             * and then remounting not all backends might need to actually be
             * unmounted.
             */
            remount(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Remounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_remount_finish() with the mount
             * and #GAsyncResults data returned in the `callback.`
             *
             * Remounting is useful when some setting affecting the operation
             * of the volume has been changed, as these may need a remount to
             * take affect. While this is semantically equivalent with unmounting
             * and then remounting not all backends might need to actually be
             * unmounted.
             */
            remount(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes remounting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            remount_finish(result: AsyncResult): boolean;
            /**
             * Increments the shadow count on `mount.` Usually used by
             * #GVolumeMonitor implementations when creating a shadow mount for
             * mount, see g_mount_is_shadowed() for more information. The caller
             * will need to emit the #GMount::changed signal on `mount `manually.
             */
            shadow(): void;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            unmount(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            unmount(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            unmount(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes unmounting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            unmount_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            unmount_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            unmount_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            unmount_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes unmounting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            unmount_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Decrements the shadow count on `mount.` Usually used by
             * #GVolumeMonitor implementations when destroying a shadow mount for
             * mount, see g_mount_is_shadowed() for more information. The caller
             * will need to emit the #GMount::changed signal on `mount `manually.
             */
            unshadow(): void;
            /**
             * Checks if `mount `can be ejected.
             */
            vfunc_can_eject(): boolean;
            /**
             * Checks if `mount `can be unmounted.
             */
            vfunc_can_unmount(): boolean;
            vfunc_changed(): void;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_eject_finish(result: AsyncResult): boolean;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_eject_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the default location of `mount.` The default location of the given
             * `mount `is a path that reflects the main entry point for the user (e.g.
             * the home directory, or the root of the volume).
             */
            vfunc_get_default_location(): File;
            /**
             * Gets the drive for the `mount.`
             *
             * This is a convenience method for getting the #GVolume and then
             * using that object to get the #GDrive.
             */
            vfunc_get_drive(): Drive | null;
            /**
             * Gets the icon for `mount.`
             */
            vfunc_get_icon(): Icon;
            /**
             * Gets the name of `mount.`
             */
            vfunc_get_name(): string;
            /**
             * Gets the root directory on `mount.`
             */
            vfunc_get_root(): File;
            /**
             * Gets the sort key for mount, if any.
             */
            vfunc_get_sort_key(): string | null;
            /**
             * Gets the symbolic icon for `mount.`
             */
            vfunc_get_symbolic_icon(): Icon;
            /**
             * Gets the UUID for the `mount.` The reference is typically based on
             * the file system UUID for the mount in question and should be
             * considered an opaque string. Returns %NULL if there is no UUID
             * available.
             */
            vfunc_get_uuid(): string | null;
            /**
             * Gets the volume for the `mount.`
             */
            vfunc_get_volume(): Volume | null;
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is an asynchronous operation (see
             * g_mount_guess_content_type_sync() for the synchronous version), and
             * is finished by calling g_mount_guess_content_type_finish() with the
             * `mount `and #GAsyncResult data returned in the `callback.`
             */
            vfunc_guess_content_type(force_rescan: boolean, cancellable?: Cancellable | null): Promise<string[]>;
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is an asynchronous operation (see
             * g_mount_guess_content_type_sync() for the synchronous version), and
             * is finished by calling g_mount_guess_content_type_finish() with the
             * `mount `and #GAsyncResult data returned in the `callback.`
             */
            vfunc_guess_content_type(
                force_rescan: boolean,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is an asynchronous operation (see
             * g_mount_guess_content_type_sync() for the synchronous version), and
             * is finished by calling g_mount_guess_content_type_finish() with the
             * `mount `and #GAsyncResult data returned in the `callback.`
             */
            vfunc_guess_content_type(
                force_rescan: boolean,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string[]> | void;
            /**
             * Finishes guessing content types of `mount.` If any errors occurred
             * during the operation, `error `will be set to contain the errors and
             * %FALSE will be returned. In particular, you may get an
             * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
             * guessing.
             */
            vfunc_guess_content_type_finish(result: AsyncResult): string[];
            /**
             * Tries to guess the type of content stored on `mount.` Returns one or
             * more textual identifiers of well-known content types (typically
             * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
             * memory cards. See the
             * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
             * specification for more on x-content types.
             *
             * This is a synchronous operation and as such may block doing IO;
             * see g_mount_guess_content_type() for the asynchronous version.
             */
            vfunc_guess_content_type_sync(force_rescan: boolean, cancellable?: Cancellable | null): string[];
            vfunc_pre_unmount(): void;
            /**
             * Remounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_remount_finish() with the mount
             * and #GAsyncResults data returned in the `callback.`
             *
             * Remounting is useful when some setting affecting the operation
             * of the volume has been changed, as these may need a remount to
             * take affect. While this is semantically equivalent with unmounting
             * and then remounting not all backends might need to actually be
             * unmounted.
             */
            vfunc_remount(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Remounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_remount_finish() with the mount
             * and #GAsyncResults data returned in the `callback.`
             *
             * Remounting is useful when some setting affecting the operation
             * of the volume has been changed, as these may need a remount to
             * take affect. While this is semantically equivalent with unmounting
             * and then remounting not all backends might need to actually be
             * unmounted.
             */
            vfunc_remount(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Remounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_remount_finish() with the mount
             * and #GAsyncResults data returned in the `callback.`
             *
             * Remounting is useful when some setting affecting the operation
             * of the volume has been changed, as these may need a remount to
             * take affect. While this is semantically equivalent with unmounting
             * and then remounting not all backends might need to actually be
             * unmounted.
             */
            vfunc_remount(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes remounting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_remount_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_unmount(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_unmount(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_unmount(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes unmounting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_unmount_finish(result: AsyncResult): boolean;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_unmount_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_unmount_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Unmounts a mount. This is an asynchronous operation, and is
             * finished by calling g_mount_unmount_with_operation_finish() with the mount
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_unmount_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes unmounting a mount. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_unmount_with_operation_finish(result: AsyncResult): boolean;
            vfunc_unmounted(): void;
        }

        export const Mount: MountNamespace;

        /**
         * #GNetworkMonitor provides an easy-to-use cross-platform API
         * for monitoring network connectivity. On Linux, the available
         * implementations are based on the kernel's netlink interface and
         * on NetworkManager.
         *
         * There is also an implementation for use inside Flatpak sandboxes.
         */
        export interface NetworkMonitorNamespace {
            $gtype: GObject.GType<NetworkMonitor>;
            prototype: NetworkMonitorPrototype;

            /**
             * Gets the default #GNetworkMonitor for the system.
             */
            get_default(): NetworkMonitor;
        }
        export type NetworkMonitor = NetworkMonitorPrototype;
        export interface NetworkMonitorPrototype extends Initable {
            // Properties
            readonly connectivity: NetworkConnectivity;
            readonly network_available: boolean;
            readonly networkAvailable: boolean;
            readonly network_metered: boolean;
            readonly networkMetered: boolean;

            // Members

            /**
             * Attempts to determine whether or not the host pointed to by
             * `connectable `can be reached, without actually trying to connect to
             * it.
             *
             * This may return %TRUE even when #GNetworkMonitor:network-available
             * is %FALSE, if, for example, `monitor `can determine that
             * `connectable `refers to a host on a local network.
             *
             * If `monitor `believes that an attempt to connect to connectable
             * will succeed, it will return %TRUE. Otherwise, it will return
             * %FALSE and set `error `to an appropriate error (such as
             * %G_IO_ERROR_HOST_UNREACHABLE).
             *
             * Note that although this does not attempt to connect to
             * connectable, it may still block for a brief period of time (eg,
             * trying to do multicast DNS on the local network), so if you do not
             * want to block, you should use g_network_monitor_can_reach_async().
             */
            can_reach(connectable: SocketConnectable, cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously attempts to determine whether or not the host
             * pointed to by `connectable `can be reached, without actually
             * trying to connect to it.
             *
             * For more details, see g_network_monitor_can_reach().
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_network_monitor_can_reach_finish()
             * to get the result of the operation.
             */
            can_reach_async(connectable: SocketConnectable, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously attempts to determine whether or not the host
             * pointed to by `connectable `can be reached, without actually
             * trying to connect to it.
             *
             * For more details, see g_network_monitor_can_reach().
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_network_monitor_can_reach_finish()
             * to get the result of the operation.
             */
            can_reach_async(
                connectable: SocketConnectable,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously attempts to determine whether or not the host
             * pointed to by `connectable `can be reached, without actually
             * trying to connect to it.
             *
             * For more details, see g_network_monitor_can_reach().
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_network_monitor_can_reach_finish()
             * to get the result of the operation.
             */
            can_reach_async(
                connectable: SocketConnectable,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an async network connectivity test.
             * See g_network_monitor_can_reach_async().
             */
            can_reach_finish(result: AsyncResult): boolean;
            /**
             * Gets a more detailed networking state than
             * g_network_monitor_get_network_available().
             *
             * If #GNetworkMonitor:network-available is %FALSE, then the
             * connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
             *
             * If #GNetworkMonitor:network-available is %TRUE, then the
             * connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
             * is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
             * the host has a default route, but appears to be unable to actually
             * reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
             * host is trapped behind a "captive portal" that requires some sort
             * of login or acknowledgement before allowing full Internet access).
             *
             * Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
             * %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
             * reachable but others are not. In this case, applications can
             * attempt to connect to remote servers, but should gracefully fall
             * back to their "offline" behavior if the connection attempt fails.
             */
            get_connectivity(): NetworkConnectivity;
            /**
             * Checks if the network is available. "Available" here means that the
             * system has a default route available for at least one of IPv4 or
             * IPv6. It does not necessarily imply that the public Internet is
             * reachable. See #GNetworkMonitor:network-available for more details.
             */
            get_network_available(): boolean;
            /**
             * Checks if the network is metered.
             * See #GNetworkMonitor:network-metered for more details.
             */
            get_network_metered(): boolean;
            /**
             * Attempts to determine whether or not the host pointed to by
             * `connectable `can be reached, without actually trying to connect to
             * it.
             *
             * This may return %TRUE even when #GNetworkMonitor:network-available
             * is %FALSE, if, for example, `monitor `can determine that
             * `connectable `refers to a host on a local network.
             *
             * If `monitor `believes that an attempt to connect to connectable
             * will succeed, it will return %TRUE. Otherwise, it will return
             * %FALSE and set `error `to an appropriate error (such as
             * %G_IO_ERROR_HOST_UNREACHABLE).
             *
             * Note that although this does not attempt to connect to
             * connectable, it may still block for a brief period of time (eg,
             * trying to do multicast DNS on the local network), so if you do not
             * want to block, you should use g_network_monitor_can_reach_async().
             */
            vfunc_can_reach(connectable: SocketConnectable, cancellable?: Cancellable | null): boolean;
            /**
             * Asynchronously attempts to determine whether or not the host
             * pointed to by `connectable `can be reached, without actually
             * trying to connect to it.
             *
             * For more details, see g_network_monitor_can_reach().
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_network_monitor_can_reach_finish()
             * to get the result of the operation.
             */
            vfunc_can_reach_async(connectable: SocketConnectable, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Asynchronously attempts to determine whether or not the host
             * pointed to by `connectable `can be reached, without actually
             * trying to connect to it.
             *
             * For more details, see g_network_monitor_can_reach().
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_network_monitor_can_reach_finish()
             * to get the result of the operation.
             */
            vfunc_can_reach_async(
                connectable: SocketConnectable,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronously attempts to determine whether or not the host
             * pointed to by `connectable `can be reached, without actually
             * trying to connect to it.
             *
             * For more details, see g_network_monitor_can_reach().
             *
             * When the operation is finished, `callback `will be called.
             * You can then call g_network_monitor_can_reach_finish()
             * to get the result of the operation.
             */
            vfunc_can_reach_async(
                connectable: SocketConnectable,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes an async network connectivity test.
             * See g_network_monitor_can_reach_async().
             */
            vfunc_can_reach_finish(result: AsyncResult): boolean;
            vfunc_network_changed(network_available: boolean): void;
        }

        export const NetworkMonitor: NetworkMonitorNamespace;

        /**
         * #GPollableInputStream is implemented by #GInputStreams that
         * can be polled for readiness to read. This can be used when
         * interfacing with a non-GIO API that expects
         * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
         */
        export interface PollableInputStreamNamespace {
            $gtype: GObject.GType<PollableInputStream>;
            prototype: PollableInputStreamPrototype;
        }
        export type PollableInputStream = PollableInputStreamPrototype;
        export interface PollableInputStreamPrototype extends InputStream {
            // Members

            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableInputStream but have only certain instances of that class
             * be pollable. If this method returns %FALSE, then the behavior of
             * other #GPollableInputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be read, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_input_stream_is_readable(), it is possible that
             * the stream may not actually be readable even after the source
             * triggers, so you should use g_pollable_input_stream_read_nonblocking()
             * rather than g_input_stream_read() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be read.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_input_stream_read()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_input_stream_read_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_readable(): boolean;
            /**
             * Attempts to read up to `count `bytes from `stream `into buffer, as
             * with g_input_stream_read(). If `stream `is not currently readable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_input_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is readable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             */
            vfunc_read_nonblocking(): [number, Uint8Array | null];
        }

        export const PollableInputStream: PollableInputStreamNamespace;

        /**
         * #GPollableOutputStream is implemented by #GOutputStreams that
         * can be polled for readiness to write. This can be used when
         * interfacing with a non-GIO API that expects
         * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
         */
        export interface PollableOutputStreamNamespace {
            $gtype: GObject.GType<PollableOutputStream>;
            prototype: PollableOutputStreamPrototype;
        }
        export type PollableOutputStream = PollableOutputStreamPrototype;
        export interface PollableOutputStreamPrototype extends OutputStream {
            // Members

            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
            /**
             * Checks if `stream `is actually pollable. Some classes may implement
             * #GPollableOutputStream but have only certain instances of that
             * class be pollable. If this method returns %FALSE, then the behavior
             * of other #GPollableOutputStream methods is undefined.
             *
             * For any given stream, the value returned by this method is constant;
             * a stream cannot switch from pollable to non-pollable or vice versa.
             */
            vfunc_can_poll(): boolean;
            /**
             * Creates a #GSource that triggers when `stream `can be written, or
             * `cancellable `is triggered or an error occurs. The callback on the
             * source is of the #GPollableSourceFunc type.
             *
             * As with g_pollable_output_stream_is_writable(), it is possible that
             * the stream may not actually be writable even after the source
             * triggers, so you should use g_pollable_output_stream_write_nonblocking()
             * rather than g_output_stream_write() from the callback.
             */
            vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
            /**
             * Checks if `stream `can be written.
             *
             * Note that some stream types may not be able to implement this 100%
             * reliably, and it is possible that a call to g_output_stream_write()
             * after this returns %TRUE would still block. To guarantee
             * non-blocking behavior, you should always use
             * g_pollable_output_stream_write_nonblocking(), which will return a
             * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
             */
            vfunc_is_writable(): boolean;
            /**
             * Attempts to write up to `count `bytes from `buffer `to stream, as
             * with g_output_stream_write(). If `stream `is not currently writable,
             * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `buffer `and
             * `count `in the next write call.
             */
            vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
            /**
             * Attempts to write the bytes contained in the `n_vectors ``vectors `to stream,
             * as with g_output_stream_writev(). If `stream `is not currently writable,
             * this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
             * use g_pollable_output_stream_create_source() to create a #GSource
             * that will be triggered when `stream `is writable. `error `will *not* be
             * set in that case.
             *
             * Note that since this method never blocks, you cannot actually
             * use `cancellable `to cancel it. However, it will return an error
             * if `cancellable `has already been cancelled when you call, which
             * may happen if you call this method after a source triggers due
             * to having been cancelled.
             *
             * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
             * transports like D/TLS require that you re-send the same `vectors `and
             * `n_vectors `in the next write call.
             */
            vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
        }

        export const PollableOutputStream: PollableOutputStreamNamespace;

        /**
         * #GPowerProfileMonitor makes it possible for applications as well as OS components
         * to monitor system power profiles and act upon them. It currently only exports
         * whether the system is in “Power Saver” mode (known as “Low Power” mode on
         * some systems).
         *
         * When in “Low Power” mode, it is recommended that applications:
         * - disable automatic downloads;
         * - reduce the rate of refresh from online sources such as calendar or
         * email synchronisation;
         * - reduce the use of expensive visual effects.
         *
         * It is also likely that OS components providing services to applications will
         * lower their own background activity, for the sake of the system.
         *
         * There are a variety of tools that exist for power consumption analysis, but those
         * usually depend on the OS and hardware used. On Linux, one could use `upower` to
         * monitor the battery discharge rate, `powertop` to check on the background activity
         * or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
         * profile GPU usage.
         *
         * Don't forget to disconnect the #GPowerProfileMonitor::notify::power-saver-enabled
         * signal, and unref the #GPowerProfileMonitor itself when exiting.
         */
        export interface PowerProfileMonitorNamespace {
            $gtype: GObject.GType<PowerProfileMonitor>;
            prototype: PowerProfileMonitorPrototype;

            /**
             * Gets a reference to the default #GPowerProfileMonitor for the system.
             */
            dup_default(): PowerProfileMonitor;
        }
        export type PowerProfileMonitor = PowerProfileMonitorPrototype;
        export interface PowerProfileMonitorPrototype extends Initable {
            // Properties
            readonly power_saver_enabled: boolean;
            readonly powerSaverEnabled: boolean;

            // Members

            /**
             * Gets whether the system is in “Power Saver” mode.
             *
             * You are expected to listen to the
             * #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
             * changed.
             */
            get_power_saver_enabled(): boolean;
        }

        export const PowerProfileMonitor: PowerProfileMonitorNamespace;

        /**
         * A #GProxy handles connecting to a remote host via a given type of
         * proxy server. It is implemented by the 'gio-proxy' extension point.
         * The extensions are named after their proxy protocol name. As an
         * example, a SOCKS5 proxy implementation can be retrieved with the
         * name 'socks5' using the function
         * g_io_extension_point_get_extension_by_name().
         */
        export interface ProxyNamespace {
            $gtype: GObject.GType<Proxy>;
            prototype: ProxyPrototype;

            /**
             * Find the `gio-proxy` extension point for a proxy implementation that supports
             * the specified protocol.
             */
            get_default_for_protocol(protocol: string): Proxy | null;
        }
        export type Proxy = ProxyPrototype;
        export interface ProxyPrototype extends GObject.Object {
            // Members

            /**
             * Given `connection `to communicate with a proxy (eg, a
             * #GSocketConnection that is connected to the proxy server), this
             * does the necessary handshake to connect to proxy_address, and if
             * required, wraps the #GIOStream to handle proxy payload.
             */
            connect(connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null): IOStream;
            connect(...args: never[]): any;
            /**
             * Asynchronous version of g_proxy_connect().
             */
            connect_async(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable?: Cancellable | null
            ): Promise<IOStream>;
            /**
             * Asynchronous version of g_proxy_connect().
             */
            connect_async(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronous version of g_proxy_connect().
             */
            connect_async(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<IOStream> | void;
            /**
             * See g_proxy_connect().
             */
            connect_finish(result: AsyncResult): IOStream;
            /**
             * Some proxy protocols expect to be passed a hostname, which they
             * will resolve to an IP address themselves. Others, like SOCKS4, do
             * not allow this. This function will return %FALSE if `proxy `is
             * implementing such a protocol. When %FALSE is returned, the caller
             * should resolve the destination hostname first, and then pass a
             * #GProxyAddress containing the stringified IP address to
             * g_proxy_connect() or g_proxy_connect_async().
             */
            supports_hostname(): boolean;
            /**
             * Given `connection `to communicate with a proxy (eg, a
             * #GSocketConnection that is connected to the proxy server), this
             * does the necessary handshake to connect to proxy_address, and if
             * required, wraps the #GIOStream to handle proxy payload.
             */
            vfunc_connect(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable?: Cancellable | null
            ): IOStream;
            /**
             * Asynchronous version of g_proxy_connect().
             */
            vfunc_connect_async(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable?: Cancellable | null
            ): Promise<IOStream>;
            /**
             * Asynchronous version of g_proxy_connect().
             */
            vfunc_connect_async(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronous version of g_proxy_connect().
             */
            vfunc_connect_async(
                connection: IOStream,
                proxy_address: ProxyAddress,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<IOStream> | void;
            /**
             * See g_proxy_connect().
             */
            vfunc_connect_finish(result: AsyncResult): IOStream;
            /**
             * Some proxy protocols expect to be passed a hostname, which they
             * will resolve to an IP address themselves. Others, like SOCKS4, do
             * not allow this. This function will return %FALSE if `proxy `is
             * implementing such a protocol. When %FALSE is returned, the caller
             * should resolve the destination hostname first, and then pass a
             * #GProxyAddress containing the stringified IP address to
             * g_proxy_connect() or g_proxy_connect_async().
             */
            vfunc_supports_hostname(): boolean;
        }

        export const Proxy: ProxyNamespace;

        /**
         * #GProxyResolver provides synchronous and asynchronous network proxy
         * resolution. #GProxyResolver is used within #GSocketClient through
         * the method g_socket_connectable_proxy_enumerate().
         *
         * Implementations of #GProxyResolver based on libproxy and GNOME settings can
         * be found in glib-networking. GIO comes with an implementation for use inside
         * Flatpak portals.
         */
        export interface ProxyResolverNamespace {
            $gtype: GObject.GType<ProxyResolver>;
            prototype: ProxyResolverPrototype;

            /**
             * Gets the default #GProxyResolver for the system.
             */
            get_default(): ProxyResolver;
        }
        export type ProxyResolver = ProxyResolverPrototype;
        export interface ProxyResolverPrototype extends GObject.Object {
            // Members

            /**
             * Checks if `resolver `can be used on this system. (This is used
             * internally; g_proxy_resolver_get_default() will only return a proxy
             * resolver that returns %TRUE for this method.)
             */
            is_supported(): boolean;
            /**
             * Looks into the system proxy configuration to determine what proxy,
             * if any, to use to connect to `uri.` The returned proxy URIs are of
             * the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
             * `direct://`, where &lt;protocol&gt; could be http, rtsp, socks
             * or other proxying protocol.
             *
             * If you don't know what network protocol is being used on the
             * socket, you should use `none` as the URI protocol.
             * In this case, the resolver might still return a generic proxy type
             * (such as SOCKS), but would not return protocol-specific proxy types
             * (such as http).
             *
             * `direct://` is used when no proxy is needed.
             * Direct connection should not be attempted unless it is part of the
             * returned array of proxies.
             */
            lookup(uri: string, cancellable?: Cancellable | null): string[];
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            lookup_async(uri: string, cancellable?: Cancellable | null): Promise<string[]>;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            lookup_async(uri: string, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            lookup_async(
                uri: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string[]> | void;
            /**
             * Call this function to obtain the array of proxy URIs when
             * g_proxy_resolver_lookup_async() is complete. See
             * g_proxy_resolver_lookup() for more details.
             */
            lookup_finish(result: AsyncResult): string[];
            /**
             * Checks if `resolver `can be used on this system. (This is used
             * internally; g_proxy_resolver_get_default() will only return a proxy
             * resolver that returns %TRUE for this method.)
             */
            vfunc_is_supported(): boolean;
            /**
             * Looks into the system proxy configuration to determine what proxy,
             * if any, to use to connect to `uri.` The returned proxy URIs are of
             * the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
             * `direct://`, where &lt;protocol&gt; could be http, rtsp, socks
             * or other proxying protocol.
             *
             * If you don't know what network protocol is being used on the
             * socket, you should use `none` as the URI protocol.
             * In this case, the resolver might still return a generic proxy type
             * (such as SOCKS), but would not return protocol-specific proxy types
             * (such as http).
             *
             * `direct://` is used when no proxy is needed.
             * Direct connection should not be attempted unless it is part of the
             * returned array of proxies.
             */
            vfunc_lookup(uri: string, cancellable?: Cancellable | null): string[];
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            vfunc_lookup_async(uri: string, cancellable?: Cancellable | null): Promise<string[]>;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            vfunc_lookup_async(
                uri: string,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
             * details.
             */
            vfunc_lookup_async(
                uri: string,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<string[]> | void;
            /**
             * Call this function to obtain the array of proxy URIs when
             * g_proxy_resolver_lookup_async() is complete. See
             * g_proxy_resolver_lookup() for more details.
             */
            vfunc_lookup_finish(result: AsyncResult): string[];
        }

        export const ProxyResolver: ProxyResolverNamespace;

        /**
         * The GRemoteActionGroup interface is implemented by #GActionGroup
         * instances that either transmit action invocations to other processes
         * or receive action invocations in the local process from other
         * processes.
         *
         * The interface has `_full` variants of the two
         * methods on #GActionGroup used to activate actions:
         * g_action_group_activate_action() and
         * g_action_group_change_action_state(). These variants allow a
         * "platform data" #GVariant to be specified: a dictionary providing
         * context for the action invocation (for example: timestamps, startup
         * notification IDs, etc).
         *
         * #GDBusActionGroup implements #GRemoteActionGroup.  This provides a
         * mechanism to send platform data for action invocations over D-Bus.
         *
         * Additionally, g_dbus_connection_export_action_group() will check if
         * the exported #GActionGroup implements #GRemoteActionGroup and use the
         * `_full` variants of the calls if available.  This
         * provides a mechanism by which to receive platform data for action
         * invocations that arrive by way of D-Bus.
         */
        export interface RemoteActionGroupNamespace {
            $gtype: GObject.GType<RemoteActionGroup>;
            prototype: RemoteActionGroupPrototype;
        }
        export type RemoteActionGroup = RemoteActionGroupPrototype;
        export interface RemoteActionGroupPrototype extends ActionGroup {
            // Members

            /**
             * Activates the remote action.
             *
             * This is the same as g_action_group_activate_action() except that it
             * allows for provision of "platform data" to be sent along with the
             * activation request.  This typically contains details such as the user
             * interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            activate_action_full(
                action_name: string,
                parameter: GLib.Variant | null,
                platform_data: GLib.Variant
            ): void;
            /**
             * Changes the state of a remote action.
             *
             * This is the same as g_action_group_change_action_state() except that
             * it allows for provision of "platform data" to be sent along with the
             * state change request.  This typically contains details such as the
             * user interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
            /**
             * Activates the remote action.
             *
             * This is the same as g_action_group_activate_action() except that it
             * allows for provision of "platform data" to be sent along with the
             * activation request.  This typically contains details such as the user
             * interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            vfunc_activate_action_full(
                action_name: string,
                parameter: GLib.Variant | null,
                platform_data: GLib.Variant
            ): void;
            /**
             * Changes the state of a remote action.
             *
             * This is the same as g_action_group_change_action_state() except that
             * it allows for provision of "platform data" to be sent along with the
             * state change request.  This typically contains details such as the
             * user interaction timestamp or startup notification information.
             *
             * `platform_data `must be non-%NULL and must have the type
             * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
             */
            vfunc_change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
        }

        export const RemoteActionGroup: RemoteActionGroupNamespace;

        /**
         * #GSeekable is implemented by streams (implementations of
         * #GInputStream or #GOutputStream) that support seeking.
         *
         * Seekable streams largely fall into two categories: resizable and
         * fixed-size.
         *
         * #GSeekable on fixed-sized streams is approximately the same as POSIX
         * lseek() on a block device (for example: attempting to seek past the
         * end of the device is an error).  Fixed streams typically cannot be
         * truncated.
         *
         * #GSeekable on resizable streams is approximately the same as POSIX
         * lseek() on a normal file.  Seeking past the end and writing data will
         * usually cause the stream to resize by introducing zero bytes.
         */
        export interface SeekableNamespace {
            $gtype: GObject.GType<Seekable>;
            prototype: SeekablePrototype;
        }
        export type Seekable = SeekablePrototype;
        export interface SeekablePrototype extends GObject.Object {
            // Members

            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            truncate(offset: number, cancellable?: Cancellable | null): boolean;
            /**
             * Tests if the stream supports the #GSeekableIface.
             */
            vfunc_can_seek(): boolean;
            /**
             * Tests if the length of the stream can be adjusted with
             * g_seekable_truncate().
             */
            vfunc_can_truncate(): boolean;
            /**
             * Seeks in the stream by the given offset, modified by `type.`
             *
             * Attempting to seek past the end of the stream will have different
             * results depending on if the stream is fixed-sized or resizable.  If
             * the stream is resizable then seeking past the end and then writing
             * will result in zeros filling the empty space.  Seeking past the end
             * of a resizable stream and reading will result in EOF.  Seeking past
             * the end of a fixed-sized stream will fail.
             *
             * Any operation that would result in a negative offset will fail.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
             */
            vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
            /**
             * Tells the current position within the stream.
             */
            vfunc_tell(): number;
            /**
             * Sets the length of the stream to `offset.` If the stream was previously
             * larger than offset, the extra data is discarded. If the stream was
             * previously shorter than offset, it is extended with NUL ('\0') bytes.
             *
             * If `cancellable `is not %NULL, then the operation can be cancelled by
             * triggering the cancellable object from another thread. If the operation
             * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
             * operation was partially finished when the operation was cancelled the
             * partial result will be returned, without an error.
             */
            vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        }

        export const Seekable: SeekableNamespace;

        /**
         * Objects that describe one or more potential socket endpoints
         * implement #GSocketConnectable. Callers can then use
         * g_socket_connectable_enumerate() to get a #GSocketAddressEnumerator
         * to try out each socket address in turn until one succeeds, as shown
         * in the sample code below.
         *
         * |[&lt;!-- language="C" --&gt;
         * MyConnectionType *
         * connect_to_host (const char    *hostname,
         * guint16        port,
         * GCancellable  *cancellable,
         * GError       **error)
         * {
         * MyConnection *conn = NULL;
         * GSocketConnectable *addr;
         * GSocketAddressEnumerator *enumerator;
         * GSocketAddress *sockaddr;
         * GError *conn_error = NULL;
         *
         * addr = g_network_address_new (hostname, port);
         * enumerator = g_socket_connectable_enumerate (addr);
         * g_object_unref (addr);
         *
         * // Try each sockaddr until we succeed. Record the first connection error,
         * // but not any further ones (since they'll probably be basically the same
         * // as the first).
         * while (!conn &amp;&amp; (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
         * {
         * conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &amp;conn_error);
         * g_object_unref (sockaddr);
         * }
         * g_object_unref (enumerator);
         *
         * if (conn)
         * {
         * if (conn_error)
         * {
         * // We couldn't connect to the first address, but we succeeded
         * // in connecting to a later address.
         * g_error_free (conn_error);
         * }
         * return conn;
         * }
         * else if (error)
         * {
         * /// Either initial lookup failed, or else the caller cancelled us.
         * if (conn_error)
         * g_error_free (conn_error);
         * return NULL;
         * }
         * else
         * {
         * g_error_propagate (error, conn_error);
         * return NULL;
         * }
         * }
         * ]|
         */
        export interface SocketConnectableNamespace {
            $gtype: GObject.GType<SocketConnectable>;
            prototype: SocketConnectablePrototype;
        }
        export type SocketConnectable = SocketConnectablePrototype;
        export interface SocketConnectablePrototype extends GObject.Object {
            // Members

            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            to_string(): string;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable.`
             */
            vfunc_enumerate(): SocketAddressEnumerator;
            /**
             * Creates a #GSocketAddressEnumerator for `connectable `that will
             * return a #GProxyAddress for each of its addresses that you must connect
             * to via a proxy.
             *
             * If `connectable `does not implement
             * g_socket_connectable_proxy_enumerate(), this will fall back to
             * calling g_socket_connectable_enumerate().
             */
            vfunc_proxy_enumerate(): SocketAddressEnumerator;
            /**
             * Format a #GSocketConnectable as a string. This is a human-readable format for
             * use in debugging output, and is not a stable serialization format. It is not
             * suitable for use in user interfaces as it exposes too much information for a
             * user.
             *
             * If the #GSocketConnectable implementation does not support string formatting,
             * the implementation’s type name will be returned as a fallback.
             */
            vfunc_to_string(): string;
        }

        export const SocketConnectable: SocketConnectableNamespace;

        /**
         * TLS (Transport Layer Security, aka SSL) and DTLS backend.
         */
        export interface TlsBackendNamespace {
            $gtype: GObject.GType<TlsBackend>;
            prototype: TlsBackendPrototype;

            /**
             * Gets the default #GTlsBackend for the system.
             */
            get_default(): TlsBackend;
        }
        export type TlsBackend = TlsBackendPrototype;
        export interface TlsBackendPrototype extends GObject.Object {
            // Members

            /**
             * Gets the #GType of backend's #GTlsCertificate implementation.
             */
            get_certificate_type(): GObject.GType;
            /**
             * Gets the #GType of backend's #GTlsClientConnection implementation.
             */
            get_client_connection_type(): GObject.GType;
            /**
             * Gets the default #GTlsDatabase used to verify TLS connections.
             */
            get_default_database(): TlsDatabase;
            /**
             * Gets the #GType of backend’s #GDtlsClientConnection implementation.
             */
            get_dtls_client_connection_type(): GObject.GType;
            /**
             * Gets the #GType of backend’s #GDtlsServerConnection implementation.
             */
            get_dtls_server_connection_type(): GObject.GType;
            /**
             * Gets the #GType of backend's #GTlsFileDatabase implementation.
             */
            get_file_database_type(): GObject.GType;
            /**
             * Gets the #GType of backend's #GTlsServerConnection implementation.
             */
            get_server_connection_type(): GObject.GType;
            /**
             * Set the default #GTlsDatabase used to verify TLS connections
             *
             * Any subsequent call to g_tls_backend_get_default_database() will return
             * the database set in this call.  Existing databases and connections are not
             * modified.
             *
             * Setting a %NULL default database will reset to using the system default
             * database as if g_tls_backend_set_default_database() had never been called.
             */
            set_default_database(database?: TlsDatabase | null): void;
            /**
             * Checks if DTLS is supported. DTLS support may not be available even if TLS
             * support is available, and vice-versa.
             */
            supports_dtls(): boolean;
            /**
             * Checks if TLS is supported; if this returns %FALSE for the default
             * #GTlsBackend, it means no "real" TLS backend is available.
             */
            supports_tls(): boolean;
            /**
             * Gets the default #GTlsDatabase used to verify TLS connections.
             */
            vfunc_get_default_database(): TlsDatabase;
            /**
             * Checks if DTLS is supported. DTLS support may not be available even if TLS
             * support is available, and vice-versa.
             */
            vfunc_supports_dtls(): boolean;
            /**
             * Checks if TLS is supported; if this returns %FALSE for the default
             * #GTlsBackend, it means no "real" TLS backend is available.
             */
            vfunc_supports_tls(): boolean;
        }

        export const TlsBackend: TlsBackendNamespace;

        /**
         * #GTlsClientConnection is the client-side subclass of
         * #GTlsConnection, representing a client-side TLS connection.
         */
        export interface TlsClientConnectionNamespace {
            $gtype: GObject.GType<TlsClientConnection>;
            prototype: TlsClientConnectionPrototype;

            /**
             * Creates a new #GTlsClientConnection wrapping `base_io_stream `(which
             * must have pollable input and output streams) which is assumed to
             * communicate with the server identified by `server_identity.`
             *
             * See the documentation for #GTlsConnection:base-io-stream for restrictions
             * on when application code can run operations on the `base_io_stream `after
             * this function has returned.
             */
            ["new"](base_io_stream: IOStream, server_identity?: SocketConnectable | null): TlsClientConnection;
        }
        export type TlsClientConnection = TlsClientConnectionPrototype;
        export interface TlsClientConnectionPrototype extends TlsConnection {
            // Properties
            readonly accepted_cas: any[];
            readonly acceptedCas: any[];
            server_identity: SocketConnectable;
            serverIdentity: SocketConnectable;
            use_ssl3: boolean;
            useSsl3: boolean;
            validation_flags: TlsCertificateFlags;
            validationFlags: TlsCertificateFlags;

            // Members

            /**
             * Possibly copies session state from one connection to another, for use
             * in TLS session resumption. This is not normally needed, but may be
             * used when the same session needs to be used between different
             * endpoints, as is required by some protocols, such as FTP over TLS.
             * `source `should have already completed a handshake and, since TLS 1.3,
             * it should have been used to read data at least once. `conn `should not
             * have completed a handshake.
             *
             * It is not possible to know whether a call to this function will
             * actually do anything. Because session resumption is normally used
             * only for performance benefit, the TLS backend might not implement
             * this function. Even if implemented, it may not actually succeed in
             * allowing `conn `to resume source's TLS session, because the server
             * may not have sent a session resumption token to source, or it may
             * refuse to accept the token from `conn.` There is no way to know
             * whether a call to this function is actually successful.
             *
             * Using this function is not required to benefit from session
             * resumption. If the TLS backend supports session resumption, the
             * session will be resumed automatically if it is possible to do so
             * without weakening the privacy guarantees normally provided by TLS,
             * without need to call this function. For example, with TLS 1.3,
             * a session ticket will be automatically copied from any
             * #GTlsClientConnection that has previously received session tickets
             * from the server, provided a ticket is available that has not
             * previously been used for session resumption, since session ticket
             * reuse would be a privacy weakness. Using this function causes the
             * ticket to be copied without regard for privacy considerations.
             */
            copy_session_state(source: TlsClientConnection): void;
            /**
             * Gets the list of distinguished names of the Certificate Authorities
             * that the server will accept certificates from. This will be set
             * during the TLS handshake if the server requests a certificate.
             * Otherwise, it will be %NULL.
             *
             * Each item in the list is a #GByteArray which contains the complete
             * subject DN of the certificate authority.
             */
            get_accepted_cas(): GLib.List;
            /**
             * Gets conn's expected server identity
             */
            get_server_identity(): SocketConnectable | null;
            /**
             * SSL 3.0 is no longer supported. See
             * g_tls_client_connection_set_use_ssl3() for details.
             */
            get_use_ssl3(): boolean;
            /**
             * Gets conn's validation flags
             *
             * This function does not work as originally designed and is impossible
             * to use correctly. See #GTlsClientConnection:validation-flags for more
             * information.
             */
            get_validation_flags(): TlsCertificateFlags;
            /**
             * Sets conn's expected server identity, which is used both to tell
             * servers on virtual hosts which certificate to present, and also
             * to let `conn `know what name to look for in the certificate when
             * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
             */
            set_server_identity(identity: SocketConnectable): void;
            /**
             * Since GLib 2.42.1, SSL 3.0 is no longer supported.
             *
             * From GLib 2.42.1 through GLib 2.62, this function could be used to
             * force use of TLS 1.0, the lowest-supported TLS protocol version at
             * the time. In the past, this was needed to connect to broken TLS
             * servers that exhibited protocol version intolerance. Such servers
             * are no longer common, and using TLS 1.0 is no longer considered
             * acceptable.
             *
             * Since GLib 2.64, this function does nothing.
             */
            set_use_ssl3(use_ssl3: boolean): void;
            /**
             * Sets conn's validation flags, to override the default set of
             * checks performed when validating a server certificate. By default,
             * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
             *
             * This function does not work as originally designed and is impossible
             * to use correctly. See #GTlsClientConnection:validation-flags for more
             * information.
             */
            set_validation_flags(flags: TlsCertificateFlags): void;
            /**
             * Possibly copies session state from one connection to another, for use
             * in TLS session resumption. This is not normally needed, but may be
             * used when the same session needs to be used between different
             * endpoints, as is required by some protocols, such as FTP over TLS.
             * `source `should have already completed a handshake and, since TLS 1.3,
             * it should have been used to read data at least once. `conn `should not
             * have completed a handshake.
             *
             * It is not possible to know whether a call to this function will
             * actually do anything. Because session resumption is normally used
             * only for performance benefit, the TLS backend might not implement
             * this function. Even if implemented, it may not actually succeed in
             * allowing `conn `to resume source's TLS session, because the server
             * may not have sent a session resumption token to source, or it may
             * refuse to accept the token from `conn.` There is no way to know
             * whether a call to this function is actually successful.
             *
             * Using this function is not required to benefit from session
             * resumption. If the TLS backend supports session resumption, the
             * session will be resumed automatically if it is possible to do so
             * without weakening the privacy guarantees normally provided by TLS,
             * without need to call this function. For example, with TLS 1.3,
             * a session ticket will be automatically copied from any
             * #GTlsClientConnection that has previously received session tickets
             * from the server, provided a ticket is available that has not
             * previously been used for session resumption, since session ticket
             * reuse would be a privacy weakness. Using this function causes the
             * ticket to be copied without regard for privacy considerations.
             */
            vfunc_copy_session_state(source: TlsClientConnection): void;
        }

        export const TlsClientConnection: TlsClientConnectionNamespace;

        /**
         * #GTlsFileDatabase is implemented by #GTlsDatabase objects which load
         * their certificate information from a file. It is an interface which
         * TLS library specific subtypes implement.
         */
        export interface TlsFileDatabaseNamespace {
            $gtype: GObject.GType<TlsFileDatabase>;
            prototype: TlsFileDatabasePrototype;

            /**
             * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
             * in `anchors `to verify certificate chains.
             *
             * The certificates in `anchors `must be PEM encoded.
             */
            ["new"](anchors: string): TlsFileDatabase;
        }
        export type TlsFileDatabase = TlsFileDatabasePrototype;
        export interface TlsFileDatabasePrototype extends TlsDatabase {
            // Properties
            anchors: string;
        }

        export const TlsFileDatabase: TlsFileDatabaseNamespace;

        /**
         * #GTlsServerConnection is the server-side subclass of #GTlsConnection,
         * representing a server-side TLS connection.
         */
        export interface TlsServerConnectionNamespace {
            $gtype: GObject.GType<TlsServerConnection>;
            prototype: TlsServerConnectionPrototype;

            /**
             * Creates a new #GTlsServerConnection wrapping `base_io_stream `(which
             * must have pollable input and output streams).
             *
             * See the documentation for #GTlsConnection:base-io-stream for restrictions
             * on when application code can run operations on the `base_io_stream `after
             * this function has returned.
             */
            ["new"](base_io_stream: IOStream, certificate?: TlsCertificate | null): TlsServerConnection;
        }
        export type TlsServerConnection = TlsServerConnectionPrototype;
        export interface TlsServerConnectionPrototype extends TlsConnection {
            // Properties
            authentication_mode: TlsAuthenticationMode;
            authenticationMode: TlsAuthenticationMode;
        }

        export const TlsServerConnection: TlsServerConnectionNamespace;

        /**
         * The #GVolume interface represents user-visible objects that can be
         * mounted. Note, when porting from GnomeVFS, #GVolume is the moral
         * equivalent of #GnomeVFSDrive.
         *
         * Mounting a #GVolume instance is an asynchronous operation. For more
         * information about asynchronous operations, see #GAsyncResult and
         * #GTask. To mount a #GVolume, first call g_volume_mount() with (at
         * least) the #GVolume instance, optionally a #GMountOperation object
         * and a #GAsyncReadyCallback.
         *
         * Typically, one will only want to pass %NULL for the
         * #GMountOperation if automounting all volumes when a desktop session
         * starts since it's not desirable to put up a lot of dialogs asking
         * for credentials.
         *
         * The callback will be fired when the operation has resolved (either
         * with success or failure), and a #GAsyncResult instance will be
         * passed to the callback.  That callback should then call
         * g_volume_mount_finish() with the #GVolume instance and the
         * #GAsyncResult data to see if the operation was completed
         * successfully.  If an `error `is present when g_volume_mount_finish()
         * is called, then it will be filled with any error information.
         *
         * ## Volume Identifiers # {#volume-identifier}
         *
         * It is sometimes necessary to directly access the underlying
         * operating system object behind a volume (e.g. for passing a volume
         * to an application via the commandline). For this purpose, GIO
         * allows to obtain an 'identifier' for the volume. There can be
         * different kinds of identifiers, such as Hal UDIs, filesystem labels,
         * traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
         * strings as names for the different kinds of identifiers:
         * %G_VOLUME_IDENTIFIER_KIND_UUID, %G_VOLUME_IDENTIFIER_KIND_LABEL, etc.
         * Use g_volume_get_identifier() to obtain an identifier for a volume.
         *
         *
         * Note that %G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available
         * when the gvfs hal volume monitor is in use. Other volume monitors
         * will generally be able to provide the %G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
         * identifier, which can be used to obtain a hal device by means of
         * libhal_manager_find_device_string_match().
         */
        export interface VolumeNamespace {
            $gtype: GObject.GType<Volume>;
            prototype: VolumePrototype;
        }
        export type Volume = VolumePrototype;
        export interface VolumePrototype extends GObject.Object {
            // Members

            /**
             * Checks if a volume can be ejected.
             */
            can_eject(): boolean;
            /**
             * Checks if a volume can be mounted.
             */
            can_mount(): boolean;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            eject(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            eject(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            eject(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a volume. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            eject_finish(result: AsyncResult): boolean;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_with_operation_finish() with the volume
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_with_operation_finish() with the volume
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_with_operation_finish() with the volume
             * and #GAsyncResult data returned in the `callback.`
             */
            eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a volume. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            eject_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the kinds of [identifiers][volume-identifier] that `volume `has.
             * Use g_volume_get_identifier() to obtain the identifiers themselves.
             */
            enumerate_identifiers(): string[];
            /**
             * Gets the activation root for a #GVolume if it is known ahead of
             * mount time. Returns %NULL otherwise. If not %NULL and if volume
             * is mounted, then the result of g_mount_get_root() on the
             * #GMount object obtained from g_volume_get_mount() will always
             * either be equal or a prefix of what this function returns. In
             * other words, in code
             *
             * |[&lt;!-- language="C" --&gt;
             * GMount *mount;
             * GFile *mount_root
             * GFile *volume_activation_root;
             *
             * mount = g_volume_get_mount (volume); // mounted, so never NULL
             * mount_root = g_mount_get_root (mount);
             * volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
             * ]|
             * then the expression
             * |[&lt;!-- language="C" --&gt;
             * (g_file_has_prefix (volume_activation_root, mount_root) ||
             * g_file_equal (volume_activation_root, mount_root))
             * ]|
             * will always be %TRUE.
             *
             * Activation roots are typically used in #GVolumeMonitor
             * implementations to find the underlying mount to shadow, see
             * g_mount_is_shadowed() for more details.
             */
            get_activation_root(): File | null;
            /**
             * Gets the drive for the `volume.`
             */
            get_drive(): Drive | null;
            /**
             * Gets the icon for `volume.`
             */
            get_icon(): Icon;
            /**
             * Gets the identifier of the given kind for `volume.`
             * See the [introduction][volume-identifier] for more
             * information about volume identifiers.
             */
            get_identifier(kind: string): string | null;
            /**
             * Gets the mount for the `volume.`
             */
            get_mount(): Mount | null;
            /**
             * Gets the name of `volume.`
             */
            get_name(): string;
            /**
             * Gets the sort key for volume, if any.
             */
            get_sort_key(): string | null;
            /**
             * Gets the symbolic icon for `volume.`
             */
            get_symbolic_icon(): Icon;
            /**
             * Gets the UUID for the `volume.` The reference is typically based on
             * the file system UUID for the volume in question and should be
             * considered an opaque string. Returns %NULL if there is no UUID
             * available.
             */
            get_uuid(): string | null;
            /**
             * Mounts a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_mount_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            mount(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Mounts a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_mount_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            mount(
                flags: MountMountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Mounts a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_mount_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            mount(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes mounting a volume. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             *
             * If the mount operation succeeded, g_volume_get_mount() on volume
             * is guaranteed to return the mount right after calling this
             * function; there's no need to listen for the 'mount-added' signal on
             * #GVolumeMonitor.
             */
            mount_finish(result: AsyncResult): boolean;
            /**
             * Returns whether the volume should be automatically mounted.
             */
            should_automount(): boolean;
            /**
             * Checks if a volume can be ejected.
             */
            vfunc_can_eject(): boolean;
            /**
             * Checks if a volume can be mounted.
             */
            vfunc_can_mount(): boolean;
            vfunc_changed(): void;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            vfunc_eject(flags: MountUnmountFlags, cancellable?: Cancellable | null): Promise<boolean>;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            vfunc_eject(
                flags: MountUnmountFlags,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            vfunc_eject(
                flags: MountUnmountFlags,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a volume. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_eject_finish(result: AsyncResult): boolean;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_with_operation_finish() with the volume
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null
            ): Promise<boolean>;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_with_operation_finish() with the volume
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation: MountOperation | null,
                cancellable: Cancellable | null,
                callback: AsyncReadyCallback<this> | null
            ): void;
            /**
             * Ejects a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_eject_with_operation_finish() with the volume
             * and #GAsyncResult data returned in the `callback.`
             */
            vfunc_eject_with_operation(
                flags: MountUnmountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): Promise<boolean> | void;
            /**
             * Finishes ejecting a volume. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             */
            vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
            /**
             * Gets the kinds of [identifiers][volume-identifier] that `volume `has.
             * Use g_volume_get_identifier() to obtain the identifiers themselves.
             */
            vfunc_enumerate_identifiers(): string[];
            /**
             * Gets the activation root for a #GVolume if it is known ahead of
             * mount time. Returns %NULL otherwise. If not %NULL and if volume
             * is mounted, then the result of g_mount_get_root() on the
             * #GMount object obtained from g_volume_get_mount() will always
             * either be equal or a prefix of what this function returns. In
             * other words, in code
             *
             * |[&lt;!-- language="C" --&gt;
             * GMount *mount;
             * GFile *mount_root
             * GFile *volume_activation_root;
             *
             * mount = g_volume_get_mount (volume); // mounted, so never NULL
             * mount_root = g_mount_get_root (mount);
             * volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
             * ]|
             * then the expression
             * |[&lt;!-- language="C" --&gt;
             * (g_file_has_prefix (volume_activation_root, mount_root) ||
             * g_file_equal (volume_activation_root, mount_root))
             * ]|
             * will always be %TRUE.
             *
             * Activation roots are typically used in #GVolumeMonitor
             * implementations to find the underlying mount to shadow, see
             * g_mount_is_shadowed() for more details.
             */
            vfunc_get_activation_root(): File | null;
            /**
             * Gets the drive for the `volume.`
             */
            vfunc_get_drive(): Drive | null;
            /**
             * Gets the icon for `volume.`
             */
            vfunc_get_icon(): Icon;
            /**
             * Gets the identifier of the given kind for `volume.`
             * See the [introduction][volume-identifier] for more
             * information about volume identifiers.
             */
            vfunc_get_identifier(kind: string): string | null;
            /**
             * Gets the mount for the `volume.`
             */
            vfunc_get_mount(): Mount | null;
            /**
             * Gets the name of `volume.`
             */
            vfunc_get_name(): string;
            /**
             * Gets the sort key for volume, if any.
             */
            vfunc_get_sort_key(): string | null;
            /**
             * Gets the symbolic icon for `volume.`
             */
            vfunc_get_symbolic_icon(): Icon;
            /**
             * Gets the UUID for the `volume.` The reference is typically based on
             * the file system UUID for the volume in question and should be
             * considered an opaque string. Returns %NULL if there is no UUID
             * available.
             */
            vfunc_get_uuid(): string | null;
            /**
             * Finishes mounting a volume. If any errors occurred during the operation,
             * `error `will be set to contain the errors and %FALSE will be returned.
             *
             * If the mount operation succeeded, g_volume_get_mount() on volume
             * is guaranteed to return the mount right after calling this
             * function; there's no need to listen for the 'mount-added' signal on
             * #GVolumeMonitor.
             */
            vfunc_mount_finish(result: AsyncResult): boolean;
            /**
             * Mounts a volume. This is an asynchronous operation, and is
             * finished by calling g_volume_mount_finish() with the volume
             * and #GAsyncResult returned in the `callback.`
             */
            vfunc_mount_fn(
                flags: MountMountFlags,
                mount_operation?: MountOperation | null,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<this> | null
            ): void;
            vfunc_removed(): void;
            /**
             * Returns whether the volume should be automatically mounted.
             */
            vfunc_should_automount(): boolean;
        }

        export const Volume: VolumeNamespace;

        export interface DBusNamespace {
            prototype: DBusPrototype;
            readonly session: DBusConnection;
            readonly system: DBusConnection;
            /**
             * Asynchronously connects to the message bus specified by `bus_type.`
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_bus_get_finish() to get the result of the operation.
             *
             * This is an asynchronous failable function. See g_bus_get_sync() for
             * the synchronous version.
             */
            get(bus_type: BusType, cancellable?: Cancellable | null): Promise<DBusConnection>;
            /**
             * Asynchronously connects to the message bus specified by `bus_type.`
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_bus_get_finish() to get the result of the operation.
             *
             * This is an asynchronous failable function. See g_bus_get_sync() for
             * the synchronous version.
             */
            get(bus_type: BusType, cancellable: Cancellable | null, callback: AsyncReadyCallback<BusType> | null): void;
            /**
             * Asynchronously connects to the message bus specified by `bus_type.`
             *
             * When the operation is finished, `callback `will be invoked. You can
             * then call g_bus_get_finish() to get the result of the operation.
             *
             * This is an asynchronous failable function. See g_bus_get_sync() for
             * the synchronous version.
             */
            get(
                bus_type: BusType,
                cancellable?: Cancellable | null,
                callback?: AsyncReadyCallback<BusType> | null
            ): Promise<DBusConnection> | void;
            /**
             * Finishes an operation started with g_bus_get().
             *
             * The returned object is a singleton, that is, shared with other
             * callers of g_bus_get() and g_bus_get_sync() for `bus_type.` In the
             * event that you need a private message bus connection, use
             * g_dbus_address_get_for_bus_sync() and
             * g_dbus_connection_new_for_address() with
             * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
             * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
             *
             * Note that the returned #GDBusConnection object will (usually) have
             * the #GDBusConnection:exit-on-close property set to %TRUE.
             */
            get_finish(res: AsyncResult): DBusConnection;
            /**
             * Synchronously connects to the message bus specified by `bus_type.`
             * Note that the returned object may shared with other callers,
             * e.g. if two separate parts of a process calls this function with
             * the same bus_type, they will share the same object.
             *
             * This is a synchronous failable function. See g_bus_get() and
             * g_bus_get_finish() for the asynchronous version.
             *
             * The returned object is a singleton, that is, shared with other
             * callers of g_bus_get() and g_bus_get_sync() for `bus_type.` In the
             * event that you need a private message bus connection, use
             * g_dbus_address_get_for_bus_sync() and
             * g_dbus_connection_new_for_address() with
             * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
             * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
             *
             * Note that the returned #GDBusConnection object will (usually) have
             * the #GDBusConnection:exit-on-close property set to %TRUE.
             */
            get_sync(bus_type: BusType, cancellable?: Cancellable | null): DBusConnection;
            /**
             * Version of g_bus_own_name() using closures instead of callbacks for
             * easier binding in other languages.
             */
            own_name(
                bus_type: BusType,
                name: string,
                flags: BusNameOwnerFlags,
                bus_acquired_closure?: GObject.Closure | null,
                name_acquired_closure?: GObject.Closure | null,
                name_lost_closure?: GObject.Closure | null
            ): number;
            /**
             * Version of g_bus_own_name_on_connection() using closures instead of
             * callbacks for easier binding in other languages.
             */
            own_name_on_connection(
                connection: DBusConnection,
                name: string,
                flags: BusNameOwnerFlags,
                name_acquired_closure?: GObject.Closure | null,
                name_lost_closure?: GObject.Closure | null
            ): number;
            /**
             * Stops owning a name.
             *
             * Note that there may still be D-Bus traffic to process (relating to owning
             * and unowning the name) in the current thread-default #GMainContext after
             * this function has returned. You should continue to iterate the #GMainContext
             * until the #GDestroyNotify function passed to g_bus_own_name() is called, in
             * order to avoid memory leaks through callbacks queued on the #GMainContext
             * after it’s stopped being iterated.
             */
            unown_name(owner_id: number): void;
            /**
             * Version of g_bus_watch_name() using closures instead of callbacks for
             * easier binding in other languages.
             */
            watch_name(
                bus_type: BusType,
                name: string,
                flags: BusNameWatcherFlags,
                name_appeared_closure?: GObject.Closure | null,
                name_vanished_closure?: GObject.Closure | null
            ): number;
            /**
             * Stops watching a name.
             *
             * Note that there may still be D-Bus traffic to process (relating to watching
             * and unwatching the name) in the current thread-default #GMainContext after
             * this function has returned. You should continue to iterate the #GMainContext
             * until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
             * order to avoid memory leaks through callbacks queued on the #GMainContext
             * after it’s stopped being iterated.
             */
            unwatch_name(watcher_id: number): void;
            /**
             * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
             * easier binding in other languages.
             */
            watch_name_on_connection(
                connection: DBusConnection,
                name: string,
                flags: BusNameWatcherFlags,
                name_appeared_closure?: GObject.Closure | null,
                name_vanished_closure?: GObject.Closure | null
            ): number;
        }
        export type DBus = DBusPrototype;
        export interface DBusPrototype {}

        export const DBus: DBusNamespace;

        export module DBusExportedObject {
            export interface ConstructorProperties {
                [key: string]: any;
            }
        }
        export class DBusExportedObject {
            static $gtype: GObject.GType<DBusExportedObject>;

            constructor(properties?: Partial<DBusExportedObject.ConstructorProperties>, ...args: any[]);
            _init(properties?: Partial<DBusExportedObject.ConstructorProperties>, ...args: any[]): void;

            // Members

            static wrapJSObject(info: string, obj: any): DBusExportedObject;
            get_info(): DBusInterfaceInfo;
            get_connection(): DBusConnection;
            get_object_path(): string;
            unexport_from_connection(connection: DBusConnection): void;
            ["export"](busConnection: DBusConnection, objectPath: string): void;
            unexport(): void;
            flush(): void;
            emit_signal(name: string, variant: GLib.Variant): void;
            emit_property_changed(name: string, variant: GLib.Variant): void;
        }

        export function _promisify(klass: any, function_name: string, finish_function_name: string): void;
        export interface _LocalFilePrototype extends FilePrototype {}
        export const _LocalFilePrototype: _LocalFilePrototype;

        /**
         * Name of the imported GIR library
         * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
         */
        export const __name__: string;
        /**
         * Version of the imported GIR library
         * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
         */
        export const __version__: string;
    }

    export default Gio2;
}

declare module "gi://Gio" {
    export { default } from "gi://Gio?version=2.0";
}
